üìÅ OS Project Tree (with text file contents)
================================================================================
‚îî‚îÄ‚îÄ 
    ‚îú‚îÄ‚îÄ LICENSE
        ‚îÇ
        ‚îú‚îÄ‚îÄ CONTENT:
        ‚îÇ   Copyright (C) 2023-2025 mintsuki and contributors.
        ‚îÇ   
        ‚îÇ   Permission to use, copy, modify, and/or distribute this software for any
        ‚îÇ   purpose with or without fee is hereby granted.
        ‚îÇ   
        ‚îÇ   THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
        ‚îÇ   REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
        ‚îÇ   FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
        ‚îÇ   INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
        ‚îÇ   LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
        ‚îÇ   OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
        ‚îÇ   PERFORMANCE OF THIS SOFTWARE.
        ‚îÇ
    ‚îú‚îÄ‚îÄ OS-TREE.txt
        ‚îÇ
        ‚îú‚îÄ‚îÄ CONTENT:
        ‚îÇ   <empty>
        ‚îÇ
    ‚îú‚îÄ‚îÄ build.py
        ‚îÇ
        ‚îú‚îÄ‚îÄ CONTENT:
        ‚îÇ   #!/usr/bin/env python3
        ‚îÇ   
        ‚îÇ   import os
        ‚îÇ   import sys
        ‚îÇ   import subprocess
        ‚îÇ   import argparse
        ‚îÇ   from pathlib import Path
        ‚îÇ   import json
        ‚îÇ   import time
        ‚îÇ   
        ‚îÇ   
        ‚îÇ   def run(cmd, check=True, shell=False, cwd=None):
        ‚îÇ       """–£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–∞—è –æ–±—ë—Ä—Ç–∫–∞ –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∫–æ–º–∞–Ω–¥."""
        ‚îÇ       print(f"[RUN] {' '.join(cmd) if isinstance(cmd, list) else cmd}")
        ‚îÇ       result = subprocess.run(cmd, shell=shell, check=check, cwd=cwd)
        ‚îÇ       return result
        ‚îÇ   
        ‚îÇ   
        ‚îÇ   class Builder:
        ‚îÇ       def __init__(self, name=None, version=None):
        ‚îÇ           self.ensure_config()  # ‚Üê –î–æ–±–∞–≤–ª–µ–Ω–æ
        ‚îÇ   
        ‚îÇ           self.ARCH = "x86_64"
        ‚îÇ           self.OUTPUT = "kernel"
        ‚îÇ           self.KERNEL_DIR = Path("kernel")
        ‚îÇ           self.BUILD_DIR = self.KERNEL_DIR / f"bin-{self.ARCH}"
        ‚îÇ           self.OBJ_DIR = self.KERNEL_DIR / f"obj-{self.ARCH}"
        ‚îÇ           self.LINKER_SCRIPT = self.KERNEL_DIR / "linker-scripts" / f"{self.ARCH}.lds"
        ‚îÇ   
        ‚îÇ           TOOLS_DIR = Path("limine-tools")
        ‚îÇ           self.LIMINE_DIR = TOOLS_DIR / "limine"
        ‚îÇ           self.OVMF_DIR = TOOLS_DIR / "ovmf"
        ‚îÇ           self.OVMF_FILE = self.OVMF_DIR / f"ovmf-code-{self.ARCH}.fd"
        ‚îÇ   
        ‚îÇ           self.ISO_DIR = Path("iso_root")
        ‚îÇ           self.ISO_FILE = Path("deer-v0.0.1.iso")
        ‚îÇ           self.HDD_FILE = Path("deer-v0.0.1.hdd")
        ‚îÇ   
        ‚îÇ           self.QEMU = f"qemu-system-{self.ARCH}"
        ‚îÇ   
        ‚îÇ           # –ó–∞–≥—Ä—É–∂–∞–µ–º –∫–æ–Ω—Ñ–∏–≥
        ‚îÇ           with open("os-config.json", 'r', encoding='utf-8') as f:
        ‚îÇ               config = json.load(f)
        ‚îÇ           self.OS_NAME = name or config.get("name", "DEER")
        ‚îÇ           self.OS_VERSION = version or config.get("version", "v0.0.1")
        ‚îÇ   
        ‚îÇ           # –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∏–º–µ–Ω–∏ ISO
        ‚îÇ           timestamp = time.strftime("%Y%m%d-%H%M%S")
        ‚îÇ           safe_name = "".join(c for c in self.OS_NAME if c.isalnum() or c in "._-")
        ‚îÇ           safe_version = "".join(c for c in self.OS_VERSION if c.isalnum() or c in "._-")
        ‚îÇ           self.FINAL_ISO_NAME = f"{safe_name}.{safe_version}-{timestamp}.iso"
        ‚îÇ   
        ‚îÇ           self.DEMO_ISO_DIR = Path("demo_iso")
        ‚îÇ           self.DEMO_ISO_DIR.mkdir(exist_ok=True)
        ‚îÇ   
        ‚îÇ       def clean(self):
        ‚îÇ           """–û—á–∏—Å—Ç–∏—Ç—å –≤—Ä–µ–º–µ–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã —Å–±–æ—Ä–∫–∏ –∏ ISO."""
        ‚îÇ           cleaned = []
        ‚îÇ           if self.BUILD_DIR.exists():
        ‚îÇ               run(["rm", "-rf", str(self.BUILD_DIR)])
        ‚îÇ               cleaned.append(str(self.BUILD_DIR))
        ‚îÇ           if self.OBJ_DIR.exists():
        ‚îÇ               run(["rm", "-rf", str(self.OBJ_DIR)])
        ‚îÇ               cleaned.append(str(self.OBJ_DIR))
        ‚îÇ           if self.ISO_DIR.exists():
        ‚îÇ               run(["rm", "-rf", str(self.ISO_DIR)])
        ‚îÇ               cleaned.append(str(self.ISO_DIR))
        ‚îÇ           if self.ISO_FILE.exists():
        ‚îÇ               self.ISO_FILE.unlink()
        ‚îÇ               cleaned.append(str(self.ISO_FILE))
        ‚îÇ   
        ‚îÇ           if cleaned:
        ‚îÇ               print(f"[OK] –û—á–∏—â–µ–Ω–æ: {', '.join(cleaned)}")
        ‚îÇ           else:
        ‚îÇ               print("[OK] –ù–µ—á–µ–≥–æ —á–∏—Å—Ç–∏—Ç—å.")
        ‚îÇ   
        ‚îÇ       def distclean(self):
        ‚îÇ           """–ü–æ–ª–Ω–∞—è –æ—á–∏—Å—Ç–∫–∞: –≤–∫–ª—é—á–∞—è –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏."""
        ‚îÇ           self.clean()
        ‚îÇ           tools_dir = Path("limine-tools")
        ‚îÇ           if tools_dir.exists():
        ‚îÇ               run(["rm", "-rf", str(tools_dir)])
        ‚îÇ           deps_flag = self.KERNEL_DIR / ".deps-obtained"
        ‚îÇ           if deps_flag.exists():
        ‚îÇ               deps_flag.unlink()
        ‚îÇ           print("[OK] –ü–æ–ª–Ω–∞—è –æ—á–∏—Å—Ç–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞.")
        ‚îÇ   
        ‚îÇ       def ensure_deps(self):
        ‚îÇ           deps_flag = self.KERNEL_DIR / ".deps-obtained"
        ‚îÇ           if not deps_flag.exists():
        ‚îÇ               print("[!] –ó–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã. –ó–∞–ø—É—Å–∫–∞–µ–º get-deps...")
        ‚îÇ               run(["./get-deps"], cwd=str(self.KERNEL_DIR))
        ‚îÇ               deps_flag.touch()
        ‚îÇ       
        ‚îÇ       def ensure_config(self):
        ‚îÇ           """–°–æ–∑–¥–∞—ë—Ç os-config.json, –µ—Å–ª–∏ –æ–Ω –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç."""
        ‚îÇ           config_path = Path("os-config.json")
        ‚îÇ           if config_path.exists():
        ‚îÇ               return
        ‚îÇ   
        ‚îÇ           print(f"[*] –°–æ–∑–¥–∞–Ω–∏–µ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–æ–Ω–Ω–æ–≥–æ —Ñ–∞–π–ª–∞ {config_path}...")
        ‚îÇ   
        ‚îÇ           config_data = {
        ‚îÇ               "name": "DEER",
        ‚îÇ               "version": "v0.0.1",
        ‚îÇ               "description": "A 64-bit operating system for extreme conditions.",
        ‚îÇ               "author": "VeoQeo",
        ‚îÇ               "arch": "x86_64",
        ‚îÇ               "bootloader": "limine",
        ‚îÇ               "website": None,
        ‚îÇ               "license": "MIT"
        ‚îÇ           }
        ‚îÇ   
        ‚îÇ           with open(config_path, 'w', encoding='utf-8') as f:
        ‚îÇ               json.dump(config_data, f, indent=4, ensure_ascii=False)
        ‚îÇ   
        ‚îÇ           print(f"[OK] –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –≤ {config_path}")
        ‚îÇ   
        ‚îÇ       def ensure_linker_scripts(self):
        ‚îÇ           """–°–æ–∑–¥–∞—ë—Ç –ø–∞–ø–∫—É linker-scripts –∏ —Ñ–∞–π–ª x86_64.lds, –µ—Å–ª–∏ –∏—Ö –Ω–µ—Ç."""
        ‚îÇ           script_dir = self.KERNEL_DIR / "linker-scripts"
        ‚îÇ           script_file = script_dir / "x86_64.lds"
        ‚îÇ   
        ‚îÇ           if not script_file.exists():
        ‚îÇ               print(f"[*] –°–æ–∑–¥–∞–Ω–∏–µ {script_file}...")
        ‚îÇ   
        ‚îÇ               lds_content = '''OUTPUT_FORMAT(elf64-x86-64)
        ‚îÇ   
        ‚îÇ   ENTRY(kernel_main)
        ‚îÇ   
        ‚îÇ   PHDRS
        ‚îÇ   {
        ‚îÇ       limine_requests PT_LOAD;
        ‚îÇ       text PT_LOAD;
        ‚îÇ       rodata PT_LOAD;
        ‚îÇ       data PT_LOAD;
        ‚îÇ   }
        ‚îÇ   
        ‚îÇ   SECTIONS
        ‚îÇ   {
        ‚îÇ       . = 0xffffffff80000000;
        ‚îÇ   
        ‚îÇ       .limine_requests : {
        ‚îÇ           KEEP(*(.limine_requests_start))
        ‚îÇ           KEEP(*(.limine_requests))
        ‚îÇ           KEEP(*(.limine_requests_end))
        ‚îÇ       } :limine_requests
        ‚îÇ   
        ‚îÇ       . = ALIGN(CONSTANT(MAXPAGESIZE));
        ‚îÇ   
        ‚îÇ       .text : {
        ‚îÇ           *(.text .text.*)
        ‚îÇ       } :text
        ‚îÇ   
        ‚îÇ       . = ALIGN(CONSTANT(MAXPAGESIZE));
        ‚îÇ   
        ‚îÇ       .rodata : {
        ‚îÇ           *(.rodata .rodata.*)
        ‚îÇ       } :rodata
        ‚îÇ   
        ‚îÇ       .note.gnu.build-id : {
        ‚îÇ           *(.note.gnu.build-id)
        ‚îÇ       } :rodata
        ‚îÇ   
        ‚îÇ       . = ALIGN(CONSTANT(MAXPAGESIZE));
        ‚îÇ   
        ‚îÇ       .data : {
        ‚îÇ           *(.data .data.*)
        ‚îÇ       } :data
        ‚îÇ   
        ‚îÇ       .bss : {
        ‚îÇ           *(.bss .bss.*)
        ‚îÇ           *(COMMON)
        ‚îÇ       } :data
        ‚îÇ   
        ‚îÇ       /DISCARD/ : {
        ‚îÇ           *(.eh_frame*)
        ‚îÇ           *(.note .note.*)
        ‚îÇ       }
        ‚îÇ   }
        ‚îÇ   '''
        ‚îÇ               script_dir.mkdir(exist_ok=True)
        ‚îÇ               with open(script_file, 'w', encoding='utf-8') as f:
        ‚îÇ                   f.write(lds_content.strip() + '\n')
        ‚îÇ               print(f"[OK] –§–∞–π–ª {script_file} —Å–æ–∑–¥–∞–Ω.")
        ‚îÇ           else:
        ‚îÇ               print(f"[OK] –õ–∏–Ω–∫–µ—Ä-—Å–∫—Ä–∏–ø—Ç —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç: {script_file}")
        ‚îÇ   
        ‚îÇ       def build_kernel(self):
        ‚îÇ           print("[*] –°–±–æ—Ä–∫–∞ —è–¥—Ä–∞ –¥–ª—è x86_64...")
        ‚îÇ   
        ‚îÇ           # –ì–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ–º –Ω–∞–ª–∏—á–∏–µ linker-scripts/x86_64.lds
        ‚îÇ           self.ensure_linker_scripts()
        ‚îÇ   
        ‚îÇ           from glob import glob
        ‚îÇ           c_files = [Path(f) for f in glob("src/**/*.c", recursive=True, root_dir=self.KERNEL_DIR)]
        ‚îÇ           s_files = [Path(f) for f in glob("src/**/*.S", recursive=True, root_dir=self.KERNEL_DIR)]
        ‚îÇ           asm_files = [Path(f) for f in glob("src/**/*.asm", recursive=True, root_dir=self.KERNEL_DIR)]
        ‚îÇ   
        ‚îÇ           arch_c = [Path(f) for f in glob("src/arch/x86_64/**/*.c", recursive=True, root_dir=self.KERNEL_DIR)]
        ‚îÇ           arch_s = [Path(f) for f in glob("src/arch/x86_64/**/*.S", recursive=True, root_dir=self.KERNEL_DIR)]
        ‚îÇ           arch_asm = [Path(f) for f in glob("src/arch/x86_64/**/*.asm", recursive=True, root_dir=self.KERNEL_DIR)]
        ‚îÇ   
        ‚îÇ           all_c = c_files + arch_c
        ‚îÇ           all_s = s_files + arch_s
        ‚îÇ           all_asm = asm_files + arch_asm
        ‚îÇ   
        ‚îÇ           objects = []
        ‚îÇ   
        ‚îÇ           CC = os.getenv("CC", "gcc")
        ‚îÇ           LD = os.getenv("LD", "ld")
        ‚îÇ           NASM = "nasm"
        ‚îÇ   
        ‚îÇ           # –û—Å–Ω–æ–≤–Ω—ã–µ —Ñ–ª–∞–≥–∏ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ (–±–µ–∑ SSE)
        ‚îÇ           CFLAGS = [
        ‚îÇ               "-g", "-O2", "-pipe", "-Wall", "-Wextra", "-std=gnu11",
        ‚îÇ               "-ffreestanding", "-fno-stack-protector",
        ‚îÇ               "-fno-stack-check", "-fno-lto", "-fno-PIC",
        ‚îÇ               "-ffunction-sections", "-fdata-sections",
        ‚îÇ               "-m64", "-march=x86-64", "-mabi=sysv",
        ‚îÇ               "-mno-80387", "-mno-mmx", "-mno-sse", "-mno-sse2",
        ‚îÇ               "-mno-red-zone", "-mcmodel=kernel"
        ‚îÇ           ]
        ‚îÇ   
        ‚îÇ           # –°–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ —Ñ–ª–∞–≥–∏ –¥–ª—è SIMD —Ñ–∞–π–ª–æ–≤ –∏ kernel.c (—Å SSE)
        ‚îÇ           SIMD_CFLAGS = [
        ‚îÇ               "-g", "-O2", "-pipe", "-Wall", "-Wextra", "-std=gnu11",
        ‚îÇ               "-ffreestanding", "-fno-stack-protector",
        ‚îÇ               "-fno-stack-check", "-fno-lto", "-fno-PIC",
        ‚îÇ               "-ffunction-sections", "-fdata-sections",
        ‚îÇ               "-m64", "-march=x86-64", "-mabi=sysv",
        ‚îÇ               "-mno-80387", "-mno-mmx", 
        ‚îÇ               # –í–ö–õ–Æ–ß–ê–ï–ú SSE –î–õ–Ø SIMD –§–ê–ô–õ–û–í –ò KERNEL.C:
        ‚îÇ               "-msse", "-msse2",
        ‚îÇ               "-mno-red-zone", "-mcmodel=kernel"
        ‚îÇ           ]
        ‚îÇ   
        ‚îÇ           CPPFLAGS = [
        ‚îÇ               f"-I{self.KERNEL_DIR}/src",
        ‚îÇ               f"-I{self.KERNEL_DIR}/../limine-tools/limine-protocol/include",
        ‚îÇ               f"-isystem{self.KERNEL_DIR}/../limine-tools/freestnd-c-hdrs/include",
        ‚îÇ               "-nostdinc",
        ‚îÇ               "-DLIMINE_API_REVISION=3",
        ‚îÇ               "-MMD", "-MP"
        ‚îÇ           ]
        ‚îÇ   
        ‚îÇ           LDFLAGS = [
        ‚îÇ               "-nostdlib", "-static",
        ‚îÇ               "-z", "max-page-size=0x1000",
        ‚îÇ               "--gc-sections",
        ‚îÇ               f"-T{self.LINKER_SCRIPT}"
        ‚îÇ           ]
        ‚îÇ   
        ‚îÇ           os.makedirs(self.OBJ_DIR, exist_ok=True)
        ‚îÇ   
        ‚îÇ           # –ö–æ–º–ø–∏–ª—è—Ü–∏—è .c —Ñ–∞–π–ª–æ–≤
        ‚îÇ           for src in all_c:
        ‚îÇ               rel_src = Path("src") / src
        ‚îÇ               obj = self.OBJ_DIR / rel_src.with_suffix(".c.o")
        ‚îÇ               os.makedirs(obj.parent, exist_ok=True)
        ‚îÇ               
        ‚îÇ               # –í—ã–±–∏—Ä–∞–µ–º —Ñ–ª–∞–≥–∏ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ñ–∞–π–ª–∞
        ‚îÇ               src_str = str(src)
        ‚îÇ               if "simd" in src_str.lower() or "kernel.c" in src_str:
        ‚îÇ                   # –î–ª—è SIMD —Ñ–∞–π–ª–æ–≤ –∏ kernel.c –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ —Ñ–ª–∞–≥–∏
        ‚îÇ                   print(f"[*] –ö–æ–º–ø–∏–ª—è—Ü–∏—è —Å SSE: {src}")
        ‚îÇ                   cmd = [CC] + SIMD_CFLAGS + CPPFLAGS + ["-c", str(self.KERNEL_DIR / src), "-o", str(obj)]
        ‚îÇ               else:
        ‚îÇ                   # –î–ª—è –≤—Å–µ—Ö –æ—Å—Ç–∞–ª—å–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤ - –æ–±—ã—á–Ω—ã–µ —Ñ–ª–∞–≥–∏
        ‚îÇ                   cmd = [CC] + CFLAGS + CPPFLAGS + ["-c", str(self.KERNEL_DIR / src), "-o", str(obj)]
        ‚îÇ               
        ‚îÇ               run(cmd)
        ‚îÇ               objects.append(obj)
        ‚îÇ   
        ‚îÇ           # –ö–æ–º–ø–∏–ª—è—Ü–∏—è .S —Ñ–∞–π–ª–æ–≤ (–∞—Å—Å–µ–º–±–ª–µ—Ä) - –≤—Å–µ–≥–¥–∞ –±–µ–∑ SSE
        ‚îÇ           for src in all_s:
        ‚îÇ               rel_src = Path("src") / src
        ‚îÇ               obj = self.OBJ_DIR / rel_src.with_suffix(".S.o")
        ‚îÇ               os.makedirs(obj.parent, exist_ok=True)
        ‚îÇ               cmd = [CC] + CFLAGS + CPPFLAGS + ["-c", str(self.KERNEL_DIR / src), "-o", str(obj)]
        ‚îÇ               run(cmd)
        ‚îÇ               objects.append(obj)
        ‚îÇ   
        ‚îÇ           # –ö–æ–º–ø–∏–ª—è—Ü–∏—è .asm —á–µ—Ä–µ–∑ NASM
        ‚îÇ           NASMFLAGS = ["-g", "-F", "dwarf", "-Wall", "-f", "elf64"]
        ‚îÇ           for src in all_asm:
        ‚îÇ               rel_src = Path("src") / src
        ‚îÇ               obj = self.OBJ_DIR / rel_src.with_suffix(".asm.o")
        ‚îÇ               os.makedirs(obj.parent, exist_ok=True)
        ‚îÇ               cmd = [NASM] + NASMFLAGS + [str(self.KERNEL_DIR / src), "-o", str(obj)]
        ‚îÇ               run(cmd)
        ‚îÇ               objects.append(obj)
        ‚îÇ   
        ‚îÇ           # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º font.psf –≤ –æ–±—ä–µ–∫—Ç–Ω—ã–π —Ñ–∞–π–ª
        ‚îÇ           font_psf = self.KERNEL_DIR / "src" / "font.psf"
        ‚îÇ           font_o = self.OBJ_DIR / "font.o"
        ‚îÇ   
        ‚îÇ           if font_psf.exists():
        ‚îÇ               print("[*] –ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è font.psf -> font.o...")
        ‚îÇ               run([
        ‚îÇ                   "objcopy",
        ‚îÇ                   "-I", "binary",
        ‚îÇ                   "-O", "elf64-x86-64",
        ‚îÇ                   "-B", "i386",
        ‚îÇ                   "--redefine-sym", "_binary_kernel_src_font_psf_start=_binary_font_psf_start",
        ‚îÇ                   "--redefine-sym", "_binary_kernel_src_font_psf_end=_binary_font_psf_end",
        ‚îÇ                   "--redefine-sym", "_binary_kernel_src_font_psf_size=_binary_font_psf_size",
        ‚îÇ                   str(font_psf),
        ‚îÇ                   str(font_o)
        ‚îÇ               ])
        ‚îÇ               objects.append(font_o)
        ‚îÇ           else:
        ‚îÇ               print(f"[!] –§–∞–π–ª —à—Ä–∏—Ñ—Ç–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω: {font_psf}")
        ‚îÇ               sys.exit(1)
        ‚îÇ   
        ‚îÇ           # –õ–∏–Ω–∫–æ–≤–∫–∞
        ‚îÇ           kernel_out = self.BUILD_DIR / self.OUTPUT
        ‚îÇ           os.makedirs(self.BUILD_DIR, exist_ok=True)
        ‚îÇ           link_cmd = [LD] + LDFLAGS + [str(obj) for obj in objects] + ["-o", str(kernel_out)]
        ‚îÇ           run(link_cmd)
        ‚îÇ           print(f"[OK] –Ø–¥—Ä–æ —Å–æ–±—Ä–∞–Ω–æ: {kernel_out}")
        ‚îÇ   
        ‚îÇ       def clone_limine(self):
        ‚îÇ           if not self.LIMINE_DIR.parent.exists():
        ‚îÇ               self.LIMINE_DIR.parent.mkdir(parents=True, exist_ok=True)
        ‚îÇ   
        ‚îÇ           if not self.LIMINE_DIR.exists():
        ‚îÇ               print("[*] –ö–ª–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ Limine binary release –≤ limine-tools/limine...")
        ‚îÇ               run([
        ‚îÇ                   "git", "clone",
        ‚îÇ                   "--branch", "v10.x-binary",
        ‚îÇ                   "--depth", "1",
        ‚îÇ                   "https://codeberg.org/Limine/Limine.git",
        ‚îÇ                   str(self.LIMINE_DIR)
        ‚îÇ               ])
        ‚îÇ           run(["make"], cwd=self.LIMINE_DIR)
        ‚îÇ   
        ‚îÇ       def download_ovmf(self):
        ‚îÇ           if not self.OVMF_FILE.parent.exists():
        ‚îÇ               self.OVMF_FILE.parent.mkdir(parents=True, exist_ok=True)
        ‚îÇ   
        ‚îÇ           if not self.OVMF_FILE.exists():
        ‚îÇ               print("[*] –°–∫–∞—á–∏–≤–∞–Ω–∏–µ OVMF –≤ limine-tools/ovmf...")
        ‚îÇ               url = "https://github.com/osdev0/edk2-ovmf-nightly/releases/latest/download/ovmf-code-x86_64.fd"
        ‚îÇ               run(["curl", "-Lo", str(self.OVMF_FILE), url])
        ‚îÇ   
        ‚îÇ       def create_iso(self):
        ‚îÇ           if self.ISO_FILE.exists():
        ‚îÇ               print(f"[*] ISO —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç ‚Äî –ø—Ä–æ–ø—É—Å–∫–∞–µ–º —Å–æ–∑–¥–∞–Ω–∏–µ.")
        ‚îÇ               return
        ‚îÇ   
        ‚îÇ           print("[*] –°–æ–∑–¥–∞–Ω–∏–µ ISO...")
        ‚îÇ   
        ‚îÇ           if self.ISO_DIR.exists():
        ‚îÇ               run(["rm", "-rf", str(self.ISO_DIR)])
        ‚îÇ   
        ‚îÇ           boot_dir = self.ISO_DIR / "boot"
        ‚îÇ           limine_dir = boot_dir / "limine"
        ‚îÇ           efi_dir = self.ISO_DIR / "EFI" / "BOOT"
        ‚îÇ   
        ‚îÇ           for d in [boot_dir, limine_dir, efi_dir]:
        ‚îÇ               d.mkdir(parents=True, exist_ok=True)
        ‚îÇ   
        ‚îÇ           kernel_src = self.BUILD_DIR / self.OUTPUT
        ‚îÇ           run(["cp", str(kernel_src), str(boot_dir / "kernel")])
        ‚îÇ           run(["cp", "limine.conf", str(limine_dir)])
        ‚îÇ   
        ‚îÇ           # –ö–æ–ø–∏—Ä—É–µ–º —Ñ–∞–π–ª—ã Limine –∏–∑ limine-tools
        ‚îÇ           files_to_copy = [
        ‚îÇ               ("limine-bios.sys", "boot/limine"),
        ‚îÇ               ("limine-bios-cd.bin", "boot/limine"),
        ‚îÇ               ("limine-uefi-cd.bin", "boot/limine"),
        ‚îÇ               ("BOOTX64.EFI", "EFI/BOOT"),
        ‚îÇ               ("BOOTIA32.EFI", "EFI/BOOT"),
        ‚îÇ           ]
        ‚îÇ   
        ‚îÇ           for src, dst in files_to_copy:
        ‚îÇ               run(["cp", str(self.LIMINE_DIR / src), str(self.ISO_DIR / dst)])
        ‚îÇ   
        ‚îÇ           # –°–æ–∑–¥–∞—ë–º ISO
        ‚îÇ           xorriso_cmd = [
        ‚îÇ               "xorriso", "-as", "mkisofs", "-R", "-r", "-J",
        ‚îÇ               "-b", "boot/limine/limine-bios-cd.bin",
        ‚îÇ               "-no-emul-boot", "-boot-load-size", "4", "-boot-info-table",
        ‚îÇ               "-hfsplus", "-apm-block-size", "2048",
        ‚îÇ               "--efi-boot", "boot/limine/limine-uefi-cd.bin",
        ‚îÇ               "-efi-boot-part", "--efi-boot-image", "--protective-msdos-label",
        ‚îÇ               str(self.ISO_DIR), "-o", str(self.ISO_FILE)
        ‚îÇ           ]
        ‚îÇ           run(xorriso_cmd)
        ‚îÇ   
        ‚îÇ           # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º Limine –≤ –æ–±—Ä–∞–∑
        ‚îÇ           run([str(self.LIMINE_DIR / "limine"), "bios-install", str(self.ISO_FILE)])
        ‚îÇ           print(f"[OK] ISO —Å–æ–∑–¥–∞–Ω: {self.ISO_FILE}")
        ‚îÇ   
        ‚îÇ       def save_demo_iso(self):
        ‚îÇ           """–ö–æ–ø–∏—Ä—É–µ—Ç ISO –≤ demo_iso/ —Å –∏–º–µ–Ω–µ–º NAME.VERSION-TIMESTAMP.iso"""
        ‚îÇ           dest = self.DEMO_ISO_DIR / self.FINAL_ISO_NAME
        ‚îÇ           run(["cp", str(self.ISO_FILE), str(dest)])
        ‚îÇ           print(f"[OK] ISO —Å–æ—Ö—Ä–∞–Ω—ë–Ω –∫–∞–∫: {dest}")
        ‚îÇ   
        ‚îÇ       def run_qemu_uefi(self, cleanup_after=False):
        ‚îÇ           if not self.ISO_FILE.exists():
        ‚îÇ               print(f"[!] ISO –Ω–µ –Ω–∞–π–¥–µ–Ω: {self.ISO_FILE}")
        ‚îÇ               sys.exit(1)
        ‚îÇ           self.download_ovmf()
        ‚îÇ           cmd = (
        ‚îÇ               f"{self.QEMU} -M q35 "
        ‚îÇ               f"-drive if=pflash,unit=0,format=raw,file={self.OVMF_FILE},readonly=on "
        ‚îÇ               f"-cdrom {self.ISO_FILE} -m 2G "
        ‚îÇ               "-serial stdio" 
        ‚îÇ           )
        ‚îÇ           try:
        ‚îÇ               run(cmd, shell=True)
        ‚îÇ           finally:
        ‚îÇ               if cleanup_after:
        ‚îÇ                   print("\n[CLEANUP] –ó–∞–∫—Ä—ã—Ç–∏–µ QEMU ‚Äî –∑–∞–ø—É—Å–∫ –æ—á–∏—Å—Ç–∫–∏...")
        ‚îÇ                   self.clean()
        ‚îÇ   
        ‚îÇ       def _is_text_file(self, path: Path) -> bool:
        ‚îÇ           """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —Ñ–∞–π–ª —Ç–µ–∫—Å—Ç–æ–≤—ã–º (–±–µ–∑–æ–ø–∞—Å–Ω–æ —á–∏—Ç–∞–µ–º—ã–º)."""
        ‚îÇ           try:
        ‚îÇ               with open(path, 'r', encoding='utf-8') as f:
        ‚îÇ                   f.read(1024)
        ‚îÇ               return True
        ‚îÇ           except (UnicodeDecodeError, PermissionError, IsADirectoryError, FileNotFoundError):
        ‚îÇ               return False
        ‚îÇ   
        ‚îÇ       def generate_tree_with_content(self, output_file="OS-TREE.txt"):
        ‚îÇ           """–ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç OS-TREE.txt —Å –¥–µ—Ä–µ–≤–æ–º –ø—Ä–æ–µ–∫—Ç–∞ –∏ —Å–æ–¥–µ—Ä–∂–∏–º—ã–º —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö —Ñ–∞–π–ª–æ–≤ (—Å –∏—Å–∫–ª—é—á–µ–Ω–∏—è–º–∏)."""
        ‚îÇ           print(f"[*] –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –¥–µ—Ä–µ–≤–∞ —Å–∏—Å—Ç–µ–º—ã –≤ {output_file}...")
        ‚îÇ   
        ‚îÇ           with open(output_file, "w", encoding="utf-8") as out:
        ‚îÇ               root = Path(".")
        ‚îÇ   
        ‚îÇ               skip_dirs = {
        ‚îÇ                   "bin-x86_64", "obj-x86_64",
        ‚îÇ                   "cc-runtime", "freestnd-c-hdrs",
        ‚îÇ                   "limine-protocol", "ovmf", "limine"
        ‚îÇ               }
        ‚îÇ   
        ‚îÇ               exclude_dirs = {"__pycache__", ".git", "iso_root"}
        ‚îÇ               exclude_files = {"*.o", "*.d", "*.fd", "*.iso", "*.hdd", "*.pyc"}
        ‚îÇ   
        ‚îÇ               def should_exclude(p: Path):
        ‚îÇ                   if any(part.startswith('.') for part in p.parts):
        ‚îÇ                       return True
        ‚îÇ                   if any(excl in str(p) for excl in exclude_dirs):
        ‚îÇ                       return True
        ‚îÇ                   if any(p.match(pattern) for pattern in exclude_files):
        ‚îÇ                       return True
        ‚îÇ                   return False
        ‚îÇ   
        ‚îÇ               def write_tree(path: Path, prefix="", is_last=True):
        ‚îÇ                   connector = "‚îî‚îÄ‚îÄ " if is_last else "‚îú‚îÄ‚îÄ "
        ‚îÇ                   out.write(f"{prefix}{connector}{path.name}\n")
        ‚îÇ   
        ‚îÇ                   if path.is_dir():
        ‚îÇ                       if path.name in skip_dirs:
        ‚îÇ                           out.write(f"{prefix}    ‚îî‚îÄ‚îÄ <—Å–∫—Ä—ã—Ç–æ: —Å–∏—Å—Ç–µ–º–Ω–∞—è/–±–∏–Ω–∞—Ä–Ω–∞—è –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è>\n")
        ‚îÇ                           return
        ‚îÇ                       children = sorted([p for p in path.iterdir() if not should_exclude(p)])
        ‚îÇ                       for i, child in enumerate(children):
        ‚îÇ                           extension = "    " if is_last else "‚îÇ   "
        ‚îÇ                           write_tree(child, prefix + extension, i == len(children) - 1)
        ‚îÇ                   else:
        ‚îÇ                       if path.name == "build.py":
        ‚îÇ                           try:
        ‚îÇ                               out.write(f"{prefix}    ‚îÇ\n")
        ‚îÇ                               out.write(f"{prefix}    ‚îú‚îÄ‚îÄ CONTENT:\n")
        ‚îÇ                               with open(path, 'r', encoding='utf-8') as f:
        ‚îÇ                                   content = f.read().strip()
        ‚îÇ                                   lines = content.splitlines() or ["<empty>"]
        ‚îÇ                                   for line in lines:
        ‚îÇ                                       out.write(f"{prefix}    ‚îÇ   {line}\n")
        ‚îÇ                               out.write(f"{prefix}    ‚îÇ\n")
        ‚îÇ                           except Exception as e:
        ‚îÇ                               out.write(f"{prefix}    ‚îÇ   <–æ—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è: {e}>\n")
        ‚îÇ                           return
        ‚îÇ   
        ‚îÇ                       if self._is_text_file(path):
        ‚îÇ                           try:
        ‚îÇ                               out.write(f"{prefix}    ‚îÇ\n")
        ‚îÇ                               out.write(f"{prefix}    ‚îú‚îÄ‚îÄ CONTENT:\n")
        ‚îÇ                               with open(path, 'r', encoding='utf-8') as f:
        ‚îÇ                                   content = f.read().strip()
        ‚îÇ                                   lines = content.splitlines() or ["<empty>"]
        ‚îÇ                                   for line in lines:
        ‚îÇ                                       out.write(f"{prefix}    ‚îÇ   {line}\n")
        ‚îÇ                               out.write(f"{prefix}    ‚îÇ\n")
        ‚îÇ                           except Exception as e:
        ‚îÇ                               out.write(f"{prefix}    ‚îÇ   <–æ—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è: {e}>\n")
        ‚îÇ   
        ‚îÇ               out.write("üìÅ OS Project Tree (with text file contents)\n")
        ‚îÇ               out.write("=" * 80 + "\n")
        ‚îÇ               write_tree(root)
        ‚îÇ   
        ‚îÇ           print(f"[OK] –î–µ—Ä–µ–≤–æ —Å —Å–æ–¥–µ—Ä–∂–∏–º—ã–º —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ –≤ {output_file}")
        ‚îÇ   
        ‚îÇ   
        ‚îÇ   def main():
        ‚îÇ       parser = argparse.ArgumentParser(
        ‚îÇ           description="–°–±–æ—Ä–∫–∞ –∏ –∑–∞–ø—É—Å–∫ DEER OS (x86_64)"
        ‚îÇ       )
        ‚îÇ       parser.add_argument("--run", action="store_true",
        ‚îÇ                           help="–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Å–æ–±—Ä–∞—Ç—å –∏ –∑–∞–ø—É—Å—Ç–∏—Ç—å –≤ QEMU (UEFI –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é)")
        ‚îÇ       parser.add_argument("--clean", action="store_true",
        ‚îÇ                           help="–û—á–∏—Å—Ç–∏—Ç—å –æ–±—ä–µ–∫—Ç–Ω—ã–µ —Ñ–∞–π–ª—ã (–±–µ–∑ –ø–æ—Å–ª–µ–¥—É—é—â–µ–π —Å–±–æ—Ä–∫–∏)")
        ‚îÇ       parser.add_argument("--distclean", action="store_true",
        ‚îÇ                           help="–ü–æ–ª–Ω–∞—è –æ—á–∏—Å—Ç–∫–∞: —É–¥–∞–ª–∏—Ç—å –≤—Å—ë, –≤–∫–ª—é—á–∞—è –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –∏ –æ–±—Ä–∞–∑—ã")
        ‚îÇ       parser.add_argument("--tree", action="store_true",
        ‚îÇ                           help="–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å OS-TREE.txt —Å –¥–µ—Ä–µ–≤–æ–º –∏ —Å–æ–¥–µ—Ä–∂–∏–º—ã–º —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö —Ñ–∞–π–ª–æ–≤")
        ‚îÇ       parser.add_argument("--name", type=str,
        ‚îÇ                           help="–ò–º—è –û–° (–Ω–∞–ø—Ä–∏–º–µ—Ä, MyDeer)")
        ‚îÇ       parser.add_argument("--version", type=str,
        ‚îÇ                           help="–í–µ—Ä—Å–∏—è –û–° (–Ω–∞–ø—Ä–∏–º–µ—Ä, v0.1-alpha)")
        ‚îÇ   
        ‚îÇ       args = parser.parse_args()
        ‚îÇ       builder = Builder(name=args.name, version=args.version)
        ‚îÇ   
        ‚îÇ       if args.clean:
        ‚îÇ           builder.clean()
        ‚îÇ       elif args.distclean:
        ‚îÇ           builder.distclean()
        ‚îÇ       elif args.tree:
        ‚îÇ           builder.generate_tree_with_content()
        ‚îÇ       elif args.run:
        ‚îÇ           builder.ensure_deps()
        ‚îÇ           builder.build_kernel()
        ‚îÇ           builder.clone_limine()
        ‚îÇ           builder.create_iso()
        ‚îÇ           builder.save_demo_iso()  # –°–æ—Ö—Ä–∞–Ω—è–µ–º ISO —Å –∏–º–µ–Ω–µ–º –∏ –≤—Ä–µ–º–µ–Ω–µ–º
        ‚îÇ           builder.generate_tree_with_content()
        ‚îÇ           builder.run_qemu_uefi(cleanup_after=True)
        ‚îÇ       else:
        ‚îÇ           parser.print_help()
        ‚îÇ   
        ‚îÇ   
        ‚îÇ   if __name__ == "__main__":
        ‚îÇ       main()
        ‚îÇ
    ‚îú‚îÄ‚îÄ demo_iso
    ‚îú‚îÄ‚îÄ kernel
    ‚îÇ   ‚îú‚îÄ‚îÄ bin-x86_64
    ‚îÇ       ‚îî‚îÄ‚îÄ <—Å–∫—Ä—ã—Ç–æ: —Å–∏—Å—Ç–µ–º–Ω–∞—è/–±–∏–Ω–∞—Ä–Ω–∞—è –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è>
    ‚îÇ   ‚îú‚îÄ‚îÄ get-deps
    ‚îÇ       ‚îÇ
    ‚îÇ       ‚îú‚îÄ‚îÄ CONTENT:
    ‚îÇ       ‚îÇ   #!/bin/sh
    ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   set -e
    ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   srcdir="$(dirname "$0")"
    ‚îÇ       ‚îÇ   cd "$srcdir"
    ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   clone_repo_commit() {
    ‚îÇ       ‚îÇ       local url="$1"
    ‚îÇ       ‚îÇ       local dir="../limine-tools/$2"
    ‚îÇ       ‚îÇ       local commit="$3"
    ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       if test -d "$dir/.git"; then
    ‚îÇ       ‚îÇ           git -C "$dir" reset --hard
    ‚îÇ       ‚îÇ           git -C "$dir" clean -fd
    ‚îÇ       ‚îÇ           git -C "$dir" -c advice.detachedHead=false checkout "$commit" || exit 1
    ‚îÇ       ‚îÇ       else
    ‚îÇ       ‚îÇ           rm -rf "$dir"
    ‚îÇ       ‚îÇ           git clone "$url" "$dir"
    ‚îÇ       ‚îÇ           git -C "$dir" -c advice.detachedHead=false checkout "$commit" || exit 1
    ‚îÇ       ‚îÇ       fi
    ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   # –°–æ–∑–¥–∞—ë–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é limine-tools –ø—Ä–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏
    ‚îÇ       ‚îÇ   mkdir -p ../limine-tools
    ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   rm -f .deps-obtained
    ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   clone_repo_commit https://codeberg.org/OSDev/freestnd-c-hdrs-0bsd.git freestnd-c-hdrs 5e4e9e70278fe89ea328d359a58aff4f4a94b165
    ‚îÇ       ‚îÇ   clone_repo_commit https://codeberg.org/OSDev/cc-runtime.git cc-runtime dae79833b57a01b9fd3e359ee31def69f5ae899b
    ‚îÇ       ‚îÇ   clone_repo_commit https://codeberg.org/Limine/limine-protocol.git limine-protocol fedf97facd1c473ee8720f8dfd5a71d03490d928
    ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   touch .deps-obtained
    ‚îÇ       ‚îÇ   echo "
    ‚îÇ       ‚îÇ   Dependencies obtained successfully.
    ‚îÇ       ‚îÇ   "
    ‚îÇ       ‚îÇ
    ‚îÇ   ‚îú‚îÄ‚îÄ linker-scripts
    ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ x86_64.lds
    ‚îÇ   ‚îÇ       ‚îÇ
    ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ CONTENT:
    ‚îÇ   ‚îÇ       ‚îÇ   OUTPUT_FORMAT(elf64-x86-64)
    ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ   ‚îÇ       ‚îÇ   ENTRY(kernel_main)
    ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ   ‚îÇ       ‚îÇ   PHDRS
    ‚îÇ   ‚îÇ       ‚îÇ   {
    ‚îÇ   ‚îÇ       ‚îÇ       limine_requests PT_LOAD;
    ‚îÇ   ‚îÇ       ‚îÇ       text PT_LOAD;
    ‚îÇ   ‚îÇ       ‚îÇ       rodata PT_LOAD;
    ‚îÇ   ‚îÇ       ‚îÇ       data PT_LOAD;
    ‚îÇ   ‚îÇ       ‚îÇ   }
    ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ   ‚îÇ       ‚îÇ   SECTIONS
    ‚îÇ   ‚îÇ       ‚îÇ   {
    ‚îÇ   ‚îÇ       ‚îÇ       . = 0xffffffff80000000;
    ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ   ‚îÇ       ‚îÇ       .limine_requests : {
    ‚îÇ   ‚îÇ       ‚îÇ           KEEP(*(.limine_requests_start))
    ‚îÇ   ‚îÇ       ‚îÇ           KEEP(*(.limine_requests))
    ‚îÇ   ‚îÇ       ‚îÇ           KEEP(*(.limine_requests_end))
    ‚îÇ   ‚îÇ       ‚îÇ       } :limine_requests
    ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ   ‚îÇ       ‚îÇ       . = ALIGN(CONSTANT(MAXPAGESIZE));
    ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ   ‚îÇ       ‚îÇ       .text : {
    ‚îÇ   ‚îÇ       ‚îÇ           *(.text .text.*)
    ‚îÇ   ‚îÇ       ‚îÇ       } :text
    ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ   ‚îÇ       ‚îÇ       . = ALIGN(CONSTANT(MAXPAGESIZE));
    ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ   ‚îÇ       ‚îÇ       .rodata : {
    ‚îÇ   ‚îÇ       ‚îÇ           *(.rodata .rodata.*)
    ‚îÇ   ‚îÇ       ‚îÇ       } :rodata
    ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ   ‚îÇ       ‚îÇ       .note.gnu.build-id : {
    ‚îÇ   ‚îÇ       ‚îÇ           *(.note.gnu.build-id)
    ‚îÇ   ‚îÇ       ‚îÇ       } :rodata
    ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ   ‚îÇ       ‚îÇ       . = ALIGN(CONSTANT(MAXPAGESIZE));
    ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ   ‚îÇ       ‚îÇ       .data : {
    ‚îÇ   ‚îÇ       ‚îÇ           *(.data .data.*)
    ‚îÇ   ‚îÇ       ‚îÇ       } :data
    ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ   ‚îÇ       ‚îÇ       .bss : {
    ‚îÇ   ‚îÇ       ‚îÇ           *(.bss .bss.*)
    ‚îÇ   ‚îÇ       ‚îÇ           *(COMMON)
    ‚îÇ   ‚îÇ       ‚îÇ       } :data
    ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ   ‚îÇ       ‚îÇ       /DISCARD/ : {
    ‚îÇ   ‚îÇ       ‚îÇ           *(.eh_frame*)
    ‚îÇ   ‚îÇ       ‚îÇ           *(.note .note.*)
    ‚îÇ   ‚îÇ       ‚îÇ       }
    ‚îÇ   ‚îÇ       ‚îÇ   }
    ‚îÇ   ‚îÇ       ‚îÇ
    ‚îÇ   ‚îú‚îÄ‚îÄ obj-x86_64
    ‚îÇ       ‚îî‚îÄ‚îÄ <—Å–∫—Ä—ã—Ç–æ: —Å–∏—Å—Ç–µ–º–Ω–∞—è/–±–∏–Ω–∞—Ä–Ω–∞—è –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è>
    ‚îÇ   ‚îî‚îÄ‚îÄ src
    ‚îÇ       ‚îú‚îÄ‚îÄ drivers
    ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ pic.c
    ‚îÇ       ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ       ‚îú‚îÄ‚îÄ CONTENT:
    ‚îÇ       ‚îÇ       ‚îÇ   #include "include/drivers/pic.h"
    ‚îÇ       ‚îÇ       ‚îÇ   #include "include/drivers/io.h"
    ‚îÇ       ‚îÇ       ‚îÇ   #include "include/drivers/serial.h"
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   void pic_remap(void) {
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts("[PIC] Remapping PIC...\n");
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // –°–æ—Ö—Ä–∞–Ω—è–µ–º –º–∞—Å–∫–∏
    ‚îÇ       ‚îÇ       ‚îÇ       uint8_t pic1_mask = inb(PIC1_DATA);
    ‚îÇ       ‚îÇ       ‚îÇ       uint8_t pic2_mask = inb(PIC2_DATA);
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // ICW1 - –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
    ‚îÇ       ‚îÇ       ‚îÇ       outb(PIC1_COMMAND, PIC_ICW1_INIT | PIC_ICW1_ICW4);
    ‚îÇ       ‚îÇ       ‚îÇ       outb(PIC2_COMMAND, PIC_ICW1_INIT | PIC_ICW1_ICW4);
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // ICW2 - —Å–º–µ—â–µ–Ω–∏—è
    ‚îÇ       ‚îÇ       ‚îÇ       outb(PIC1_DATA, PIC1_OFFSET);   // IRQ 0-7 -> INT 32-39
    ‚îÇ       ‚îÇ       ‚îÇ       outb(PIC2_DATA, PIC2_OFFSET);   // IRQ 8-15 -> INT 40-47
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // ICW3 - –∫–∞—Å–∫–∞–¥–∏—Ä–æ–≤–∞–Ω–∏–µ
    ‚îÇ       ‚îÇ       ‚îÇ       outb(PIC1_DATA, 0x04);          // PIC1 –∏–º–µ–µ—Ç slave –Ω–∞ IRQ2
    ‚îÇ       ‚îÇ       ‚îÇ       outb(PIC2_DATA, 0x02);          // PIC2 cascade identity
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // ICW4 - –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
    ‚îÇ       ‚îÇ       ‚îÇ       outb(PIC1_DATA, PIC_ICW4_8086);
    ‚îÇ       ‚îÇ       ‚îÇ       outb(PIC2_DATA, PIC_ICW4_8086);
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –º–∞—Å–∫–∏
    ‚îÇ       ‚îÇ       ‚îÇ       outb(PIC1_DATA, pic1_mask);
    ‚îÇ       ‚îÇ       ‚îÇ       outb(PIC2_DATA, pic2_mask);
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts("[PIC] PIC remapped to 0x20-0x2F\n");
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   void pic_send_eoi(uint8_t irq) {
    ‚îÇ       ‚îÇ       ‚îÇ       if (irq >= 8) {
    ‚îÇ       ‚îÇ       ‚îÇ           outb(PIC2_COMMAND, PIC_EOI);
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       outb(PIC1_COMMAND, PIC_EOI);
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   void pic_disable(void) {
    ‚îÇ       ‚îÇ       ‚îÇ       // –ú–∞—Å–∫–∏—Ä—É–µ–º –≤—Å–µ IRQ
    ‚îÇ       ‚îÇ       ‚îÇ       outb(PIC1_DATA, 0xFF);
    ‚îÇ       ‚îÇ       ‚îÇ       outb(PIC2_DATA, 0xFF);
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts("[PIC] PIC disabled\n");
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   void pic_mask_irq(uint8_t irq) {
    ‚îÇ       ‚îÇ       ‚îÇ       uint16_t port;
    ‚îÇ       ‚îÇ       ‚îÇ       uint8_t value;
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       if (irq < 8) {
    ‚îÇ       ‚îÇ       ‚îÇ           port = PIC1_DATA;
    ‚îÇ       ‚îÇ       ‚îÇ       } else {
    ‚îÇ       ‚îÇ       ‚îÇ           port = PIC2_DATA;
    ‚îÇ       ‚îÇ       ‚îÇ           irq -= 8;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       value = inb(port) | (1 << irq);
    ‚îÇ       ‚îÇ       ‚îÇ       outb(port, value);
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   void pic_unmask_irq(uint8_t irq) {
    ‚îÇ       ‚îÇ       ‚îÇ       uint16_t port;
    ‚îÇ       ‚îÇ       ‚îÇ       uint8_t value;
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       if (irq < 8) {
    ‚îÇ       ‚îÇ       ‚îÇ           port = PIC1_DATA;
    ‚îÇ       ‚îÇ       ‚îÇ       } else {
    ‚îÇ       ‚îÇ       ‚îÇ           port = PIC2_DATA;
    ‚îÇ       ‚îÇ       ‚îÇ           irq -= 8;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       value = inb(port) & ~(1 << irq);
    ‚îÇ       ‚îÇ       ‚îÇ       outb(port, value);
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ pit.c
    ‚îÇ       ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ       ‚îú‚îÄ‚îÄ CONTENT:
    ‚îÇ       ‚îÇ       ‚îÇ   #include "include/drivers/pit.h"
    ‚îÇ       ‚îÇ       ‚îÇ   #include "include/drivers/io.h"
    ‚îÇ       ‚îÇ       ‚îÇ   #include "include/drivers/serial.h"
    ‚îÇ       ‚îÇ       ‚îÇ   #include "libc/string.h" 
    ‚îÇ       ‚îÇ       ‚îÇ   #include "libc/stdio.h"
    ‚îÇ       ‚îÇ       ‚îÇ   #include "include/graphics/fb.h"
    ‚îÇ       ‚îÇ       ‚îÇ   #include "include/graphics/font.h"
    ‚îÇ       ‚îÇ       ‚îÇ   #include "include/graphics/color.h"
    ‚îÇ       ‚îÇ       ‚îÇ   #include <limine.h>
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   volatile uint64_t pit_ticks = 0;
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   void pit_init(void) {
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts("[PIT] Initializing PIT...\n");
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —á–∞—Å—Ç–æ—Ç—É
    ‚îÇ       ‚îÇ       ‚îÇ       pit_set_frequency(PIT_DIVIDER);
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts("[PIT] PIT initialized at 1000 Hz\n");
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   void pit_set_frequency(uint32_t divider) {
    ‚îÇ       ‚îÇ       ‚îÇ       uint32_t divisor = PIT_BASE_FREQ / divider;
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∫–æ–º–∞–Ω–¥—É PIT
    ‚îÇ       ‚îÇ       ‚îÇ       outb(PIT_COMMAND, PIT_CHANNEL0_SEL | PIT_ACCESS_LOHI | PIT_MODE3);
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –¥–µ–ª–∏—Ç–µ–ª—å
    ‚îÇ       ‚îÇ       ‚îÇ       outb(PIT_CHANNEL0, divisor & 0xFF);
    ‚îÇ       ‚îÇ       ‚îÇ       outb(PIT_CHANNEL0, (divisor >> 8) & 0xFF);
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   uint64_t pit_get_ticks(void) {
    ‚îÇ       ‚îÇ       ‚îÇ       return pit_ticks;
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   void pit_sleep(uint64_t ms) {
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t target_ticks = pit_ticks + ms;
    ‚îÇ       ‚îÇ       ‚îÇ       while (pit_ticks < target_ticks) {
    ‚îÇ       ‚îÇ       ‚îÇ           asm volatile("hlt");
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è —Ç–∞–π–º–µ—Ä–∞
    ‚îÇ       ‚îÇ       ‚îÇ   void pit_timer_handler(struct registers *regs) {
    ‚îÇ       ‚îÇ       ‚îÇ       (void)regs; 
    ‚îÇ       ‚îÇ       ‚îÇ       pit_ticks++;
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ serial.c
    ‚îÇ       ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ       ‚îú‚îÄ‚îÄ CONTENT:
    ‚îÇ       ‚îÇ       ‚îÇ   #include <stdint.h>
    ‚îÇ       ‚îÇ       ‚îÇ   #include <stddef.h>
    ‚îÇ       ‚îÇ       ‚îÇ   #include "../include/drivers/io.h"
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   #define SERIAL_PORT 0x3F8  // COM1
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   static int is_initialized = 0;
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   void serial_init(void) {
    ‚îÇ       ‚îÇ       ‚îÇ       if (is_initialized) return;
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ       // –û—Ç–∫–ª—é—á–∞–µ–º –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è
    ‚îÇ       ‚îÇ       ‚îÇ       outb(SERIAL_PORT + 1, 0x00);
    ‚îÇ       ‚îÇ       ‚îÇ       // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å–∫–æ—Ä–æ—Å—Ç—å: Divisor Latch Access Bit (DLAB)
    ‚îÇ       ‚îÇ       ‚îÇ       outb(SERIAL_PORT + 3, 0x80);
    ‚îÇ       ‚îÇ       ‚îÇ       // –î–µ–ª–∏—Ç–µ–ª—å —Å–∫–æ—Ä–æ—Å—Ç–∏: 115200 / 115200 = 1 (—Å–∫–æ—Ä–æ—Å—Ç—å: 115200)
    ‚îÇ       ‚îÇ       ‚îÇ       outb(SERIAL_PORT + 0, 0x01);
    ‚îÇ       ‚îÇ       ‚îÇ       outb(SERIAL_PORT + 1, 0x00);
    ‚îÇ       ‚îÇ       ‚îÇ       // 8 –±–∏—Ç –¥–∞–Ω–Ω—ã—Ö, –Ω–µ—Ç —á—ë—Ç–Ω–æ—Å—Ç–∏, 1 —Å—Ç–æ–ø-–±–∏—Ç
    ‚îÇ       ‚îÇ       ‚îÇ       outb(SERIAL_PORT + 3, 0x03);
    ‚îÇ       ‚îÇ       ‚îÇ       // –í–∫–ª—é—á–∞–µ–º FIFO, –æ—á–∏—â–∞–µ–º –±—É—Ñ–µ—Ä—ã
    ‚îÇ       ‚îÇ       ‚îÇ       outb(SERIAL_PORT + 2, 0xC7);
    ‚îÇ       ‚îÇ       ‚îÇ       // IRQs enabled, RTS/DSR set
    ‚îÇ       ‚îÇ       ‚îÇ       outb(SERIAL_PORT + 4, 0x0B);
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ       is_initialized = 1;
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   // –ñ–¥—ë–º, –ø–æ–∫–∞ –ø–æ—Ä—Ç –±—É–¥–µ—Ç –≥–æ—Ç–æ–≤ –∫ –ø–µ—Ä–µ–¥–∞—á–µ
    ‚îÇ       ‚îÇ       ‚îÇ   static void serial_wait_ready(void) {
    ‚îÇ       ‚îÇ       ‚îÇ       while ((inb(SERIAL_PORT + 5) & 0x20) == 0);
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   // –û—Ç–ø—Ä–∞–≤–∏—Ç—å –æ–¥–∏–Ω —Å–∏–º–≤–æ–ª
    ‚îÇ       ‚îÇ       ‚îÇ   void serial_putc(char c) {
    ‚îÇ       ‚îÇ       ‚îÇ       if (!is_initialized) serial_init();
    ‚îÇ       ‚îÇ       ‚îÇ       if (c == '\n') {
    ‚îÇ       ‚îÇ       ‚îÇ           serial_putc('\r');  // \n ‚Üí \r\n
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       serial_wait_ready();
    ‚îÇ       ‚îÇ       ‚îÇ       outb(SERIAL_PORT, c);
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   // –û—Ç–ø—Ä–∞–≤–∏—Ç—å —Å—Ç—Ä–æ–∫—É
    ‚îÇ       ‚îÇ       ‚îÇ   void serial_puts(const char *str) {
    ‚îÇ       ‚îÇ       ‚îÇ       while (*str) {
    ‚îÇ       ‚îÇ       ‚îÇ           serial_putc(*str++);
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ
    ‚îÇ       ‚îú‚îÄ‚îÄ font.psf
    ‚îÇ       ‚îú‚îÄ‚îÄ graphics
    ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ banner.c
    ‚îÇ       ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ       ‚îú‚îÄ‚îÄ CONTENT:
    ‚îÇ       ‚îÇ       ‚îÇ   #include <stdint.h>
    ‚îÇ       ‚îÇ       ‚îÇ   #include <limine.h>
    ‚îÇ       ‚îÇ       ‚îÇ   #include "../include/graphics/fb.h"
    ‚îÇ       ‚îÇ       ‚îÇ   #include "../include/graphics/font.h"
    ‚îÇ       ‚îÇ       ‚îÇ   #include "../include/graphics/banner.h"
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   void draw_deer_banner(struct limine_framebuffer *fb, uint32_t x, uint32_t y, uint32_t color) {
    ‚îÇ       ‚îÇ       ‚îÇ       const char *banner_lines[] = {
    ‚îÇ       ‚îÇ       ‚îÇ           "                                                                                   ",
    ‚îÇ       ‚îÇ       ‚îÇ           "                                                                                   ",
    ‚îÇ       ‚îÇ       ‚îÇ           "DDDDDDDDDDDDD      EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEERRRRRRRRRRRRRRRRR   ",
    ‚îÇ       ‚îÇ       ‚îÇ           "D::::::::::::DDD   E::::::::::::::::::::EE::::::::::::::::::::ER::::::::::::::::R  ",
    ‚îÇ       ‚îÇ       ‚îÇ           "D:::::::::::::::DD E::::::::::::::::::::EE::::::::::::::::::::ER::::::RRRRRR:::::R ",
    ‚îÇ       ‚îÇ       ‚îÇ           "DDD:::::DDDDD:::::DEE::::::EEEEEEEEE::::EEE::::::EEEEEEEEE::::ERR:::::R     R:::::R",
    ‚îÇ       ‚îÇ       ‚îÇ           "  D:::::D    D:::::D E:::::E       EEEEEE  E:::::E       EEEEEE  R::::R     R:::::R",
    ‚îÇ       ‚îÇ       ‚îÇ           "  D:::::D     D:::::DE:::::E               E:::::E               R::::R     R:::::R",
    ‚îÇ       ‚îÇ       ‚îÇ           "  D:::::D     D:::::DE::::::EEEEEEEEEE     E::::::EEEEEEEEEE     R::::RRRRRR:::::R ",
    ‚îÇ       ‚îÇ       ‚îÇ           "  D:::::D     D:::::DE:::::::::::::::E     E:::::::::::::::E     R:::::::::::::RR  ",
    ‚îÇ       ‚îÇ       ‚îÇ           "  D:::::D     D:::::DE:::::::::::::::E     E:::::::::::::::E     R::::RRRRRR:::::R ",
    ‚îÇ       ‚îÇ       ‚îÇ           "  D:::::D     D:::::DE::::::EEEEEEEEEE     E::::::EEEEEEEEEE     R::::R     R:::::R",
    ‚îÇ       ‚îÇ       ‚îÇ           "  D:::::D     D:::::DE:::::E               E:::::E               R::::R     R:::::R",
    ‚îÇ       ‚îÇ       ‚îÇ           "  D:::::D    D:::::D E:::::E       EEEEEE  E:::::E       EEEEEE  R::::R     R:::::R",
    ‚îÇ       ‚îÇ       ‚îÇ           "DDD:::::DDDDD:::::DEE::::::EEEEEEEE:::::EEE::::::EEEEEEEE:::::ERR:::::R     R:::::R",
    ‚îÇ       ‚îÇ       ‚îÇ           "D:::::::::::::::DD E::::::::::::::::::::EE::::::::::::::::::::ER::::::R     R:::::R",
    ‚îÇ       ‚îÇ       ‚îÇ           "D::::::::::::DDD   E::::::::::::::::::::EE::::::::::::::::::::ER::::::R     R:::::R",
    ‚îÇ       ‚îÇ       ‚îÇ           "DDDDDDDDDDDDD      EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEERRRRRRRR     RRRRRRR",
    ‚îÇ       ‚îÇ       ‚îÇ           "                                                                                   ",
    ‚îÇ       ‚îÇ       ‚îÇ           "                                                                                   ",
    ‚îÇ       ‚îÇ       ‚îÇ           "                                                                                   ",
    ‚îÇ       ‚îÇ       ‚îÇ           "                                                                                   ",
    ‚îÇ       ‚îÇ       ‚îÇ           "                                                                                   ",
    ‚îÇ       ‚îÇ       ‚îÇ           "                                                                                   ",
    ‚îÇ       ‚îÇ       ‚îÇ           "                                                                                   "
    ‚îÇ       ‚îÇ       ‚îÇ       };
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       uint32_t current_y = y;
    ‚îÇ       ‚îÇ       ‚îÇ       for (int i = 0; i < 25; i++) {
    ‚îÇ       ‚îÇ       ‚îÇ           fb_draw_string(fb, banner_lines[i], x, current_y, color);
    ‚îÇ       ‚îÇ       ‚îÇ           current_y += 16; // –ü–µ—Ä–µ—Ö–æ–¥ –Ω–∞ —Å–ª–µ–¥—É—é—â—É—é —Å—Ç—Ä–æ–∫—É (–≤—ã—Å–æ—Ç–∞ —à—Ä–∏—Ñ—Ç–∞)
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ fb.c
    ‚îÇ       ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ       ‚îú‚îÄ‚îÄ CONTENT:
    ‚îÇ       ‚îÇ       ‚îÇ   #include <stdint.h>
    ‚îÇ       ‚îÇ       ‚îÇ   #include <stddef.h>
    ‚îÇ       ‚îÇ       ‚îÇ   #include <limine.h>
    ‚îÇ       ‚îÇ       ‚îÇ   #include "../include/graphics/fb.h"
    ‚îÇ       ‚îÇ       ‚îÇ   #include "../include/graphics/font.h"
    ‚îÇ       ‚îÇ       ‚îÇ   #include "../include/graphics/color.h"
    ‚îÇ       ‚îÇ       ‚îÇ   #include "../libc/string.h"
    ‚îÇ       ‚îÇ       ‚îÇ   #include "../include/drivers/serial.h"
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   void fb_draw_pixel(struct limine_framebuffer *fb, uint32_t x, uint32_t y, uint32_t color) {
    ‚îÇ       ‚îÇ       ‚îÇ       if (x >= fb->width || y >= fb->height) return;
    ‚îÇ       ‚îÇ       ‚îÇ       uint32_t *fb_ptr = (uint32_t *)fb->address;
    ‚îÇ       ‚îÇ       ‚îÇ       uint32_t pitch = fb->pitch / 4;
    ‚îÇ       ‚îÇ       ‚îÇ       fb_ptr[y * pitch + x] = color;
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   void fb_fill_rect(struct limine_framebuffer *fb, uint32_t x, uint32_t y, uint32_t w, uint32_t h, uint32_t color) {
    ‚îÇ       ‚îÇ       ‚îÇ       for (uint32_t py = y; py < y + h; py++) {
    ‚îÇ       ‚îÇ       ‚îÇ           for (uint32_t px = x; px < x + w; px++) {
    ‚îÇ       ‚îÇ       ‚îÇ               fb_draw_pixel(fb, px, py, color);
    ‚îÇ       ‚îÇ       ‚îÇ           }
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   void fb_clear(struct limine_framebuffer *fb, uint32_t color) {
    ‚îÇ       ‚îÇ       ‚îÇ       uint32_t *fb_ptr = (uint32_t *)fb->address;
    ‚îÇ       ‚îÇ       ‚îÇ       size_t pixels = fb->width * fb->height;
    ‚îÇ       ‚îÇ       ‚îÇ       for (size_t i = 0; i < pixels; i++) {
    ‚îÇ       ‚îÇ       ‚îÇ           fb_ptr[i] = color;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   int psf_validate(void) {
    ‚îÇ       ‚îÇ       ‚îÇ       const uint8_t *raw = get_font_data();
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–ª—è PSF v2
    ‚îÇ       ‚îÇ       ‚îÇ       if (raw[0] == 0x72 && raw[1] == 0xb5 && 
    ‚îÇ       ‚îÇ       ‚îÇ           raw[2] == 0x4a && raw[3] == 0x86) {
    ‚îÇ       ‚îÇ       ‚îÇ           return 2; // PSF v2
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥–ª—è PSF v1
    ‚îÇ       ‚îÇ       ‚îÇ       if (raw[0] == 0x36 && raw[1] == 0x04) {
    ‚îÇ       ‚îÇ       ‚îÇ           return 1; // PSF v1
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       return 0; // –ù–µ–≤–∞–ª–∏–¥–Ω—ã–π —à—Ä–∏—Ñ—Ç
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   void fb_draw_char(struct limine_framebuffer *fb, char c, uint32_t x, uint32_t y, uint32_t color) {
    ‚îÇ       ‚îÇ       ‚îÇ       const uint8_t *raw = get_font_data();
    ‚îÇ       ‚îÇ       ‚îÇ       uint32_t headersize = 32;
    ‚îÇ       ‚îÇ       ‚îÇ       uint32_t charsiz = *(uint32_t*)(raw + 20);
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       uint8_t *glyphs = (uint8_t*)raw + headersize;
    ‚îÇ       ‚îÇ       ‚îÇ       uint32_t glyph_index;
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–∞–∑–Ω—ã—Ö –¥–∏–∞–ø–∞–∑–æ–Ω–æ–≤ —Å–∏–º–≤–æ–ª–æ–≤
    ‚îÇ       ‚îÇ       ‚îÇ       if ((uint8_t)c < 128) {
    ‚îÇ       ‚îÇ       ‚îÇ           // Basic ASCII - —Ä–∞–±–æ—Ç–∞—é—Ç –æ—Ç–ª–∏—á–Ω–æ!
    ‚îÇ       ‚îÇ       ‚îÇ           glyph_index = (uint8_t)c;
    ‚îÇ       ‚îÇ       ‚îÇ       } else if ((uint8_t)c >= 128) {
    ‚îÇ       ‚îÇ       ‚îÇ           glyph_index = '?'; 
    ‚îÇ       ‚îÇ       ‚îÇ       } else {
    ‚îÇ       ‚îÇ       ‚îÇ           glyph_index = '?'; 
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // –ü—Ä–æ–≤–µ—Ä–∫–∞ –≥—Ä–∞–Ω–∏—Ü
    ‚îÇ       ‚îÇ       ‚îÇ       if (glyph_index >= 512) {
    ‚îÇ       ‚îÇ       ‚îÇ           glyph_index = '?';
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       uint8_t *glyph = &glyphs[glyph_index * charsiz];
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ       // –û—Ç—Ä–∏—Å–æ–≤–∫–∞
    ‚îÇ       ‚îÇ       ‚îÇ       for (uint32_t row = 0; row < 16; row++) {
    ‚îÇ       ‚îÇ       ‚îÇ           uint8_t byte = glyph[row];
    ‚îÇ       ‚îÇ       ‚îÇ           for (uint32_t col = 0; col < 8; col++) {
    ‚îÇ       ‚îÇ       ‚îÇ               if (byte & (0x80 >> col)) {
    ‚îÇ       ‚îÇ       ‚îÇ                   fb_draw_pixel(fb, x + col, y + row, color);
    ‚îÇ       ‚îÇ       ‚îÇ               }
    ‚îÇ       ‚îÇ       ‚îÇ           }
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   void fb_draw_string(struct limine_framebuffer *fb, const char *str, uint32_t x, uint32_t y, uint32_t color) {
    ‚îÇ       ‚îÇ       ‚îÇ       uint32_t orig_x = x;
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ       if (!psf_validate()) return;
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ       while (*str) {
    ‚îÇ       ‚îÇ       ‚îÇ           if (*str == '\n') {
    ‚îÇ       ‚îÇ       ‚îÇ               x = orig_x;
    ‚îÇ       ‚îÇ       ‚îÇ               y += 16;
    ‚îÇ       ‚îÇ       ‚îÇ           } else {
    ‚îÇ       ‚îÇ       ‚îÇ               fb_draw_char(fb, *str, x, y, color);
    ‚îÇ       ‚îÇ       ‚îÇ               x += 8;
    ‚îÇ       ‚îÇ       ‚îÇ           }
    ‚îÇ       ‚îÇ       ‚îÇ           str++;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ
    ‚îÇ       ‚îú‚îÄ‚îÄ include
    ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ drivers
    ‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ io.h
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ CONTENT:
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #ifndef IO_H
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define IO_H
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #include <stdint.h>
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   static inline uint8_t inb(uint16_t port) {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       uint8_t ret;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       asm volatile ("inb %1, %0" : "=a"(ret) : "Nd"(port));
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       return ret;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   static inline void outb(uint16_t port, uint8_t val) {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       asm volatile ("outb %0, %1" : : "a"(val), "Nd"(port));
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #endif // IO_H
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ pic.h
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ CONTENT:
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #ifndef PIC_H
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define PIC_H
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #include <stdint.h>
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // –ü–æ—Ä—Ç—ã PIC
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define PIC1_COMMAND    0x20
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define PIC1_DATA       0x21
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define PIC2_COMMAND    0xA0
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define PIC2_DATA       0xA1
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // –ö–æ–º–∞–Ω–¥—ã PIC
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define PIC_EOI         0x20        // End Of Interrupt
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // ICW1
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define PIC_ICW1_INIT   0x10        // Initialization
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define PIC_ICW1_ICW4   0x01        // ICW4 needed
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // ICW4
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define PIC_ICW4_8086   0x01        // 8086 mode
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // IRQ –±–∞–∑–æ–≤—ã–µ –≤–µ–∫—Ç–æ—Ä—ã
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define PIC1_OFFSET     0x20
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define PIC2_OFFSET     0x28
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // –§—É–Ω–∫—Ü–∏–∏
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void pic_remap(void);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void pic_send_eoi(uint8_t irq);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void pic_disable(void);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void pic_mask_irq(uint8_t irq);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void pic_unmask_irq(uint8_t irq);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #endif // PIC_H
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ pit.h
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ CONTENT:
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #ifndef PIT_H
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define PIT_H
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #include <stdint.h>
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #include "../interrupts/isr.h"
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // –ü–æ—Ä—Ç—ã PIT (Programmable Interval Timer)
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define PIT_CHANNEL0    0x40
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define PIT_CHANNEL1    0x41
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define PIT_CHANNEL2    0x42
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define PIT_COMMAND     0x43
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // –ö–æ–º–∞–Ω–¥—ã PIT
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define PIT_CHANNEL0_SEL    0x00
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define PIT_ACCESS_LOHI     0x30    // Access mode: low then high byte
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define PIT_MODE3           0x06    // Mode 3: square wave generator
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // –ß–∞—Å—Ç–æ—Ç–∞ PIT
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define PIT_BASE_FREQ       1193182
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define PIT_DIVIDER         1000    // 1000 Hz = 1 ms
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   extern volatile uint64_t pit_ticks;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // –§—É–Ω–∫—Ü–∏–∏
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void pit_init(void);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void pit_set_frequency(uint32_t freq);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   uint64_t pit_get_ticks(void);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void pit_sleep(uint64_t ms);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void pit_timer_handler(struct registers *regs);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #endif // PIT_H
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ serial.h
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ CONTENT:
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #ifndef SERIAL_H
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define SERIAL_H
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #include <stdint.h>
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void serial_init(void);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void serial_putc(char c);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void serial_puts(const char *str);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #endif // SERIAL_H
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ graphics
    ‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ banner.h
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ CONTENT:
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #ifndef BANNER_H
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define BANNER_H
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #include <stdint.h>
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #include <limine.h>
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void draw_deer_banner(struct limine_framebuffer *fb, uint32_t x, uint32_t y, uint32_t color);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #endif // BANNER_H
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ color.h
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ CONTENT:
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // kernel/include/graphics/color.h
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #ifndef COLOR_H
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define COLOR_H
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #include <stdint.h>
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define RGB(r, g, b) (((r) << 16) | ((g) << 8) | (b))
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define COLOR_BLACK     RGB(  0,   0,   0)
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define COLOR_WHITE     RGB(255, 255, 255)
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define COLOR_RED       RGB(255,   0,   0)
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define COLOR_GREEN     RGB(  0, 255,   0)
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define COLOR_BLUE      RGB(  0,   0, 255)
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define COLOR_CYAN      RGB(  0, 255, 255)
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define COLOR_MAGENTA   RGB(255,   0, 255)
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define COLOR_YELLOW    RGB(255, 255,   0)
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define COLOR_ORANGE    RGB(255, 165,   0)
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define COLOR_GRAY      RGB(128, 128, 128)
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define COLOR_DARKGRAY  RGB( 64,  64,  64)
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define COLOR_BROWN     RGB(165,  42,  42)
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #endif // COLOR_H
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ fb.h
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ CONTENT:
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #ifndef FB_H
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define FB_H
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #include <stdint.h>
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #include <limine.h>
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void fb_draw_pixel(struct limine_framebuffer *fb, uint32_t x, uint32_t y, uint32_t color);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void fb_fill_rect(struct limine_framebuffer *fb, uint32_t x, uint32_t y, uint32_t w, uint32_t h, uint32_t color);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void fb_clear(struct limine_framebuffer *fb, uint32_t color);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #endif // FB_H
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ font.h
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ CONTENT:
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // kernel/include/graphics/font.h
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #ifndef FONT_H
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define FONT_H
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #include <stdint.h>
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #include <stddef.h>
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –∑–∞–≥–æ–ª–æ–≤–∫–∞ PSFv2
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   struct psf_header {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       uint32_t magic;        // 0x72b54a86
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       uint32_t version;      // 0
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       uint32_t headersize;   // 32
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       uint32_t flags;        // 0 –∏–ª–∏ 1 (–µ—Å—Ç—å —Ç–∞–±–ª–∏—Ü–∞ Unicode)
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       uint32_t numglyph;     // —á–∏—Å–ª–æ –≥–ª–∏—Ñ–æ–≤
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       uint32_t bytesperglyph;// —Ä–∞–∑–º–µ—Ä –æ–¥–Ω–æ–≥–æ –≥–ª–∏—Ñ–∞
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       uint32_t height;       // –≤—ã—Å–æ—Ç–∞ —Å–∏–º–≤–æ–ª–∞
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       uint32_t width;        // —à–∏—Ä–∏–Ω–∞ —Å–∏–º–≤–æ–ª–∞ (–æ–±—ã—á–Ω–æ 8)
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   } __attribute__((packed));
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // –í–Ω–µ—à–Ω–∏–µ —Å–∏–º–≤–æ–ª—ã, —Å–æ–∑–¥–∞–Ω–Ω—ã–µ objcopy ‚Äî –æ–±—ä—è–≤–ª—è–µ–º –∫–∞–∫ uint8_t –¥–ª—è —è—Å–Ω–æ—Å—Ç–∏
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   extern uint8_t _binary_font_psf_start[];
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   extern uint8_t _binary_font_psf_end[];
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // –ü–æ–ª—É—á–∏—Ç—å —É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ –Ω–∞—á–∞–ª–æ –¥–∞–Ω–Ω—ã—Ö —à—Ä–∏—Ñ—Ç–∞
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   static inline const uint8_t* get_font_data(void) {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       return (const uint8_t*)&_binary_font_psf_start;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   static inline size_t get_font_data_size(void) {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       return _binary_font_psf_end - _binary_font_psf_start;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // –ü–æ–ª—É—á–∏—Ç—å –∑–∞–≥–æ–ª–æ–≤–æ–∫ —à—Ä–∏—Ñ—Ç–∞
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   static inline const struct psf_header* get_psf_header(void) {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       return (const struct psf_header*)&_binary_font_psf_start;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // –ü—Ä–æ–≤–µ—Ä–∏—Ç—å, —á—Ç–æ —à—Ä–∏—Ñ—Ç –∫–æ—Ä—Ä–µ–∫—Ç–µ–Ω
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   int psf_validate(void) ;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ —Å–∏–º–≤–æ–ª–∞
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void fb_draw_char(struct limine_framebuffer *fb, char c, uint32_t x, uint32_t y, uint32_t color);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ —Å—Ç—Ä–æ–∫–∏
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void fb_draw_string(struct limine_framebuffer *fb, const char *str, uint32_t x, uint32_t y, uint32_t color);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #endif // FONT_H
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ interrupts
    ‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ idt.h
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ CONTENT:
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #ifndef IDT_H
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define IDT_H
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #include <stdint.h>
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä–∞ IDT
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   struct idt_entry {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       uint16_t base_low;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       uint16_t selector;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       uint8_t ist;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       uint8_t type_attr;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       uint16_t base_middle;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       uint32_t base_high;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       uint32_t zero;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   } __attribute__((packed));
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // –°—Ç—Ä—É–∫—Ç—É—Ä–∞ —É–∫–∞–∑–∞—Ç–µ–ª—è IDT
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   struct idt_ptr {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       uint16_t limit;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       uint64_t base;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   } __attribute__((packed));
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // –ê—Ç—Ä–∏–±—É—Ç—ã –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä–∞ IDT
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define IDT_PRESENT     (1 << 7)
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define IDT_RING0       (0 << 5)
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define IDT_RING3       (3 << 5)
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define IDT_TYPE_INT    0x0E    // 32-bit interrupt gate
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define IDT_TYPE_TRAP   0x0F    // 32-bit trap gate
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // –ò—Å–∫–ª—é—á–µ–Ω–∏—è x86_64
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define EXCEPTION_DIVISION_ERROR        0
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define EXCEPTION_DEBUG                 1
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define EXCEPTION_NMI                   2
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define EXCEPTION_BREAKPOINT            3
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define EXCEPTION_OVERFLOW              4
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define EXCEPTION_BOUND_RANGE           5
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define EXCEPTION_INVALID_OPCODE        6
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define EXCEPTION_DEVICE_NOT_AVAILABLE  7
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define EXCEPTION_DOUBLE_FAULT          8
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define EXCEPTION_COPROCESSOR_SEGMENT   9
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define EXCEPTION_INVALID_TSS           10
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define EXCEPTION_SEGMENT_NOT_PRESENT   11
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define EXCEPTION_STACK_SEGMENT_FAULT   12
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define EXCEPTION_GPF                   13
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define EXCEPTION_PAGE_FAULT            14
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define EXCEPTION_RESERVED              15
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define EXCEPTION_X87_FPU               16
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define EXCEPTION_ALIGNMENT_CHECK       17
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define EXCEPTION_MACHINE_CHECK         18
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define EXCEPTION_SIMD_FPU              19
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define EXCEPTION_VIRTUALIZATION        20
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define EXCEPTION_SECURITY              30
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // –§—É–Ω–∫—Ü–∏–∏
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void idt_init(void);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void idt_load(void);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void idt_set_entry(uint8_t index, uint64_t base, uint16_t selector, uint8_t type_attr);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #endif // IDT_H
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ irq.h
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ CONTENT:
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #ifndef IRQ_H
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define IRQ_H
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #include <stdint.h>
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #include "isr.h"
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // –ù–æ–º–µ—Ä–∞ IRQ
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define IRQ0    32      // Timer
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define IRQ1    33      // Keyboard
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define IRQ2    34      // Cascade
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define IRQ3    35      // COM2
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define IRQ4    36      // COM1
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define IRQ5    37      // LPT2
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define IRQ6    38      // Floppy
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define IRQ7    39      // LPT1
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define IRQ8    40      // CMOS RTC
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define IRQ9    41      // Free
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define IRQ10   42      // Free
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define IRQ11   43      // Free
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define IRQ12   44      // PS/2 Mouse
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define IRQ13   45      // FPU
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define IRQ14   46      // Primary ATA
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define IRQ15   47      // Secondary ATA
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // –§—É–Ω–∫—Ü–∏–∏
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void irq_init(void);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void irq_install_handler(uint8_t irq, isr_handler_t handler);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void irq_uninstall_handler(uint8_t irq);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void irq_handler(struct registers *regs);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #endif // IRQ_H
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ isr.h
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ CONTENT:
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #ifndef ISR_H
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define ISR_H
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #include <stdint.h>
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // –°—Ç—Ä—É–∫—Ç—É—Ä–∞ —Ä–µ–≥–∏—Å—Ç—Ä–æ–≤ –ø—Ä–∏ –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏–∏
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   struct registers {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       uint64_t r15, r14, r13, r12, r11, r10, r9, r8;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       uint64_t rdi, rsi, rbp, rbx, rdx, rcx, rax;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       uint64_t int_no, err_code;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       uint64_t rip, cs, rflags, rsp, ss;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   } __attribute__((packed));
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // –¢–∏–ø –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∞ –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏–π
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   typedef void (*isr_handler_t)(struct registers*);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // –§—É–Ω–∫—Ü–∏–∏
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void isr_install_handler(uint8_t num, isr_handler_t handler);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void isr_uninstall_handler(uint8_t num);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void exception_handler(struct registers *regs);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void irq_handler(struct registers *regs);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #endif // ISR_H
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ memory
    ‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ heap.h
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ CONTENT:
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #ifndef HEAP_H
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define HEAP_H
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #include <stdint.h>
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #include <stddef.h>
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #include <stdbool.h>
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define HEAP_START         0xFFFFFFFF90000000
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define HEAP_INITIAL_SIZE  0x100000
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define HEAP_MAX_SIZE      0x10000000
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // Security constants
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define HEAP_CANARY_VALUE          0xDEADBEEFCAFEBABE
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define HEAP_MAX_ALLOC_SIZE        (HEAP_INITIAL_SIZE / 4)  // Max 25% of heap per allocation
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define HEAP_MIN_ALLOC_SIZE        8
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define HEAP_ALIGNMENT             8
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // Memory protection flags
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define HEAP_READ_ONLY     0x01
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define HEAP_NO_EXECUTE    0x02
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define HEAP_GUARD_PAGE    0x04
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // Memory poisoning
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define HEAP_ALLOC_POISON  0xAA
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define HEAP_FREE_POISON   0xDD
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // Security statistics structure
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   struct heap_security_stats {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       size_t total_allocations;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       size_t total_frees;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       size_t failed_allocations;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       size_t double_free_attempts;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       size_t buffer_overflow_detected;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       size_t use_after_free_detected;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       size_t corruption_count;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   };
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // Structure with security features
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   struct heap_block {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       uint64_t canary_start;     // Stack canary pattern
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       size_t size;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       size_t requested_size;     // Original requested size
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       bool used;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       uint8_t protection_flags;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       uint32_t checksum;         // CRC-like checksum
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       struct heap_block* next;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       struct heap_block* prev;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       void* allocation_ptr;      // Pointer to actual allocation
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       uint64_t canary_end;       // End canary
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   } __attribute__((packed));
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   struct heap {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       void* start;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       void* end;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       size_t total_size;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       size_t used_size;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       size_t alloc_count;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       size_t free_count;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       size_t corruption_count;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       struct heap_block* first_block;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       // Security statistics
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       struct heap_security_stats stats;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   };
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // Security functions
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void heap_init(void);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void* kmalloc(size_t size);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void* kmalloc_protected(size_t size, uint8_t protection_flags);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void* kcalloc(size_t num, size_t size);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void* krealloc(void* ptr, size_t size);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void kfree(void* ptr);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // Security validation functions
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   bool heap_validate_block(struct heap_block* block);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   bool heap_validate_all_blocks(void);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void heap_check_integrity(void);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   bool heap_is_valid_pointer(void* ptr);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // Memory protection
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   bool heap_protect_block(void* ptr, uint8_t protection_flags);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   bool heap_unprotect_block(void* ptr);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   bool heap_mark_as_executable(void* ptr);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   bool heap_mark_as_readonly(void* ptr);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // Debug and diagnostics
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   size_t heap_get_total_size(void);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   size_t heap_get_used_size(void);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   size_t heap_get_free_size(void);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void heap_dump_blocks(void);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void heap_print_stats(void);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void heap_enable_poisoning(bool enable);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void heap_enable_guard_pages(bool enable);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // Advanced security
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void* kmalloc_aligned(size_t size, size_t alignment);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   bool heap_detect_corruption(void);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void heap_emergency_lockdown(void);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #endif
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ paging.h
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ CONTENT:
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #ifndef PAGING_H
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define PAGING_H
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #include <stdint.h>
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #include <stddef.h>
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #include <stdbool.h>
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #include "../interrupts/isr.h"
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #include <limine.h>
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // Page table entry flags
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define PAGING_PRESENT         (1ULL << 0)
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define PAGING_WRITABLE        (1ULL << 1)
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define PAGING_USER            (1ULL << 2)
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define PAGING_WRITE_THROUGH   (1ULL << 3)
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define PAGING_CACHE_DISABLE   (1ULL << 4)
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define PAGING_ACCESSED        (1ULL << 5)
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define PAGING_DIRTY           (1ULL << 6)
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define PAGING_HUGE_PAGE       (1ULL << 7)
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define PAGING_GLOBAL          (1ULL << 8)
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define PAGING_NO_EXECUTE      (1ULL << 63)
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define PF_PRESENT      (1 << 0)    // Page present
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define PF_WRITE        (1 << 1)    // Write operation
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define PF_USER         (1 << 2)    // User mode access
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define PF_RESERVED     (1 << 3)    // Reserved bit set
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define PF_INSTRUCTION  (1 << 4)    // Instruction fetch
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // Page sizes
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define PAGE_SIZE_4K 0x1000
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define PAGE_SIZE_2M 0x200000
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define PAGE_SIZE_1G 0x40000000
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // Virtual memory layout
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define KERNEL_VIRTUAL_BASE 0xFFFFFFFF80000000
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define HHDM_OFFSET         0xFFFF800000000000
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // Page table structure
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   typedef uint64_t page_table_entry_t;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   struct page_table {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       page_table_entry_t entries[512];
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   } __attribute__((aligned(PAGE_SIZE_4K)));
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // Paging functions
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void paging_init(volatile struct limine_hhdm_response *hhdm_response);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void paging_load_cr3(uint64_t cr3_value);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   uint64_t paging_get_cr3(void);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void paging_invalidate_tlb(uint64_t virtual_addr);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   bool paging_map_page(uint64_t virtual_addr, uint64_t physical_addr, uint64_t flags);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   bool paging_unmap_page(uint64_t virtual_addr);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   bool paging_is_mapped(uint64_t virtual_addr);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // Memory conversion functions
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void* paging_physical_to_virtual(uint64_t physical_addr);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   uint64_t paging_virtual_to_physical(void* virtual_addr);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void* paging_hhdm_to_virtual(uint64_t physical_addr);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   uint64_t paging_get_physical_address(uint64_t virtual_addr);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void handle_page_fault(struct registers *regs);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void handle_double_fault(struct registers *regs);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void handle_general_protection_fault(struct registers *regs);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #endif // PAGING_H
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ pmm.h
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ CONTENT:
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #ifndef PMM_H
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define PMM_H
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #include <stdint.h>
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #include <stddef.h>
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #include <stdbool.h>
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #include <limine.h>
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // Physical memory manager
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void pmm_init(volatile struct limine_memmap_response *memmap_response,
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                 volatile struct limine_hhdm_response *hhdm_response);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   uint64_t pmm_alloc_page(void);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void pmm_free_page(uint64_t page);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   uint64_t pmm_get_total_memory(void);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   uint64_t pmm_get_free_memory(void);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   uint64_t pmm_get_used_memory(void);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void pmm_dump_memory_map(void);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #endif // PMM_H
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ security.h
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ CONTENT:
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #ifndef MEMORY_SECURITY_H
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #define MEMORY_SECURITY_H
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #include <stdint.h>
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #include <stddef.h>
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #include <stdbool.h>
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // Memory security subsystem
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void memory_security_init(void);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void memory_security_check(void);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   bool memory_validate_kernel_stack(void);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   bool memory_validate_heap_integrity(void);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void memory_dump_security_status(void);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // Stack protection
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void stack_protector_init(void);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   bool stack_protector_check(void);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   uint64_t generate_stack_canary(void);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // Address Space Layout Randomization
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void aslr_init(void);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   uint64_t aslr_randomize_address(uint64_t base, uint64_t size);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // Memory sanitization
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void secure_memset(void* ptr, int value, size_t size);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void secure_memzero(void* ptr, size_t size);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void memory_poison_range(void* start, void* end, uint8_t pattern);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #endif
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ simd
    ‚îÇ       ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ simd.h
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ CONTENT:
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   <empty>
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ sys
    ‚îÇ       ‚îÇ       ‚îî‚îÄ‚îÄ gdt.h
    ‚îÇ       ‚îÇ           ‚îÇ
    ‚îÇ       ‚îÇ           ‚îú‚îÄ‚îÄ CONTENT:
    ‚îÇ       ‚îÇ           ‚îÇ   #ifndef GDT_H
    ‚îÇ       ‚îÇ           ‚îÇ   #define GDT_H
    ‚îÇ       ‚îÇ           ‚îÇ   
    ‚îÇ       ‚îÇ           ‚îÇ   #include <stdint.h>
    ‚îÇ       ‚îÇ           ‚îÇ   
    ‚îÇ       ‚îÇ           ‚îÇ   // –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä–∞ GDT
    ‚îÇ       ‚îÇ           ‚îÇ   struct gdt_entry {
    ‚îÇ       ‚îÇ           ‚îÇ       uint16_t limit_low;
    ‚îÇ       ‚îÇ           ‚îÇ       uint16_t base_low;
    ‚îÇ       ‚îÇ           ‚îÇ       uint8_t base_middle;
    ‚îÇ       ‚îÇ           ‚îÇ       uint8_t access;
    ‚îÇ       ‚îÇ           ‚îÇ       uint8_t granularity;
    ‚îÇ       ‚îÇ           ‚îÇ       uint8_t base_high;
    ‚îÇ       ‚îÇ           ‚îÇ   } __attribute__((packed));
    ‚îÇ       ‚îÇ           ‚îÇ   
    ‚îÇ       ‚îÇ           ‚îÇ   // –°—Ç—Ä—É–∫—Ç—É—Ä–∞ —É–∫–∞–∑–∞—Ç–µ–ª—è GDT (–ò–°–ü–†–ê–í–õ–ï–ù–û - –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å 48-–±–∏—Ç–Ω—ã–º)
    ‚îÇ       ‚îÇ           ‚îÇ   struct gdt_ptr {
    ‚îÇ       ‚îÇ           ‚îÇ       uint16_t limit;
    ‚îÇ       ‚îÇ           ‚îÇ       uint64_t base;
    ‚îÇ       ‚îÇ           ‚îÇ   } __attribute__((packed));
    ‚îÇ       ‚îÇ           ‚îÇ   
    ‚îÇ       ‚îÇ           ‚îÇ   // –°–µ–≥–º–µ–Ω—Ç–Ω—ã–µ —Å–µ–ª–µ–∫—Ç–æ—Ä—ã (–ò–°–ü–†–ê–í–õ–ï–ù–û - —É—á–∏—Ç—ã–≤–∞–µ–º —Å–º–µ—â–µ–Ω–∏–µ)
    ‚îÇ       ‚îÇ           ‚îÇ   #define GDT_KERNEL_CS 0x08  // 1-–π –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä (–ø–æ—Å–ª–µ null)
    ‚îÇ       ‚îÇ           ‚îÇ   #define GDT_KERNEL_DS 0x10  // 2-–π –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä
    ‚îÇ       ‚îÇ           ‚îÇ   
    ‚îÇ       ‚îÇ           ‚îÇ   // –§–ª–∞–≥–∏ –¥–æ—Å—Ç—É–ø–∞
    ‚îÇ       ‚îÇ           ‚îÇ   #define GDT_ACCESS_PRESENT     (1 << 7)
    ‚îÇ       ‚îÇ           ‚îÇ   #define GDT_ACCESS_RING0       (0 << 5)
    ‚îÇ       ‚îÇ           ‚îÇ   #define GDT_ACCESS_SEGMENT     (1 << 4)
    ‚îÇ       ‚îÇ           ‚îÇ   #define GDT_ACCESS_EXECUTABLE  (1 << 3)
    ‚îÇ       ‚îÇ           ‚îÇ   #define GDT_ACCESS_READ_WRITE  (1 << 1)
    ‚îÇ       ‚îÇ           ‚îÇ   
    ‚îÇ       ‚îÇ           ‚îÇ   // –§–ª–∞–≥–∏ –≥—Ä–∞–Ω—É–ª—è—Ä–Ω–æ—Å—Ç–∏
    ‚îÇ       ‚îÇ           ‚îÇ   #define GDT_GRANULARITY_4K     (1 << 7)
    ‚îÇ       ‚îÇ           ‚îÇ   #define GDT_GRANULARITY_LONG   (1 << 5)  // 64-bit mode
    ‚îÇ       ‚îÇ           ‚îÇ   
    ‚îÇ       ‚îÇ           ‚îÇ   // –§—É–Ω–∫—Ü–∏–∏
    ‚îÇ       ‚îÇ           ‚îÇ   void gdt_init(void);
    ‚îÇ       ‚îÇ           ‚îÇ   void gdt_load(void);
    ‚îÇ       ‚îÇ           ‚îÇ   
    ‚îÇ       ‚îÇ           ‚îÇ   // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä–∞ GDT (–¥–ª—è –æ—Ç–ª–∞–¥–∫–∏)
    ‚îÇ       ‚îÇ           ‚îÇ   const struct gdt_entry* gdt_get_descriptor(int index);
    ‚îÇ       ‚îÇ           ‚îÇ   
    ‚îÇ       ‚îÇ           ‚îÇ   
    ‚îÇ       ‚îÇ           ‚îÇ   
    ‚îÇ       ‚îÇ           ‚îÇ   #endif // GDT_H
    ‚îÇ       ‚îÇ           ‚îÇ
    ‚îÇ       ‚îú‚îÄ‚îÄ interrupts
    ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ idt.c
    ‚îÇ       ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ       ‚îú‚îÄ‚îÄ CONTENT:
    ‚îÇ       ‚îÇ       ‚îÇ   #include "include/interrupts/idt.h"
    ‚îÇ       ‚îÇ       ‚îÇ   #include "include/interrupts/isr.h"
    ‚îÇ       ‚îÇ       ‚îÇ   #include "include/drivers/serial.h"
    ‚îÇ       ‚îÇ       ‚îÇ   #include "libc/string.h" 
    ‚îÇ       ‚îÇ       ‚îÇ   #include "include/memory/paging.h"
    ‚îÇ       ‚îÇ       ‚îÇ   #include <stddef.h>
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   // IDT —Ç–∞–±–ª–∏—Ü–∞ (256 –∑–∞–ø–∏—Å–µ–π)
    ‚îÇ       ‚îÇ       ‚îÇ   static struct idt_entry idt[256];
    ‚îÇ       ‚îÇ       ‚îÇ   static struct idt_ptr idtp;
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   // –í–Ω–µ—à–Ω–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏ –∏–∑ –∞—Å—Å–µ–º–±–ª–µ—Ä–∞
    ‚îÇ       ‚îÇ       ‚îÇ   extern void idt_flush(uint64_t idt_ptr);
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   // –û–±—ä—è–≤–ª–µ–Ω–∏—è –∞—Å—Å–µ–º–±–ª–µ—Ä–Ω—ã—Ö –∑–∞–≥–ª—É—à–µ–∫ –¥–ª—è –≤—Å–µ—Ö –∏—Å–∫–ª—é—á–µ–Ω–∏–π
    ‚îÇ       ‚îÇ       ‚îÇ   extern void isr_stub_0(void);
    ‚îÇ       ‚îÇ       ‚îÇ   extern void isr_stub_1(void);
    ‚îÇ       ‚îÇ       ‚îÇ   extern void isr_stub_2(void);
    ‚îÇ       ‚îÇ       ‚îÇ   extern void isr_stub_3(void);
    ‚îÇ       ‚îÇ       ‚îÇ   extern void isr_stub_4(void);
    ‚îÇ       ‚îÇ       ‚îÇ   extern void isr_stub_5(void);
    ‚îÇ       ‚îÇ       ‚îÇ   extern void isr_stub_6(void);
    ‚îÇ       ‚îÇ       ‚îÇ   extern void isr_stub_7(void);
    ‚îÇ       ‚îÇ       ‚îÇ   extern void isr_stub_8(void);
    ‚îÇ       ‚îÇ       ‚îÇ   extern void isr_stub_9(void);
    ‚îÇ       ‚îÇ       ‚îÇ   extern void isr_stub_10(void);
    ‚îÇ       ‚îÇ       ‚îÇ   extern void isr_stub_11(void);
    ‚îÇ       ‚îÇ       ‚îÇ   extern void isr_stub_12(void);
    ‚îÇ       ‚îÇ       ‚îÇ   extern void isr_stub_13(void);
    ‚îÇ       ‚îÇ       ‚îÇ   extern void isr_stub_14(void);
    ‚îÇ       ‚îÇ       ‚îÇ   extern void isr_stub_15(void);
    ‚îÇ       ‚îÇ       ‚îÇ   extern void isr_stub_16(void);
    ‚îÇ       ‚îÇ       ‚îÇ   extern void isr_stub_17(void);
    ‚îÇ       ‚îÇ       ‚îÇ   extern void isr_stub_18(void);
    ‚îÇ       ‚îÇ       ‚îÇ   extern void isr_stub_19(void);
    ‚îÇ       ‚îÇ       ‚îÇ   extern void isr_stub_20(void);
    ‚îÇ       ‚îÇ       ‚îÇ   extern void isr_stub_21(void);
    ‚îÇ       ‚îÇ       ‚îÇ   extern void isr_stub_22(void);
    ‚îÇ       ‚îÇ       ‚îÇ   extern void isr_stub_23(void);
    ‚îÇ       ‚îÇ       ‚îÇ   extern void isr_stub_24(void);
    ‚îÇ       ‚îÇ       ‚îÇ   extern void isr_stub_25(void);
    ‚îÇ       ‚îÇ       ‚îÇ   extern void isr_stub_26(void);
    ‚îÇ       ‚îÇ       ‚îÇ   extern void isr_stub_27(void);
    ‚îÇ       ‚îÇ       ‚îÇ   extern void isr_stub_28(void);
    ‚îÇ       ‚îÇ       ‚îÇ   extern void isr_stub_29(void);
    ‚îÇ       ‚îÇ       ‚îÇ   extern void isr_stub_30(void);
    ‚îÇ       ‚îÇ       ‚îÇ   extern void isr_stub_31(void);
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   extern void isr_stub_32(void);
    ‚îÇ       ‚îÇ       ‚îÇ   extern void isr_stub_33(void);
    ‚îÇ       ‚îÇ       ‚îÇ   extern void isr_stub_34(void);
    ‚îÇ       ‚îÇ       ‚îÇ   extern void isr_stub_35(void);
    ‚îÇ       ‚îÇ       ‚îÇ   extern void isr_stub_36(void);
    ‚îÇ       ‚îÇ       ‚îÇ   extern void isr_stub_37(void);
    ‚îÇ       ‚îÇ       ‚îÇ   extern void isr_stub_38(void);
    ‚îÇ       ‚îÇ       ‚îÇ   extern void isr_stub_39(void);
    ‚îÇ       ‚îÇ       ‚îÇ   extern void isr_stub_40(void);
    ‚îÇ       ‚îÇ       ‚îÇ   extern void isr_stub_41(void);
    ‚îÇ       ‚îÇ       ‚îÇ   extern void isr_stub_42(void);
    ‚îÇ       ‚îÇ       ‚îÇ   extern void isr_stub_43(void);
    ‚îÇ       ‚îÇ       ‚îÇ   extern void isr_stub_44(void);
    ‚îÇ       ‚îÇ       ‚îÇ   extern void isr_stub_45(void);
    ‚îÇ       ‚îÇ       ‚îÇ   extern void isr_stub_46(void);
    ‚îÇ       ‚îÇ       ‚îÇ   extern void isr_stub_47(void);
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   // –¢–∞–±–ª–∏—Ü–∞ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏–π
    ‚îÇ       ‚îÇ       ‚îÇ   static isr_handler_t isr_handlers[256] = {0};
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   // –î–µ–∫–ª–∞—Ä–∞—Ü–∏—è –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∞ –∏–∑ isr.c
    ‚îÇ       ‚îÇ       ‚îÇ   extern void isr_handler(struct registers *regs);
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   void idt_set_entry(uint8_t index, uint64_t base, uint16_t selector, uint8_t type_attr) {
    ‚îÇ       ‚îÇ       ‚îÇ       idt[index].base_low = base & 0xFFFF;
    ‚îÇ       ‚îÇ       ‚îÇ       idt[index].base_middle = (base >> 16) & 0xFFFF;
    ‚îÇ       ‚îÇ       ‚îÇ       idt[index].base_high = (base >> 32) & 0xFFFFFFFF;
    ‚îÇ       ‚îÇ       ‚îÇ       idt[index].selector = selector;
    ‚îÇ       ‚îÇ       ‚îÇ       idt[index].ist = 0;
    ‚îÇ       ‚îÇ       ‚îÇ       idt[index].type_attr = type_attr;
    ‚îÇ       ‚îÇ       ‚îÇ       idt[index].zero = 0;
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   void idt_init(void) {
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts("[IDT] Initializing IDT...\n");
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // –û–±–Ω—É–ª—è–µ–º IDT
    ‚îÇ       ‚îÇ       ‚îÇ       for (int i = 0; i < 256; i++) {
    ‚îÇ       ‚îÇ       ‚îÇ           idt_set_entry(i, 0, 0, 0);
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∏—Å–∫–ª—é—á–µ–Ω–∏–π (0-31)
    ‚îÇ       ‚îÇ       ‚îÇ       idt_set_entry(EXCEPTION_DIVISION_ERROR, (uint64_t)isr_stub_0, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    ‚îÇ       ‚îÇ       ‚îÇ       idt_set_entry(EXCEPTION_DEBUG, (uint64_t)isr_stub_1, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    ‚îÇ       ‚îÇ       ‚îÇ       idt_set_entry(EXCEPTION_NMI, (uint64_t)isr_stub_2, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    ‚îÇ       ‚îÇ       ‚îÇ       idt_set_entry(EXCEPTION_BREAKPOINT, (uint64_t)isr_stub_3, 0x08, IDT_PRESENT | IDT_RING3 | IDT_TYPE_INT);
    ‚îÇ       ‚îÇ       ‚îÇ       idt_set_entry(EXCEPTION_OVERFLOW, (uint64_t)isr_stub_4, 0x08, IDT_PRESENT | IDT_RING3 | IDT_TYPE_INT);
    ‚îÇ       ‚îÇ       ‚îÇ       idt_set_entry(EXCEPTION_BOUND_RANGE, (uint64_t)isr_stub_5, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    ‚îÇ       ‚îÇ       ‚îÇ       idt_set_entry(EXCEPTION_INVALID_OPCODE, (uint64_t)isr_stub_6, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    ‚îÇ       ‚îÇ       ‚îÇ       idt_set_entry(EXCEPTION_DEVICE_NOT_AVAILABLE, (uint64_t)isr_stub_7, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    ‚îÇ       ‚îÇ       ‚îÇ       idt_set_entry(EXCEPTION_DOUBLE_FAULT, (uint64_t)isr_stub_8, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    ‚îÇ       ‚îÇ       ‚îÇ       idt_set_entry(EXCEPTION_COPROCESSOR_SEGMENT, (uint64_t)isr_stub_9, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    ‚îÇ       ‚îÇ       ‚îÇ       idt_set_entry(EXCEPTION_INVALID_TSS, (uint64_t)isr_stub_10, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    ‚îÇ       ‚îÇ       ‚îÇ       idt_set_entry(EXCEPTION_SEGMENT_NOT_PRESENT, (uint64_t)isr_stub_11, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    ‚îÇ       ‚îÇ       ‚îÇ       idt_set_entry(EXCEPTION_STACK_SEGMENT_FAULT, (uint64_t)isr_stub_12, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    ‚îÇ       ‚îÇ       ‚îÇ       idt_set_entry(EXCEPTION_GPF, (uint64_t)isr_stub_13, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    ‚îÇ       ‚îÇ       ‚îÇ       idt_set_entry(EXCEPTION_PAGE_FAULT, (uint64_t)isr_stub_14, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    ‚îÇ       ‚îÇ       ‚îÇ       idt_set_entry(EXCEPTION_RESERVED, (uint64_t)isr_stub_15, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    ‚îÇ       ‚îÇ       ‚îÇ       idt_set_entry(EXCEPTION_X87_FPU, (uint64_t)isr_stub_16, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    ‚îÇ       ‚îÇ       ‚îÇ       idt_set_entry(EXCEPTION_ALIGNMENT_CHECK, (uint64_t)isr_stub_17, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    ‚îÇ       ‚îÇ       ‚îÇ       idt_set_entry(EXCEPTION_MACHINE_CHECK, (uint64_t)isr_stub_18, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    ‚îÇ       ‚îÇ       ‚îÇ       idt_set_entry(EXCEPTION_SIMD_FPU, (uint64_t)isr_stub_19, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    ‚îÇ       ‚îÇ       ‚îÇ       idt_set_entry(EXCEPTION_VIRTUALIZATION, (uint64_t)isr_stub_20, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    ‚îÇ       ‚îÇ       ‚îÇ       idt_set_entry(21, (uint64_t)isr_stub_21, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    ‚îÇ       ‚îÇ       ‚îÇ       idt_set_entry(22, (uint64_t)isr_stub_22, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    ‚îÇ       ‚îÇ       ‚îÇ       idt_set_entry(23, (uint64_t)isr_stub_23, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    ‚îÇ       ‚îÇ       ‚îÇ       idt_set_entry(24, (uint64_t)isr_stub_24, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    ‚îÇ       ‚îÇ       ‚îÇ       idt_set_entry(25, (uint64_t)isr_stub_25, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    ‚îÇ       ‚îÇ       ‚îÇ       idt_set_entry(26, (uint64_t)isr_stub_26, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    ‚îÇ       ‚îÇ       ‚îÇ       idt_set_entry(27, (uint64_t)isr_stub_27, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    ‚îÇ       ‚îÇ       ‚îÇ       idt_set_entry(28, (uint64_t)isr_stub_28, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    ‚îÇ       ‚îÇ       ‚îÇ       idt_set_entry(29, (uint64_t)isr_stub_29, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    ‚îÇ       ‚îÇ       ‚îÇ       idt_set_entry(EXCEPTION_SECURITY, (uint64_t)isr_stub_30, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    ‚îÇ       ‚îÇ       ‚îÇ       idt_set_entry(31, (uint64_t)isr_stub_31, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       idt_set_entry(32, (uint64_t)isr_stub_32, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    ‚îÇ       ‚îÇ       ‚îÇ       idt_set_entry(33, (uint64_t)isr_stub_33, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    ‚îÇ       ‚îÇ       ‚îÇ       idt_set_entry(34, (uint64_t)isr_stub_34, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    ‚îÇ       ‚îÇ       ‚îÇ       idt_set_entry(35, (uint64_t)isr_stub_35, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    ‚îÇ       ‚îÇ       ‚îÇ       idt_set_entry(36, (uint64_t)isr_stub_36, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    ‚îÇ       ‚îÇ       ‚îÇ       idt_set_entry(37, (uint64_t)isr_stub_37, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    ‚îÇ       ‚îÇ       ‚îÇ       idt_set_entry(38, (uint64_t)isr_stub_38, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    ‚îÇ       ‚îÇ       ‚îÇ       idt_set_entry(39, (uint64_t)isr_stub_39, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    ‚îÇ       ‚îÇ       ‚îÇ       idt_set_entry(40, (uint64_t)isr_stub_40, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    ‚îÇ       ‚îÇ       ‚îÇ       idt_set_entry(41, (uint64_t)isr_stub_41, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    ‚îÇ       ‚îÇ       ‚îÇ       idt_set_entry(42, (uint64_t)isr_stub_42, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    ‚îÇ       ‚îÇ       ‚îÇ       idt_set_entry(43, (uint64_t)isr_stub_43, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    ‚îÇ       ‚îÇ       ‚îÇ       idt_set_entry(44, (uint64_t)isr_stub_44, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    ‚îÇ       ‚îÇ       ‚îÇ       idt_set_entry(45, (uint64_t)isr_stub_45, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    ‚îÇ       ‚îÇ       ‚îÇ       idt_set_entry(46, (uint64_t)isr_stub_46, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    ‚îÇ       ‚îÇ       ‚îÇ       idt_set_entry(47, (uint64_t)isr_stub_47, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    ‚îÇ       ‚îÇ       ‚îÇ       // –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º —É–∫–∞–∑–∞—Ç–µ–ª—å IDT
    ‚îÇ       ‚îÇ       ‚îÇ       idtp.limit = sizeof(idt) - 1;
    ‚îÇ       ‚îÇ       ‚îÇ       idtp.base = (uint64_t)&idt;
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∏—Å–∫–ª—é—á–µ–Ω–∏–π
    ‚îÇ       ‚îÇ       ‚îÇ       for (int i = 0; i < 32; i++) {
    ‚îÇ       ‚îÇ       ‚îÇ           isr_install_handler(i, exception_handler);
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ       isr_install_handler(EXCEPTION_DOUBLE_FAULT, handle_double_fault);
    ‚îÇ       ‚îÇ       ‚îÇ       isr_install_handler(EXCEPTION_GPF, handle_general_protection_fault);
    ‚îÇ       ‚îÇ       ‚îÇ       isr_install_handler(EXCEPTION_PAGE_FAULT, handle_page_fault);
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts("[IDT] IDT entries set up (0-31: exceptions)\n");
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   void idt_load(void) {
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts("[IDT] Loading IDT...\n");
    ‚îÇ       ‚îÇ       ‚îÇ       idt_flush((uint64_t)&idtp);
    ‚îÇ       ‚îÇ       ‚îÇ       asm volatile("sti");  // –†–∞–∑—Ä–µ—à–∞–µ–º –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts("[IDT] Interrupts enabled\n");
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   void isr_install_handler(uint8_t num, isr_handler_t handler) {
    ‚îÇ       ‚îÇ       ‚îÇ       isr_handlers[num] = handler;
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       char buffer[16];
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts("[IDT] Installed handler for interrupt ");
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts(itoa(num, buffer, 10));
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts("\n");
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   void isr_uninstall_handler(uint8_t num) {
    ‚îÇ       ‚îÇ       ‚îÇ       isr_handlers[num] = NULL;
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   // –§—É–Ω–∫—Ü–∏—è-–æ–±—Ä–∞–±–æ—Ç—á–∏–∫, –≤—ã–∑—ã–≤–∞–µ–º–∞—è –∏–∑ –∞—Å—Å–µ–º–±–ª–µ—Ä–∞
    ‚îÇ       ‚îÇ       ‚îÇ   void isr_handler(struct registers *regs) {
    ‚îÇ       ‚îÇ       ‚îÇ       if (isr_handlers[regs->int_no] != NULL) {
    ‚îÇ       ‚îÇ       ‚îÇ           isr_handlers[regs->int_no](regs);
    ‚îÇ       ‚îÇ       ‚îÇ       } else {
    ‚îÇ       ‚îÇ       ‚îÇ           if (regs->int_no >= 32 && regs->int_no < 48) {
    ‚îÇ       ‚îÇ       ‚îÇ               // –≠—Ç–æ IRQ - –ø–µ—Ä–µ–¥–∞–µ–º –≤ irq_handler
    ‚îÇ       ‚îÇ       ‚îÇ               irq_handler(regs);
    ‚îÇ       ‚îÇ       ‚îÇ           } else {
    ‚îÇ       ‚îÇ       ‚îÇ               // –ù–µ–æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω–æ–µ –∏—Å–∫–ª—é—á–µ–Ω–∏–µ
    ‚îÇ       ‚îÇ       ‚îÇ               char buffer[64];
    ‚îÇ       ‚îÇ       ‚îÇ               serial_puts("[ISR] No handler for interrupt ");
    ‚îÇ       ‚îÇ       ‚îÇ               serial_puts(itoa(regs->int_no, buffer, 10));
    ‚îÇ       ‚îÇ       ‚îÇ               serial_puts("\n");
    ‚îÇ       ‚îÇ       ‚îÇ               
    ‚îÇ       ‚îÇ       ‚îÇ               if (regs->int_no < 32) {
    ‚îÇ       ‚îÇ       ‚îÇ                   serial_puts("[ISR] Unhandled exception! System halted.\n");
    ‚îÇ       ‚îÇ       ‚îÇ                   for(;;) {
    ‚îÇ       ‚îÇ       ‚îÇ                       asm volatile("hlt");
    ‚îÇ       ‚îÇ       ‚îÇ                   }
    ‚îÇ       ‚îÇ       ‚îÇ               }
    ‚îÇ       ‚îÇ       ‚îÇ           }
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ irq.c
    ‚îÇ       ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ       ‚îú‚îÄ‚îÄ CONTENT:
    ‚îÇ       ‚îÇ       ‚îÇ   #include "include/interrupts/irq.h"
    ‚îÇ       ‚îÇ       ‚îÇ   #include "include/drivers/pic.h"
    ‚îÇ       ‚îÇ       ‚îÇ   #include "include/interrupts/idt.h"
    ‚îÇ       ‚îÇ       ‚îÇ   #include "include/drivers/serial.h"
    ‚îÇ       ‚îÇ       ‚îÇ   #include "libc/string.h"
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   static isr_handler_t irq_handlers[16] = {0};
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –¥–ª—è IRQ (–æ–±—ä—è–≤–ª—è–µ–º –ü–ï–†–í–´–ú)
    ‚îÇ       ‚îÇ       ‚îÇ   void irq_default_handler(struct registers *regs) {
    ‚îÇ       ‚îÇ       ‚îÇ       char buffer[64];
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts("[IRQ] Default handler for IRQ");
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts(itoa(regs->int_no - 32, buffer, 10));
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts("\n");
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   // –ì–ª–∞–≤–Ω—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ IRQ
    ‚îÇ       ‚îÇ       ‚îÇ   void irq_handler(struct registers *regs) {
    ‚îÇ       ‚îÇ       ‚îÇ       uint8_t irq_num = regs->int_no - 32;
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // –í—ã–∑—ã–≤–∞–µ–º –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫
    ‚îÇ       ‚îÇ       ‚îÇ       if (irq_handlers[irq_num] != NULL) {
    ‚îÇ       ‚îÇ       ‚îÇ           irq_handlers[irq_num](regs);
    ‚îÇ       ‚îÇ       ‚îÇ       } else {
    ‚îÇ       ‚îÇ       ‚îÇ           irq_default_handler(regs);
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º EOI –≤ PIC
    ‚îÇ       ‚îÇ       ‚îÇ       pic_send_eoi(irq_num);
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   void irq_init(void) {
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts("[IRQ] Initializing IRQ handlers...\n");
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
    ‚îÇ       ‚îÇ       ‚îÇ       for (int i = 0; i < 16; i++) {
    ‚îÇ       ‚îÇ       ‚îÇ           irq_install_handler(i, irq_default_handler);
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts("[IRQ] IRQ handlers initialized\n");
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   void irq_install_handler(uint8_t irq, isr_handler_t handler) {
    ‚îÇ       ‚îÇ       ‚îÇ       if (irq < 16) {
    ‚îÇ       ‚îÇ       ‚îÇ           irq_handlers[irq] = handler;
    ‚îÇ       ‚îÇ       ‚îÇ           
    ‚îÇ       ‚îÇ       ‚îÇ           char buffer[16];
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts("[IRQ] Installed handler for IRQ");
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts(itoa(irq, buffer, 10));
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts("\n");
    ‚îÇ       ‚îÇ       ‚îÇ           
    ‚îÇ       ‚îÇ       ‚îÇ           // –†–∞–∑–º–∞—Å–∫–∏—Ä—É–µ–º IRQ
    ‚îÇ       ‚îÇ       ‚îÇ           pic_unmask_irq(irq);
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   void irq_uninstall_handler(uint8_t irq) {
    ‚îÇ       ‚îÇ       ‚îÇ       if (irq < 16) {
    ‚îÇ       ‚îÇ       ‚îÇ           irq_handlers[irq] = NULL;
    ‚îÇ       ‚îÇ       ‚îÇ           // –ú–∞—Å–∫–∏—Ä—É–µ–º IRQ
    ‚îÇ       ‚îÇ       ‚îÇ           pic_mask_irq(irq);
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ isr.c
    ‚îÇ       ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ       ‚îú‚îÄ‚îÄ CONTENT:
    ‚îÇ       ‚îÇ       ‚îÇ   #include "include/interrupts/isr.h"
    ‚îÇ       ‚îÇ       ‚îÇ   #include "include/interrupts/idt.h"  // <-- –î–û–ë–ê–í–¨ –≠–¢–£ –°–¢–†–û–ö–£
    ‚îÇ       ‚îÇ       ‚îÇ   #include "include/drivers/serial.h"
    ‚îÇ       ‚îÇ       ‚îÇ   #include "libc/string.h"
    ‚îÇ       ‚îÇ       ‚îÇ   #include "libc/stdio.h"
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   // –°–æ–æ–±—â–µ–Ω–∏—è –æ–± –∏—Å–∫–ª—é—á–µ–Ω–∏—è—Ö
    ‚îÇ       ‚îÇ       ‚îÇ   static const char *exception_messages[32] = {
    ‚îÇ       ‚îÇ       ‚îÇ       "Division By Zero",
    ‚îÇ       ‚îÇ       ‚îÇ       "Debug",
    ‚îÇ       ‚îÇ       ‚îÇ       "Non Maskable Interrupt",
    ‚îÇ       ‚îÇ       ‚îÇ       "Breakpoint",
    ‚îÇ       ‚îÇ       ‚îÇ       "Into Detected Overflow",
    ‚îÇ       ‚îÇ       ‚îÇ       "Out of Bounds",
    ‚îÇ       ‚îÇ       ‚îÇ       "Invalid Opcode",
    ‚îÇ       ‚îÇ       ‚îÇ       "No Coprocessor",
    ‚îÇ       ‚îÇ       ‚îÇ       "Double Fault",
    ‚îÇ       ‚îÇ       ‚îÇ       "Coprocessor Segment Overrun",
    ‚îÇ       ‚îÇ       ‚îÇ       "Bad TSS",
    ‚îÇ       ‚îÇ       ‚îÇ       "Segment Not Present",
    ‚îÇ       ‚îÇ       ‚îÇ       "Stack Fault",
    ‚îÇ       ‚îÇ       ‚îÇ       "General Protection Fault",
    ‚îÇ       ‚îÇ       ‚îÇ       "Page Fault",
    ‚îÇ       ‚îÇ       ‚îÇ       "Unknown Interrupt",
    ‚îÇ       ‚îÇ       ‚îÇ       "Coprocessor Fault",
    ‚îÇ       ‚îÇ       ‚îÇ       "Alignment Check",
    ‚îÇ       ‚îÇ       ‚îÇ       "Machine Check",
    ‚îÇ       ‚îÇ       ‚îÇ       "Reserved",
    ‚îÇ       ‚îÇ       ‚îÇ       "Reserved",
    ‚îÇ       ‚îÇ       ‚îÇ       "Reserved",
    ‚îÇ       ‚îÇ       ‚îÇ       "Reserved",
    ‚îÇ       ‚îÇ       ‚îÇ       "Reserved",
    ‚îÇ       ‚îÇ       ‚îÇ       "Reserved",
    ‚îÇ       ‚îÇ       ‚îÇ       "Reserved",
    ‚îÇ       ‚îÇ       ‚îÇ       "Reserved",
    ‚îÇ       ‚îÇ       ‚îÇ       "Reserved",
    ‚îÇ       ‚îÇ       ‚îÇ       "Reserved",
    ‚îÇ       ‚îÇ       ‚îÇ       "Reserved",
    ‚îÇ       ‚îÇ       ‚îÇ       "Reserved",
    ‚îÇ       ‚îÇ       ‚îÇ       "Reserved"
    ‚îÇ       ‚îÇ       ‚îÇ   };
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   void exception_handler(struct registers *regs) {
    ‚îÇ       ‚îÇ       ‚îÇ       // –î–ª—è –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö –∏—Å–∫–ª—é—á–µ–Ω–∏–π –∏—Å–ø–æ–ª—å–∑—É–µ–º —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏
    ‚îÇ       ‚îÇ       ‚îÇ       // –î–ª—è –æ—Å—Ç–∞–ª—å–Ω—ã—Ö - –æ–±—â–∏–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       if (regs->int_no < 32) {
    ‚îÇ       ‚îÇ       ‚îÇ           printf("\n=== EXCEPTION %d ===\n", regs->int_no);
    ‚îÇ       ‚îÇ       ‚îÇ           printf("%s\n", exception_messages[regs->int_no]);
    ‚îÇ       ‚îÇ       ‚îÇ           printf("Error Code: 0x%x\n", regs->err_code);
    ‚îÇ       ‚îÇ       ‚îÇ           printf("RIP: 0x%x\n", regs->rip);
    ‚îÇ       ‚îÇ       ‚îÇ           
    ‚îÇ       ‚îÇ       ‚îÇ           // –î–ª—è Page Fault –≤—ã–≤–æ–¥–∏–º –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é
    ‚îÇ       ‚îÇ       ‚îÇ           if (regs->int_no == EXCEPTION_PAGE_FAULT) {
    ‚îÇ       ‚îÇ       ‚îÇ               uint64_t cr2;
    ‚îÇ       ‚îÇ       ‚îÇ               asm volatile("mov %%cr2, %0" : "=r"(cr2));
    ‚îÇ       ‚îÇ       ‚îÇ               printf("Fault Address: 0x%x\n", cr2);
    ‚îÇ       ‚îÇ       ‚îÇ           }
    ‚îÇ       ‚îÇ       ‚îÇ           
    ‚îÇ       ‚îÇ       ‚îÇ           // –î–ª—è –Ω–µ–∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö –∏—Å–∫–ª—é—á–µ–Ω–∏–π –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º —Ä–∞–±–æ—Ç—É
    ‚îÇ       ‚îÇ       ‚îÇ           if (regs->int_no == EXCEPTION_BREAKPOINT || regs->int_no == EXCEPTION_OVERFLOW) {
    ‚îÇ       ‚îÇ       ‚îÇ               printf("Non-critical exception, continuing...\n");
    ‚îÇ       ‚îÇ       ‚îÇ               return;
    ‚îÇ       ‚îÇ       ‚îÇ           }
    ‚îÇ       ‚îÇ       ‚îÇ           
    ‚îÇ       ‚îÇ       ‚îÇ           printf("System Halted.\n");
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // –ó–∞–≤–∏—Å–∞–µ–º –ø—Ä–∏ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–æ–º –∏—Å–∫–ª—é—á–µ–Ω–∏–∏
    ‚îÇ       ‚îÇ       ‚îÇ       for(;;) {
    ‚îÇ       ‚îÇ       ‚îÇ           asm volatile("hlt");
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ isr_asm.S
    ‚îÇ       ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ       ‚îú‚îÄ‚îÄ CONTENT:
    ‚îÇ       ‚îÇ       ‚îÇ   .section .text
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   // –ú–∞–∫—Ä–æ—Å –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –∑–∞–≥–ª—É—à–∫–∏ –±–µ–∑ –∫–æ–¥–∞ –æ—à–∏–±–∫–∏
    ‚îÇ       ‚îÇ       ‚îÇ   .macro ISR_NOERRCODE index
    ‚îÇ       ‚îÇ       ‚îÇ       .global isr_stub_\index
    ‚îÇ       ‚îÇ       ‚îÇ       .type isr_stub_\index, @function
    ‚îÇ       ‚îÇ       ‚îÇ   isr_stub_\index:
    ‚îÇ       ‚îÇ       ‚îÇ       push $0                    // –ü—É—Å—Ç–æ–π –∫–æ–¥ –æ—à–∏–±–∫–∏
    ‚îÇ       ‚îÇ       ‚îÇ       push $\index               // –ù–æ–º–µ—Ä –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è
    ‚îÇ       ‚îÇ       ‚îÇ       jmp isr_common_stub
    ‚îÇ       ‚îÇ       ‚îÇ   .endm
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   // –ú–∞–∫—Ä–æ—Å –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –∑–∞–≥–ª—É—à–∫–∏ —Å –∫–æ–¥–æ–º –æ—à–∏–±–∫–∏
    ‚îÇ       ‚îÇ       ‚îÇ   .macro ISR_ERRCODE index
    ‚îÇ       ‚îÇ       ‚îÇ       .global isr_stub_\index
    ‚îÇ       ‚îÇ       ‚îÇ       .type isr_stub_\index, @function
    ‚îÇ       ‚îÇ       ‚îÇ   isr_stub_\index:
    ‚îÇ       ‚îÇ       ‚îÇ       push $\index               // –ù–æ–º–µ—Ä –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è (–∫–æ–¥ –æ—à–∏–±–∫–∏ —É–∂–µ –≤ —Å—Ç–µ–∫–µ)
    ‚îÇ       ‚îÇ       ‚îÇ       jmp isr_common_stub
    ‚îÇ       ‚îÇ       ‚îÇ   .endm
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   // –°–æ–∑–¥–∞–µ–º –∑–∞–≥–ª—É—à–∫–∏ –¥–ª—è –∏—Å–∫–ª—é—á–µ–Ω–∏–π
    ‚îÇ       ‚îÇ       ‚îÇ   ISR_NOERRCODE 0
    ‚îÇ       ‚îÇ       ‚îÇ   ISR_NOERRCODE 1
    ‚îÇ       ‚îÇ       ‚îÇ   ISR_NOERRCODE 2
    ‚îÇ       ‚îÇ       ‚îÇ   ISR_NOERRCODE 3
    ‚îÇ       ‚îÇ       ‚îÇ   ISR_NOERRCODE 4
    ‚îÇ       ‚îÇ       ‚îÇ   ISR_NOERRCODE 5
    ‚îÇ       ‚îÇ       ‚îÇ   ISR_NOERRCODE 6
    ‚îÇ       ‚îÇ       ‚îÇ   ISR_NOERRCODE 7
    ‚îÇ       ‚îÇ       ‚îÇ   ISR_ERRCODE   8
    ‚îÇ       ‚îÇ       ‚îÇ   ISR_NOERRCODE 9
    ‚îÇ       ‚îÇ       ‚îÇ   ISR_ERRCODE   10
    ‚îÇ       ‚îÇ       ‚îÇ   ISR_ERRCODE   11
    ‚îÇ       ‚îÇ       ‚îÇ   ISR_ERRCODE   12
    ‚îÇ       ‚îÇ       ‚îÇ   ISR_ERRCODE   13
    ‚îÇ       ‚îÇ       ‚îÇ   ISR_ERRCODE   14
    ‚îÇ       ‚îÇ       ‚îÇ   ISR_NOERRCODE 15
    ‚îÇ       ‚îÇ       ‚îÇ   ISR_NOERRCODE 16
    ‚îÇ       ‚îÇ       ‚îÇ   ISR_NOERRCODE 17
    ‚îÇ       ‚îÇ       ‚îÇ   ISR_NOERRCODE 18
    ‚îÇ       ‚îÇ       ‚îÇ   ISR_NOERRCODE 19
    ‚îÇ       ‚îÇ       ‚îÇ   ISR_NOERRCODE 20
    ‚îÇ       ‚îÇ       ‚îÇ   ISR_NOERRCODE 21
    ‚îÇ       ‚îÇ       ‚îÇ   ISR_NOERRCODE 22
    ‚îÇ       ‚îÇ       ‚îÇ   ISR_NOERRCODE 23
    ‚îÇ       ‚îÇ       ‚îÇ   ISR_NOERRCODE 24
    ‚îÇ       ‚îÇ       ‚îÇ   ISR_NOERRCODE 25
    ‚îÇ       ‚îÇ       ‚îÇ   ISR_NOERRCODE 26
    ‚îÇ       ‚îÇ       ‚îÇ   ISR_NOERRCODE 27
    ‚îÇ       ‚îÇ       ‚îÇ   ISR_NOERRCODE 28
    ‚îÇ       ‚îÇ       ‚îÇ   ISR_NOERRCODE 29
    ‚îÇ       ‚îÇ       ‚îÇ   ISR_NOERRCODE 30
    ‚îÇ       ‚îÇ       ‚îÇ   ISR_NOERRCODE 31
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   // –°–æ–∑–¥–∞–µ–º –∑–∞–≥–ª—É—à–∫–∏ –¥–ª—è IRQ (32-47)
    ‚îÇ       ‚îÇ       ‚îÇ   ISR_NOERRCODE 32
    ‚îÇ       ‚îÇ       ‚îÇ   ISR_NOERRCODE 33
    ‚îÇ       ‚îÇ       ‚îÇ   ISR_NOERRCODE 34
    ‚îÇ       ‚îÇ       ‚îÇ   ISR_NOERRCODE 35
    ‚îÇ       ‚îÇ       ‚îÇ   ISR_NOERRCODE 36
    ‚îÇ       ‚îÇ       ‚îÇ   ISR_NOERRCODE 37
    ‚îÇ       ‚îÇ       ‚îÇ   ISR_NOERRCODE 38
    ‚îÇ       ‚îÇ       ‚îÇ   ISR_NOERRCODE 39
    ‚îÇ       ‚îÇ       ‚îÇ   ISR_NOERRCODE 40
    ‚îÇ       ‚îÇ       ‚îÇ   ISR_NOERRCODE 41
    ‚îÇ       ‚îÇ       ‚îÇ   ISR_NOERRCODE 42
    ‚îÇ       ‚îÇ       ‚îÇ   ISR_NOERRCODE 43
    ‚îÇ       ‚îÇ       ‚îÇ   ISR_NOERRCODE 44
    ‚îÇ       ‚îÇ       ‚îÇ   ISR_NOERRCODE 45
    ‚îÇ       ‚îÇ       ‚îÇ   ISR_NOERRCODE 46
    ‚îÇ       ‚îÇ       ‚îÇ   ISR_NOERRCODE 47
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   // –û–±—â–∏–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –≤—Å–µ—Ö –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏–π
    ‚îÇ       ‚îÇ       ‚îÇ   .extern isr_handler
    ‚îÇ       ‚îÇ       ‚îÇ   .type isr_common_stub, @function
    ‚îÇ       ‚îÇ       ‚îÇ   isr_common_stub:
    ‚îÇ       ‚îÇ       ‚îÇ       // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤—Å–µ —Ä–µ–≥–∏—Å—Ç—Ä—ã
    ‚îÇ       ‚îÇ       ‚îÇ       push %r15
    ‚îÇ       ‚îÇ       ‚îÇ       push %r14
    ‚îÇ       ‚îÇ       ‚îÇ       push %r13
    ‚îÇ       ‚îÇ       ‚îÇ       push %r12
    ‚îÇ       ‚îÇ       ‚îÇ       push %r11
    ‚îÇ       ‚îÇ       ‚îÇ       push %r10
    ‚îÇ       ‚îÇ       ‚îÇ       push %r9
    ‚îÇ       ‚îÇ       ‚îÇ       push %r8
    ‚îÇ       ‚îÇ       ‚îÇ       push %rdi
    ‚îÇ       ‚îÇ       ‚îÇ       push %rsi
    ‚îÇ       ‚îÇ       ‚îÇ       push %rbp
    ‚îÇ       ‚îÇ       ‚îÇ       push %rbx
    ‚îÇ       ‚îÇ       ‚îÇ       push %rdx
    ‚îÇ       ‚îÇ       ‚îÇ       push %rcx
    ‚îÇ       ‚îÇ       ‚îÇ       push %rax
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // –í—ã–∑—ã–≤–∞–µ–º C-–æ–±—Ä–∞–±–æ—Ç—á–∏–∫
    ‚îÇ       ‚îÇ       ‚îÇ       mov %rsp, %rdi
    ‚îÇ       ‚îÇ       ‚îÇ       call isr_handler
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ä–µ–≥–∏—Å—Ç—Ä—ã
    ‚îÇ       ‚îÇ       ‚îÇ       pop %rax
    ‚îÇ       ‚îÇ       ‚îÇ       pop %rcx
    ‚îÇ       ‚îÇ       ‚îÇ       pop %rdx
    ‚îÇ       ‚îÇ       ‚îÇ       pop %rbx
    ‚îÇ       ‚îÇ       ‚îÇ       pop %rbp
    ‚îÇ       ‚îÇ       ‚îÇ       pop %rsi
    ‚îÇ       ‚îÇ       ‚îÇ       pop %rdi
    ‚îÇ       ‚îÇ       ‚îÇ       pop %r8
    ‚îÇ       ‚îÇ       ‚îÇ       pop %r9
    ‚îÇ       ‚îÇ       ‚îÇ       pop %r10
    ‚îÇ       ‚îÇ       ‚îÇ       pop %r11
    ‚îÇ       ‚îÇ       ‚îÇ       pop %r12
    ‚îÇ       ‚îÇ       ‚îÇ       pop %r13
    ‚îÇ       ‚îÇ       ‚îÇ       pop %r14
    ‚îÇ       ‚îÇ       ‚îÇ       pop %r15
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // –û—á–∏—â–∞–µ–º –Ω–æ–º–µ—Ä –ø—Ä–µ—Ä—ã–≤–∞–Ω–∏—è –∏ –∫–æ–¥ –æ—à–∏–±–∫–∏
    ‚îÇ       ‚îÇ       ‚îÇ       add $16, %rsp
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       iretq
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   // –ó–∞–≥—Ä—É–∑–∫–∞ IDT
    ‚îÇ       ‚îÇ       ‚îÇ   .global idt_flush
    ‚îÇ       ‚îÇ       ‚îÇ   .type idt_flush, @function
    ‚îÇ       ‚îÇ       ‚îÇ   idt_flush:
    ‚îÇ       ‚îÇ       ‚îÇ       lidt (%rdi)
    ‚îÇ       ‚îÇ       ‚îÇ       ret
    ‚îÇ       ‚îÇ       ‚îÇ
    ‚îÇ       ‚îú‚îÄ‚îÄ kernel.c
    ‚îÇ           ‚îÇ
    ‚îÇ           ‚îú‚îÄ‚îÄ CONTENT:
    ‚îÇ           ‚îÇ   #include <stdint.h>
    ‚îÇ           ‚îÇ   #include <stdbool.h>
    ‚îÇ           ‚îÇ   #include <stddef.h>
    ‚îÇ           ‚îÇ   #include <limine.h>
    ‚îÇ           ‚îÇ   #include "include/graphics/fb.h"
    ‚îÇ           ‚îÇ   #include "include/graphics/color.h"
    ‚îÇ           ‚îÇ   #include "include/graphics/font.h"
    ‚îÇ           ‚îÇ   #include "include/drivers/serial.h"
    ‚îÇ           ‚îÇ   #include "include/graphics/banner.h"
    ‚îÇ           ‚îÇ   #include "include/drivers/io.h"
    ‚îÇ           ‚îÇ   #include "include/sys/gdt.h"
    ‚îÇ           ‚îÇ   #include "libc/string.h"
    ‚îÇ           ‚îÇ   #include "libc/stdio.h"
    ‚îÇ           ‚îÇ   #include "include/interrupts/idt.h"
    ‚îÇ           ‚îÇ   #include "include/interrupts/isr.h"
    ‚îÇ           ‚îÇ   #include "include/drivers/pic.h"
    ‚îÇ           ‚îÇ   #include "include/drivers/pit.h"
    ‚îÇ           ‚îÇ   #include "include/interrupts/irq.h"
    ‚îÇ           ‚îÇ   #include "include/memory/paging.h"
    ‚îÇ           ‚îÇ   #include "include/memory/heap.h"
    ‚îÇ           ‚îÇ   #include "include/memory/pmm.h"
    ‚îÇ           ‚îÇ   #include "include/memory/security.h"
    ‚îÇ           ‚îÇ   
    ‚îÇ           ‚îÇ   __attribute__((used, section(".limine_requests")))
    ‚îÇ           ‚îÇ   static volatile LIMINE_BASE_REVISION(3);
    ‚îÇ           ‚îÇ   
    ‚îÇ           ‚îÇ   __attribute__((used, section(".limine_requests")))
    ‚îÇ           ‚îÇ   static volatile struct limine_framebuffer_request framebuffer_request = {
    ‚îÇ           ‚îÇ       .id = LIMINE_FRAMEBUFFER_REQUEST,
    ‚îÇ           ‚îÇ       .revision = 0
    ‚îÇ           ‚îÇ   };
    ‚îÇ           ‚îÇ   
    ‚îÇ           ‚îÇ   __attribute__((used, section(".limine_requests")))
    ‚îÇ           ‚îÇ   static volatile struct limine_hhdm_request hhdm_request = {
    ‚îÇ           ‚îÇ       .id = LIMINE_HHDM_REQUEST,
    ‚îÇ           ‚îÇ       .revision = 0
    ‚îÇ           ‚îÇ   };
    ‚îÇ           ‚îÇ   
    ‚îÇ           ‚îÇ   __attribute__((used, section(".limine_requests")))
    ‚îÇ           ‚îÇ   static volatile struct limine_memmap_request memmap_request = {
    ‚îÇ           ‚îÇ       .id = LIMINE_MEMMAP_REQUEST,
    ‚îÇ           ‚îÇ       .revision = 0
    ‚îÇ           ‚îÇ   };
    ‚îÇ           ‚îÇ   
    ‚îÇ           ‚îÇ   __attribute__((used, section(".limine_requests_start")))
    ‚îÇ           ‚îÇ   static volatile LIMINE_REQUESTS_START_MARKER;
    ‚îÇ           ‚îÇ   
    ‚îÇ           ‚îÇ   __attribute__((used, section(".limine_requests_end")))
    ‚îÇ           ‚îÇ   static volatile LIMINE_REQUESTS_END_MARKER;
    ‚îÇ           ‚îÇ   
    ‚îÇ           ‚îÇ   static volatile struct limine_hhdm_response *hhdm_response = NULL;
    ‚îÇ           ‚îÇ   static volatile struct limine_memmap_response *memmap_response = NULL;
    ‚îÇ           ‚îÇ   
    ‚îÇ           ‚îÇ   void test_process1(void) {
    ‚îÇ           ‚îÇ       while (1) {
    ‚îÇ           ‚îÇ           printf("Process 1 running\n");
    ‚îÇ           ‚îÇ           for (volatile int i = 0; i < 1000000; i++);
    ‚îÇ           ‚îÇ       }
    ‚îÇ           ‚îÇ   }
    ‚îÇ           ‚îÇ   
    ‚îÇ           ‚îÇ   void test_process2(void) {
    ‚îÇ           ‚îÇ       while (1) {
    ‚îÇ           ‚îÇ           printf("Process 2 running\n");  
    ‚îÇ           ‚îÇ           for (volatile int i = 0; i < 1000000; i++);
    ‚îÇ           ‚îÇ       }
    ‚îÇ           ‚îÇ   }
    ‚îÇ           ‚îÇ   
    ‚îÇ           ‚îÇ   void kernel_main(void) {
    ‚îÇ           ‚îÇ       serial_init();
    ‚îÇ           ‚îÇ       serial_puts("[DEER] Kernel started\n");
    ‚îÇ           ‚îÇ   
    ‚îÇ           ‚îÇ       hhdm_response = hhdm_request.response;
    ‚îÇ           ‚îÇ       memmap_response = memmap_request.response;
    ‚îÇ           ‚îÇ       
    ‚îÇ           ‚îÇ       if (!hhdm_response) {
    ‚îÇ           ‚îÇ           serial_puts("[DEER] ERROR: No HHDM response from bootloader!\n");
    ‚îÇ           ‚îÇ       } else {
    ‚îÇ           ‚îÇ           serial_puts("[DEER] HHDM available\n");
    ‚îÇ           ‚îÇ       }
    ‚îÇ           ‚îÇ       
    ‚îÇ           ‚îÇ       if (!memmap_response) {
    ‚îÇ           ‚îÇ           serial_puts("[DEER] ERROR: No memory map response from bootloader!\n");
    ‚îÇ           ‚îÇ       } else {
    ‚îÇ           ‚îÇ           serial_puts("[DEER] Memory map available\n");
    ‚îÇ           ‚îÇ       }
    ‚îÇ           ‚îÇ       
    ‚îÇ           ‚îÇ       serial_puts("[DEER] Initializing GDT...\n");
    ‚îÇ           ‚îÇ       gdt_init();
    ‚îÇ           ‚îÇ       gdt_load();
    ‚îÇ           ‚îÇ       serial_puts("[DEER] GDT initialized\n");
    ‚îÇ           ‚îÇ   
    ‚îÇ           ‚îÇ       serial_puts("[DEER] Initializing paging...\n");
    ‚îÇ           ‚îÇ       paging_init(hhdm_response);
    ‚îÇ           ‚îÇ       serial_puts("[DEER] Paging initialized\n");
    ‚îÇ           ‚îÇ   
    ‚îÇ           ‚îÇ       serial_puts("[DEER] Initializing memory(PMM/HEAP)...\n");
    ‚îÇ           ‚îÇ       pmm_init(memmap_response, hhdm_response);
    ‚îÇ           ‚îÇ       heap_init();
    ‚îÇ           ‚îÇ       serial_puts("[DEER] Memory initialized\n");
    ‚îÇ           ‚îÇ       serial_puts("[DEER] Initializing memory security...\n");
    ‚îÇ           ‚îÇ       memory_security_init();
    ‚îÇ           ‚îÇ   
    ‚îÇ           ‚îÇ       // –í –≥–ª–∞–≤–Ω–æ–º —Ü–∏–∫–ª–µ –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏–µ –ø—Ä–æ–≤–µ—Ä–∫–∏
    ‚îÇ           ‚îÇ       static uint64_t last_security_check = 0;
    ‚îÇ           ‚îÇ       if (pit_get_ticks() - last_security_check > 1000) { // –ö–∞–∂–¥—É—é —Å–µ–∫—É–Ω–¥—É
    ‚îÇ           ‚îÇ           memory_security_check();
    ‚îÇ           ‚îÇ           last_security_check = pit_get_ticks();
    ‚îÇ           ‚îÇ       }
    ‚îÇ           ‚îÇ       serial_puts("[DEER] Initializing PIC...\n");
    ‚îÇ           ‚îÇ       pic_remap();
    ‚îÇ           ‚îÇ       serial_puts("[DEER] PIC remapped\n");
    ‚îÇ           ‚îÇ   
    ‚îÇ           ‚îÇ       serial_puts("[DEER] Initializing IDT...\n");
    ‚îÇ           ‚îÇ       idt_init();
    ‚îÇ           ‚îÇ       serial_puts("[DEER] IDT initialized\n");
    ‚îÇ           ‚îÇ   
    ‚îÇ           ‚îÇ       serial_puts("[DEER] Initializing IRQ...\n");
    ‚îÇ           ‚îÇ       irq_init();
    ‚îÇ           ‚îÇ       serial_puts("[DEER] IRQ initialized\n");
    ‚îÇ           ‚îÇ   
    ‚îÇ           ‚îÇ       serial_puts("[DEER] Initializing PIT...\n");
    ‚îÇ           ‚îÇ       pit_init();
    ‚îÇ           ‚îÇ       serial_puts("[DEER] PIT initialized\n");
    ‚îÇ           ‚îÇ   
    ‚îÇ           ‚îÇ       serial_puts("[DEER] Installing timer handler...\n");
    ‚îÇ           ‚îÇ       irq_install_handler(0, pit_timer_handler);
    ‚îÇ           ‚îÇ       serial_puts("[DEER] Timer handler installed\n");
    ‚îÇ           ‚îÇ   
    ‚îÇ           ‚îÇ       serial_puts("[DEER] Enabling interrupts...\n");
    ‚îÇ           ‚îÇ       idt_load();
    ‚îÇ           ‚îÇ       serial_puts("[DEER] Interrupts enabled\n");
    ‚îÇ           ‚îÇ   
    ‚îÇ           ‚îÇ   
    ‚îÇ           ‚îÇ       serial_puts("[DEER] All subsystems initialized successfully\n");
    ‚îÇ           ‚îÇ       serial_puts("[DEER] Timer should tick every second...\n");
    ‚îÇ           ‚îÇ   
    ‚îÇ           ‚îÇ       struct limine_framebuffer *fb = NULL;
    ‚îÇ           ‚îÇ   
    ‚îÇ           ‚îÇ       if (framebuffer_request.response && framebuffer_request.response->framebuffer_count > 0) {
    ‚îÇ           ‚îÇ           fb = framebuffer_request.response->framebuffers[0];
    ‚îÇ           ‚îÇ           printf_init_with_framebuffer(fb);  
    ‚îÇ           ‚îÇ       }
    ‚îÇ           ‚îÇ       printf_set_color(COLOR_GREEN);
    ‚îÇ           ‚îÇ       printf_set_bg_color(COLOR_BLACK);
    ‚îÇ           ‚îÇ           
    ‚îÇ           ‚îÇ       printf_clear();
    ‚îÇ           ‚îÇ       printf_set_color(COLOR_ORANGE);
    ‚îÇ           ‚îÇ       printf("\n\nDEER OS v0.0.1\n");
    ‚îÇ           ‚îÇ       printf("===============\n\n");
    ‚îÇ           ‚îÇ       printf_set_color(COLOR_CYAN);
    ‚îÇ           ‚îÇ       printf("System Status:\n");
    ‚îÇ           ‚îÇ       printf("--------------\n");
    ‚îÇ           ‚îÇ       printf_set_color(COLOR_GREEN);
    ‚îÇ           ‚îÇ       printf("GDT: ACTIVE\n");
    ‚îÇ           ‚îÇ       printf("PAGING: ACTIVE\n");
    ‚îÇ           ‚îÇ       printf("PMM: READY\n");
    ‚îÇ           ‚îÇ       printf("IDT: ACTIVE\n");
    ‚îÇ           ‚îÇ       printf("PIC: REMAPPED\n");
    ‚îÇ           ‚îÇ       printf("PIT: INITIALIZED\n");
    ‚îÇ           ‚îÇ       printf("INTERRUPTS: ENABLED\n");
    ‚îÇ           ‚îÇ       
    ‚îÇ           ‚îÇ       printf("\n");
    ‚îÇ           ‚îÇ           
    ‚îÇ           ‚îÇ       printf_set_color(COLOR_GREEN);
    ‚îÇ           ‚îÇ       printf("All systems ready - Timer active\n");
    ‚îÇ           ‚îÇ           
    ‚îÇ           ‚îÇ       serial_puts("[DEER] Graphics initialized successfully\n");
    ‚îÇ           ‚îÇ   
    ‚îÇ           ‚îÇ       serial_puts("[DEER] Entering main kernel loop...\n");
    ‚îÇ           ‚îÇ       
    ‚îÇ           ‚îÇ       while(1) {   
    ‚îÇ           ‚îÇ           asm volatile("hlt");
    ‚îÇ           ‚îÇ       }
    ‚îÇ           ‚îÇ   }
    ‚îÇ           ‚îÇ
    ‚îÇ       ‚îú‚îÄ‚îÄ libc
    ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ stdio
    ‚îÇ       ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ printf.c
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ CONTENT:
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #include <stdarg.h>
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #include <stdint.h>
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #include <stddef.h>
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #include "../stdio.h"
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #include "../../include/graphics/fb.h"
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #include "../../include/graphics/font.h"
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #include "../../include/graphics/color.h"
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #include "../../include/drivers/serial.h"
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #include "../string.h"
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #include <limine.h>
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è —Ç–µ–∫—É—â–µ–≥–æ —Ñ—Ä–µ–π–º–±—É—Ñ–µ—Ä–∞ –∏ –ø–æ–∑–∏—Ü–∏–∏ –∫—É—Ä—Å–æ—Ä–∞
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   static struct limine_framebuffer *current_fb = NULL;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   static uint32_t cursor_x = 5;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   static uint32_t cursor_y = 5;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   static uint32_t text_color = COLOR_WHITE;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   static uint32_t bg_color = COLOR_BLACK;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // –§–ª–∞–≥ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   static int printf_initialized = 0;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // –ù–∞—à —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–π –∑–∞–ø—Ä–æ—Å —Ñ—Ä–µ–π–º–±—É—Ñ–µ—Ä–∞
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   static volatile struct limine_framebuffer_request fb_request = {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       .id = LIMINE_FRAMEBUFFER_REQUEST,
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       .revision = 0
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   };
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è printf
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   static void printf_auto_init(void) {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       if (printf_initialized) return;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       // –ü—ã—Ç–∞–µ–º—Å—è –ø–æ–ª—É—á–∏—Ç—å —Ñ—Ä–µ–π–º–±—É—Ñ–µ—Ä –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       if (fb_request.response && fb_request.response->framebuffer_count > 0) {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ           current_fb = fb_request.response->framebuffers[0];
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ           serial_puts("[PRINTF] Auto-initialized with framebuffer\n");
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       } else {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ           serial_puts("[PRINTF] WARNING: No framebuffer available, using serial only\n");
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       printf_initialized = 1;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // –£—Å—Ç–∞–Ω–æ–≤–∫–∞ —Ç–µ–∫—É—â–µ–≥–æ —Ñ—Ä–µ–π–º–±—É—Ñ–µ—Ä–∞
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void printf_set_framebuffer(struct limine_framebuffer *fb) {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       current_fb = fb;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       printf_initialized = 1;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       char buffer[32];
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       serial_puts("[PRINTF] Framebuffer set manually at 0x");
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       serial_puts(itoa((uint64_t)fb, buffer, 16));
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       serial_puts("\n");
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –ø–æ–∑–∏—Ü–∏–∏ –∫—É—Ä—Å–æ—Ä–∞
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void printf_set_cursor(uint32_t x, uint32_t y) {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       cursor_x = x;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       cursor_y = y;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // –£—Å—Ç–∞–Ω–æ–≤–∫–∞ —Ü–≤–µ—Ç–∞ —Ç–µ–∫—Å—Ç–∞
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void printf_set_color(uint32_t color) {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       text_color = color;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // –£—Å—Ç–∞–Ω–æ–≤–∫–∞ —Ü–≤–µ—Ç–∞ —Ñ–æ–Ω–∞
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void printf_set_bg_color(uint32_t color) {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       bg_color = color;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // –ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–µ–∫—É—â–µ–π –ø–æ–∑–∏—Ü–∏–∏ –∫—É—Ä—Å–æ—Ä–∞
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void printf_get_cursor(uint32_t *x, uint32_t *y) {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       *x = cursor_x;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       *y = cursor_y;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // –ü—Ä–æ–∫—Ä—É—Ç–∫–∞ —ç–∫—Ä–∞–Ω–∞
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   static void scroll_screen(void) {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       if (!current_fb) return;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       uint32_t scroll_height = 16; // –í—ã—Å–æ—Ç–∞ –æ–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–∏
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       uint32_t screen_height = current_fb->height;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       uint32_t screen_width = current_fb->width;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       // –ö–æ–ø–∏—Ä—É–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —ç–∫—Ä–∞–Ω–∞ –≤–≤–µ—Ä—Ö
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       for (uint32_t y = scroll_height; y < screen_height; y++) {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ           for (uint32_t x = 0; x < screen_width; x++) {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ               uint32_t *fb_ptr = (uint32_t *)current_fb->address;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ               uint32_t pitch = current_fb->pitch / 4;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ               fb_ptr[(y - scroll_height) * pitch + x] = fb_ptr[y * pitch + x];
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ           }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       // –û—á–∏—â–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω—é—é —Å—Ç—Ä–æ–∫—É
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       for (uint32_t y = screen_height - scroll_height; y < screen_height; y++) {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ           for (uint32_t x = 0; x < screen_width; x++) {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ               fb_draw_pixel(current_fb, x, y, bg_color);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ           }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–∑–∏—Ü–∏—é –∫—É—Ä—Å–æ—Ä–∞
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       cursor_y -= scroll_height;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // –û—á–∏—Å—Ç–∫–∞ —ç–∫—Ä–∞–Ω–∞
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void printf_clear(void) {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       printf_auto_init();
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       if (!current_fb) return;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       fb_clear(current_fb, bg_color);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       cursor_x = 5;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       cursor_y = 5;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // –í—ã–≤–æ–¥ –æ–¥–Ω–æ–≥–æ —Å–∏–º–≤–æ–ª–∞ —Å –æ–±—Ä–∞–±–æ—Ç–∫–æ–π —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   static void putchar(char c) {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       printf_auto_init();
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       // –í—Å–µ–≥–¥–∞ –≤—ã–≤–æ–¥–∏–º –≤ serial –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       if (c == '\n') {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ           serial_putc('\r');
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       serial_putc(c);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       if (!current_fb) return;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       switch (c) {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ           case '\n': // –ù–æ–≤–∞—è —Å—Ç—Ä–æ–∫–∞
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ               cursor_x = 5;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ               cursor_y += 16;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ               break;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ               
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ           case '\r': // –í–æ–∑–≤—Ä–∞—Ç –∫–∞—Ä–µ—Ç–∫–∏
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ               cursor_x = 5;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ               break;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ               
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ           case '\t': // –¢–∞–±—É–ª—è—Ü–∏—è
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ               cursor_x = (cursor_x + 32) & ~31; // –í—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏–µ –¥–æ 32 –ø–∏–∫—Å–µ–ª–µ–π
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ               break;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ               
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ           case '\b': // Backspace
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ               if (cursor_x > 5) {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                   cursor_x -= 8;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                   // –°—Ç–∏—Ä–∞–µ–º —Å–∏–º–≤–æ–ª
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                   fb_fill_rect(current_fb, cursor_x, cursor_y, 8, 16, bg_color);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ               }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ               break;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ               
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ           default:
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ               // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –≤—ã—à–ª–∏ –ª–∏ –º—ã –∑–∞ –≥—Ä–∞–Ω–∏—Ü—ã —ç–∫—Ä–∞–Ω–∞
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ               if (cursor_x + 8 >= current_fb->width) {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                   cursor_x = 5;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                   cursor_y += 16;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ               }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ               
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ               if (cursor_y + 16 >= current_fb->height) {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                   scroll_screen();
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ               }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ               
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ               // –í—ã–≤–æ–¥–∏–º —Å–∏–º–≤–æ–ª
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ               fb_draw_char(current_fb, c, cursor_x, cursor_y, text_color);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ               cursor_x += 8;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ               break;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –≤—ã–≤–æ–¥–∞ —Å—Ç—Ä–æ–∫–∏
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   static void putstring(const char *str) {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       while (*str) {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ           putchar(*str++);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –≤—ã–≤–æ–¥–∞ —á–∏—Å–ª–∞ –≤ —É–∫–∞–∑–∞–Ω–Ω–æ–π —Å–∏—Å—Ç–µ–º–µ —Å—á–∏—Å–ª–µ–Ω–∏—è
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   static void putnumber(uint64_t num, int base, int is_signed, int is_long) {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       (void)is_long; // –ü–æ–º–µ—á–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä –∫–∞–∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–Ω—ã–π
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       char buffer[65];
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       if (is_signed && (int64_t)num < 0) {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ           putchar('-');
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ           num = (uint64_t)(-(int64_t)num);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º —á–∏—Å–ª–æ –≤ —Å—Ç—Ä–æ–∫—É
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       itoa(num, buffer, base);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       // –í—ã–≤–æ–¥–∏–º —Å—Ç—Ä–æ–∫—É
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       putstring(buffer);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è printf
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   int printf(const char *format, ...) {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       printf_auto_init();
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       va_list args;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       va_start(args, format);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       int chars_written = 0;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       while (*format) {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ           if (*format == '%') {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ               format++;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ               
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ               // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ñ–ª–∞–≥–æ–≤
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ               int is_long = 0;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ               int is_alt = 0;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ               
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ               while (1) {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                   switch (*format) {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                       case 'l':
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                           is_long = 1;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                           format++;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                           continue;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                       case '#':
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                           is_alt = 1;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                           format++;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                           continue;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                       default:
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                           break;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                   }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                   break;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ               }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ               
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ               // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–ø–µ—Ü–∏—Ñ–∏–∫–∞—Ç–æ—Ä–æ–≤
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ               switch (*format) {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                   case 'd':
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                   case 'i': { // –¶–µ–ª–æ–µ —á–∏—Å–ª–æ —Å–æ –∑–Ω–∞–∫–æ–º
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                       if (is_long) {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                           int64_t num = va_arg(args, int64_t);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                           putnumber((uint64_t)num, 10, 1, is_long);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                       } else {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                           int num = va_arg(args, int);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                           putnumber((uint64_t)num, 10, 1, is_long);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                       }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                       chars_written++;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                       break;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                   }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                   case 'u': { // –¶–µ–ª–æ–µ —á–∏—Å–ª–æ –±–µ–∑ –∑–Ω–∞–∫–∞
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                       if (is_long) {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                           uint64_t num = va_arg(args, uint64_t);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                           putnumber(num, 10, 0, is_long);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                       } else {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                           unsigned int num = va_arg(args, unsigned int);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                           putnumber(num, 10, 0, is_long);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                       }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                       chars_written++;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                       break;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                   }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                   case 'x': { // –®–µ—Å—Ç–Ω–∞–¥—Ü–∞—Ç–µ—Ä–∏—á–Ω–æ–µ —á–∏—Å–ª–æ
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                       if (is_long) {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                           uint64_t num = va_arg(args, uint64_t);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                           if (is_alt) putstring("0x");
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                           putnumber(num, 16, 0, is_long);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                       } else {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                           unsigned int num = va_arg(args, unsigned int);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                           if (is_alt) putstring("0x");
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                           putnumber(num, 16, 0, is_long);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                       }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                       chars_written++;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                       break;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                   }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                   case 'o': { // –í–æ—Å—å–º–µ—Ä–∏—á–Ω–æ–µ —á–∏—Å–ª–æ
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                       if (is_long) {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                           uint64_t num = va_arg(args, uint64_t);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                           if (is_alt) putstring("0");
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                           putnumber(num, 8, 0, is_long);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                       } else {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                           unsigned int num = va_arg(args, unsigned int);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                           if (is_alt) putstring("0");
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                           putnumber(num, 8, 0, is_long);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                       }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                       chars_written++;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                       break;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                   }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                   case 'p': { // –£–∫–∞–∑–∞—Ç–µ–ª—å
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                       void *ptr = va_arg(args, void*);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                       putstring("0x");
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                       putnumber((uint64_t)ptr, 16, 0, 1);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                       chars_written++;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                       break;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                   }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                   case 'c': { // –°–∏–º–≤–æ–ª
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                       char c = (char)va_arg(args, int);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                       putchar(c);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                       chars_written++;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                       break;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                   }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                   case 's': { // –°—Ç—Ä–æ–∫–∞
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                       char *str = va_arg(args, char*);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                       if (!str) {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                           putstring("(null)");
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                       } else {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                           putstring(str);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                       }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                       chars_written++;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                       break;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                   }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                   case '%': { // –°–∏–º–≤–æ–ª –ø—Ä–æ—Ü–µ–Ω—Ç–∞
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                       putchar('%');
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                       chars_written++;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                       break;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                   }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                   default: // –ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Å–ø–µ—Ü–∏—Ñ–∏–∫–∞—Ç–æ—Ä
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                       putchar('%');
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                       putchar(*format);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                       chars_written += 2;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ                       break;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ               }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ           } else {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ               // –û–±—ã—á–Ω—ã–π —Å–∏–º–≤–æ–ª
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ               putchar(*format);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ               chars_written++;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ           }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ           
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ           format++;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       va_end(args);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       return chars_written;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   // –£–ø—Ä–æ—â–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è printf –¥–ª—è —Å—Ç—Ä–æ–∫–∏
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   int puts(const char *str) {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       int result = printf("%s\n", str);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       return result;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void printf_init_with_framebuffer(struct limine_framebuffer *fb) {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       current_fb = fb;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       printf_initialized = 1;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       serial_puts("[PRINTF] Initialized with framebuffer\n");
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ stdio.h
    ‚îÇ       ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ       ‚îú‚îÄ‚îÄ CONTENT:
    ‚îÇ       ‚îÇ       ‚îÇ   #ifndef STDIO_H
    ‚îÇ       ‚îÇ       ‚îÇ   #define STDIO_H
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   #include <stdint.h>
    ‚îÇ       ‚îÇ       ‚îÇ   #include <stddef.h>
    ‚îÇ       ‚îÇ       ‚îÇ   #include <limine.h>
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   // –§—É–Ω–∫—Ü–∏–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –≤—ã–≤–æ–¥–æ–º
    ‚îÇ       ‚îÇ       ‚îÇ   void printf_set_framebuffer(struct limine_framebuffer *fb);
    ‚îÇ       ‚îÇ       ‚îÇ   void printf_set_cursor(uint32_t x, uint32_t y);
    ‚îÇ       ‚îÇ       ‚îÇ   void printf_set_color(uint32_t color);
    ‚îÇ       ‚îÇ       ‚îÇ   void printf_set_bg_color(uint32_t color);
    ‚îÇ       ‚îÇ       ‚îÇ   void printf_get_cursor(uint32_t *x, uint32_t *y);
    ‚îÇ       ‚îÇ       ‚îÇ   void printf_clear(void);
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   // –û—Å–Ω–æ–≤–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –≤—ã–≤–æ–¥–∞
    ‚îÇ       ‚îÇ       ‚îÇ   int printf(const char *format, ...);
    ‚îÇ       ‚îÇ       ‚îÇ   int puts(const char *str);
    ‚îÇ       ‚îÇ       ‚îÇ   void printf_init_with_framebuffer(struct limine_framebuffer *fb);
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   #endif // STDIO_H
    ‚îÇ       ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ string
    ‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ itoa.c
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ CONTENT:
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #include <stdint.h>
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   char* itoa(uint64_t value, char* str, int base) {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       if (base < 2 || base > 16) {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ           str[0] = '\0';
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ           return str;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       char* ptr = str;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       char* end = str;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       if (value == 0) {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ           *end++ = '0';
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       } else {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ           while (value > 0) {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ               int digit = value % base;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ               *end++ = (digit < 10 ? '0' + digit : 'a' + digit - 10);
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ               value /= base;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ           }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       // –†–∞–∑–≤–æ—Ä–∞—á–∏–≤–∞–µ–º —Å—Ç—Ä–æ–∫—É
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       *end = '\0';
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       end--;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       while (ptr < end) {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ           char tmp = *ptr;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ           *ptr = *end;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ           *end = tmp;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ           ptr++;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ           end--;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       return str;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ memcmp.c
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ CONTENT:
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #include <stddef.h>
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #include <stdint.h>
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   int memcmp(const void *s1, const void *s2, size_t n) {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       const uint8_t *p1 = (const uint8_t *)s1;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       const uint8_t *p2 = (const uint8_t *)s2;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       for (size_t i = 0; i < n; i++) {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ           if (p1[i] != p2[i]) {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ               return p1[i] < p2[i] ? -1 : 1;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ           }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       return 0;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ memcpy.c
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ CONTENT:
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #include <stddef.h>
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #include <stdint.h>
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void *memcpy(void *restrict dest, const void *restrict src, size_t n) {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       uint8_t *restrict pdest = (uint8_t *restrict)dest;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       const uint8_t *restrict psrc = (const uint8_t *restrict)src;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       for (size_t i = 0; i < n; i++) {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ           pdest[i] = psrc[i];
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       return dest;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ memmove.c
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ CONTENT:
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #include <stddef.h>
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #include <stdint.h>
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void *memmove(void *dest, const void *src, size_t n) {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       uint8_t *pdest = (uint8_t *)dest;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       const uint8_t *psrc = (const uint8_t *)src;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       if (src > dest) {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ           for (size_t i = 0; i < n; i++) {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ               pdest[i] = psrc[i];
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ           }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       } else if (src < dest) {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ           for (size_t i = n; i > 0; i--) {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ               pdest[i-1] = psrc[i-1];
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ           }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       return dest;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ memset.c
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ CONTENT:
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #include <stddef.h>
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #include <stdint.h>
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   void *memset(void *s, int c, size_t n) {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       uint8_t *p = (uint8_t *)s;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       for (size_t i = 0; i < n; i++) {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ           p[i] = (uint8_t)c;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       return s;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ strcat.c
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ CONTENT:
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #include <stddef.h>
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   char* strcat(char* dest, const char* src) {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       char* ptr = dest;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       // –ù–∞—Ö–æ–¥–∏–º –∫–æ–Ω–µ—Ü dest
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       while (*ptr != '\0') {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ           ptr++;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       // –ö–æ–ø–∏—Ä—É–µ–º src –≤ –∫–æ–Ω–µ—Ü dest
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       while (*src != '\0') {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ           *ptr++ = *src++;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       *ptr = '\0';
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       return dest;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ strcpy.c
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ CONTENT:
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #include <stddef.h>
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   char* strcpy(char* dest, const char* src) {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       if (dest == NULL || src == NULL) {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ           return NULL;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       char* ptr = dest;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       while (*src != '\0') {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ           *ptr++ = *src++;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       *ptr = '\0';
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       return dest;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ strlen.c
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ CONTENT:
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #include <stddef.h>
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   size_t strlen(const char *str) {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       size_t len = 0;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       while (str[len] != '\0') {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ           len++;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       return len;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ strncpy.c
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ CONTENT:
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   #include <stddef.h>
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   char* strncpy(char* dest, const char* src, size_t n) {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       if (dest == NULL || src == NULL) {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ           return dest; // –ù–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–µ –ø–æ–≤–µ–¥–µ–Ω–∏–µ –ø–æ —Å—Ç–∞–Ω–¥–∞—Ä—Ç—É, –Ω–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º dest
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       char* ptr = dest;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       size_t i = 0;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       // –ö–æ–ø–∏—Ä—É–µ–º —Å–∏–º–≤–æ–ª—ã –∏–∑ src –≤ dest, –ø–æ–∫–∞ –Ω–µ –¥–æ—Å—Ç–∏–≥–Ω–µ–º –∫–æ–Ω—Ü–∞ src –∏–ª–∏ n —Å–∏–º–≤–æ–ª–æ–≤
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       while (i < n && src[i] != '\0') {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ           ptr[i] = src[i];
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ           i++;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       // –ó–∞–ø–æ–ª–Ω—è–µ–º –æ—Å—Ç–∞–≤—à–∏–µ—Å—è –ø–æ–∑–∏—Ü–∏–∏ –≤ dest –Ω—É–ª–µ–≤—ã–º–∏ –±–∞–π—Ç–∞–º–∏
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       while (i < n) {
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ           ptr[i] = '\0';
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ           i++;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ       return dest;
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ   ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ string.h
    ‚îÇ       ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ       ‚îú‚îÄ‚îÄ CONTENT:
    ‚îÇ       ‚îÇ       ‚îÇ   #ifndef STRING_H
    ‚îÇ       ‚îÇ       ‚îÇ   #define STRING_H
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   #include <stddef.h>
    ‚îÇ       ‚îÇ       ‚îÇ   #include <stdint.h>
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   void *memcpy(void *restrict dest, const void *restrict src, size_t n);
    ‚îÇ       ‚îÇ       ‚îÇ   void *memset(void *s, int c, size_t n);
    ‚îÇ       ‚îÇ       ‚îÇ   void *memmove(void *dest, const void *src, size_t n);
    ‚îÇ       ‚îÇ       ‚îÇ   int memcmp(const void *s1, const void *s2, size_t n);
    ‚îÇ       ‚îÇ       ‚îÇ   char* itoa(uint64_t value, char* str, int base);
    ‚îÇ       ‚îÇ       ‚îÇ   size_t strlen(const char *str);
    ‚îÇ       ‚îÇ       ‚îÇ   char* strcat(char* dest, const char* src);
    ‚îÇ       ‚îÇ       ‚îÇ   char* strcpy(char* dest, const char* src);
    ‚îÇ       ‚îÇ       ‚îÇ   char* strncpy(char* dest, const char* src, size_t n);
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   #endif // STRING_H
    ‚îÇ       ‚îÇ       ‚îÇ
    ‚îÇ       ‚îú‚îÄ‚îÄ memory
    ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ heap.c
    ‚îÇ       ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ       ‚îú‚îÄ‚îÄ CONTENT:
    ‚îÇ       ‚îÇ       ‚îÇ   #include "include/memory/heap.h"
    ‚îÇ       ‚îÇ       ‚îÇ   #include "include/memory/paging.h"
    ‚îÇ       ‚îÇ       ‚îÇ   #include "include/memory/pmm.h"
    ‚îÇ       ‚îÇ       ‚îÇ   #include "include/drivers/serial.h"
    ‚îÇ       ‚îÇ       ‚îÇ   #include "libc/string.h"
    ‚îÇ       ‚îÇ       ‚îÇ   #include "libc/stdio.h"
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   static struct heap kernel_heap = {0};
    ‚îÇ       ‚îÇ       ‚îÇ   static bool poisoning_enabled = true;
    ‚îÇ       ‚îÇ       ‚îÇ   static bool guard_pages_enabled = false;
    ‚îÇ       ‚îÇ       ‚îÇ   static bool lockdown_mode = false;
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   // Simple checksum function for integrity checking
    ‚îÇ       ‚îÇ       ‚îÇ   static uint32_t calculate_checksum(struct heap_block* block) {
    ‚îÇ       ‚îÇ       ‚îÇ       uint32_t sum = 0;
    ‚îÇ       ‚îÇ       ‚îÇ       uint8_t* data = (uint8_t*)block;
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // Skip checksum field itself in calculation
    ‚îÇ       ‚îÇ       ‚îÇ       for (size_t i = 0; i < offsetof(struct heap_block, checksum); i++) {
    ‚îÇ       ‚îÇ       ‚îÇ           sum = (sum << 3) ^ data[i];
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       for (size_t i = offsetof(struct heap_block, checksum) + sizeof(uint32_t); 
    ‚îÇ       ‚îÇ       ‚îÇ            i < sizeof(struct heap_block); i++) {
    ‚îÇ       ‚îÇ       ‚îÇ           sum = (sum << 3) ^ data[i];
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       return sum;
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   // Validate a single heap block
    ‚îÇ       ‚îÇ       ‚îÇ   bool heap_validate_block(struct heap_block* block) {
    ‚îÇ       ‚îÇ       ‚îÇ       if (!block) return false;
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // Check canaries
    ‚îÇ       ‚îÇ       ‚îÇ       if (block->canary_start != HEAP_CANARY_VALUE || 
    ‚îÇ       ‚îÇ       ‚îÇ           block->canary_end != HEAP_CANARY_VALUE) {
    ‚îÇ       ‚îÇ       ‚îÇ           kernel_heap.stats.buffer_overflow_detected++;
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts("[HEAP SECURITY] Buffer overflow detected! Canary corrupted.\n");
    ‚îÇ       ‚îÇ       ‚îÇ           return false;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // Check checksum
    ‚îÇ       ‚îÇ       ‚îÇ       uint32_t saved_checksum = block->checksum;
    ‚îÇ       ‚îÇ       ‚îÇ       block->checksum = 0;
    ‚îÇ       ‚îÇ       ‚îÇ       uint32_t calculated_checksum = calculate_checksum(block);
    ‚îÇ       ‚îÇ       ‚îÇ       block->checksum = saved_checksum;
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       if (saved_checksum != calculated_checksum) {
    ‚îÇ       ‚îÇ       ‚îÇ           kernel_heap.stats.corruption_count++;
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts("[HEAP SECURITY] Heap block checksum mismatch! Memory corrupted.\n");
    ‚îÇ       ‚îÇ       ‚îÇ           return false;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // Check size validity
    ‚îÇ       ‚îÇ       ‚îÇ       if (block->size > HEAP_MAX_ALLOC_SIZE || block->size < HEAP_MIN_ALLOC_SIZE) {
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts("[HEAP SECURITY] Invalid block size detected!\n");
    ‚îÇ       ‚îÇ       ‚îÇ           return false;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // Check if block is within heap bounds
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t block_addr = (uint64_t)block;
    ‚îÇ       ‚îÇ       ‚îÇ       if (block_addr < (uint64_t)kernel_heap.start || 
    ‚îÇ       ‚îÇ       ‚îÇ           block_addr >= (uint64_t)kernel_heap.end) {
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts("[HEAP SECURITY] Block outside heap boundaries!\n");
    ‚îÇ       ‚îÇ       ‚îÇ           return false;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       return true;
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   // Initialize a new heap block with security features
    ‚îÇ       ‚îÇ       ‚îÇ   static void initialize_block(struct heap_block* block, size_t size, size_t requested_size, 
    ‚îÇ       ‚îÇ       ‚îÇ                              bool used, uint8_t protection_flags) {
    ‚îÇ       ‚îÇ       ‚îÇ       block->canary_start = HEAP_CANARY_VALUE;
    ‚îÇ       ‚îÇ       ‚îÇ       block->size = size;
    ‚îÇ       ‚îÇ       ‚îÇ       block->requested_size = requested_size;
    ‚îÇ       ‚îÇ       ‚îÇ       block->used = used;
    ‚îÇ       ‚îÇ       ‚îÇ       block->protection_flags = protection_flags;
    ‚îÇ       ‚îÇ       ‚îÇ       block->next = NULL;
    ‚îÇ       ‚îÇ       ‚îÇ       block->prev = NULL;
    ‚îÇ       ‚îÇ       ‚îÇ       block->allocation_ptr = (void*)((uint8_t*)block + sizeof(struct heap_block));
    ‚îÇ       ‚îÇ       ‚îÇ       block->canary_end = HEAP_CANARY_VALUE;
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // Calculate and set checksum
    ‚îÇ       ‚îÇ       ‚îÇ       block->checksum = 0;
    ‚îÇ       ‚îÇ       ‚îÇ       block->checksum = calculate_checksum(block);
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // Apply memory poisoning
    ‚îÇ       ‚îÇ       ‚îÇ       if (poisoning_enabled) {
    ‚îÇ       ‚îÇ       ‚îÇ           uint8_t poison = used ? HEAP_ALLOC_POISON : HEAP_FREE_POISON;
    ‚îÇ       ‚îÇ       ‚îÇ           memset(block->allocation_ptr, poison, size);
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   // Find the best fit block with security validation
    ‚îÇ       ‚îÇ       ‚îÇ   static struct heap_block* find_best_fit_block(size_t size) {
    ‚îÇ       ‚îÇ       ‚îÇ       struct heap_block* current = kernel_heap.first_block;
    ‚îÇ       ‚îÇ       ‚îÇ       struct heap_block* best_fit = NULL;
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       while (current != NULL) {
    ‚îÇ       ‚îÇ       ‚îÇ           // Validate block before using it
    ‚îÇ       ‚îÇ       ‚îÇ           if (!heap_validate_block(current)) {
    ‚îÇ       ‚îÇ       ‚îÇ               serial_puts("[HEAP SECURITY] Corrupted block detected during allocation!\n");
    ‚îÇ       ‚îÇ       ‚îÇ               return NULL;
    ‚îÇ       ‚îÇ       ‚îÇ           }
    ‚îÇ       ‚îÇ       ‚îÇ           
    ‚îÇ       ‚îÇ       ‚îÇ           if (!current->used && current->size >= size) {
    ‚îÇ       ‚îÇ       ‚îÇ               if (best_fit == NULL || current->size < best_fit->size) {
    ‚îÇ       ‚îÇ       ‚îÇ                   best_fit = current;
    ‚îÇ       ‚îÇ       ‚îÇ               }
    ‚îÇ       ‚îÇ       ‚îÇ           }
    ‚îÇ       ‚îÇ       ‚îÇ           current = current->next;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       return best_fit;
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   // Emergency lockdown when corruption is detected
    ‚îÇ       ‚îÇ       ‚îÇ   void heap_emergency_lockdown(void) {
    ‚îÇ       ‚îÇ       ‚îÇ       lockdown_mode = true;
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts("[HEAP SECURITY] EMERGENCY LOCKDOWN ACTIVATED!\n");
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts("[HEAP SECURITY] All further allocations are blocked.\n");
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // Try to dump current state for debugging
    ‚îÇ       ‚îÇ       ‚îÇ       heap_dump_blocks();
    ‚îÇ       ‚îÇ       ‚îÇ       heap_print_stats();
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   // Enhanced heap initialization with security
    ‚îÇ       ‚îÇ       ‚îÇ   void heap_init(void) {
    ‚îÇ       ‚îÇ       ‚îÇ       if (lockdown_mode) {
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts("[HEAP SECURITY] Cannot initialize - system in lockdown mode!\n");
    ‚îÇ       ‚îÇ       ‚îÇ           return;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts("[HEAP] Initializing secure kernel heap...\n");
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // Initialize security statistics
    ‚îÇ       ‚îÇ       ‚îÇ       memset(&kernel_heap.stats, 0, sizeof(kernel_heap.stats));
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // Allocate initial pages with guard page protection
    ‚îÇ       ‚îÇ       ‚îÇ       size_t initial_pages = HEAP_INITIAL_SIZE / PAGE_SIZE_4K;
    ‚îÇ       ‚îÇ       ‚îÇ       if (guard_pages_enabled) {
    ‚îÇ       ‚îÇ       ‚îÇ           initial_pages++; // Extra page for guard
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       for (size_t i = 0; i < initial_pages; i++) {
    ‚îÇ       ‚îÇ       ‚îÇ           uint64_t physical_page = pmm_alloc_page();
    ‚îÇ       ‚îÇ       ‚îÇ           if (!physical_page) {
    ‚îÇ       ‚îÇ       ‚îÇ               serial_puts("[HEAP] ERROR: Failed to allocate initial heap pages!\n");
    ‚îÇ       ‚îÇ       ‚îÇ               heap_emergency_lockdown();
    ‚îÇ       ‚îÇ       ‚îÇ               return;
    ‚îÇ       ‚îÇ       ‚îÇ           }
    ‚îÇ       ‚îÇ       ‚îÇ           
    ‚îÇ       ‚îÇ       ‚îÇ           uint64_t virtual_addr = HEAP_START + (i * PAGE_SIZE_4K);
    ‚îÇ       ‚îÇ       ‚îÇ           uint64_t flags = PAGING_PRESENT | PAGING_WRITABLE;
    ‚îÇ       ‚îÇ       ‚îÇ           
    ‚îÇ       ‚îÇ       ‚îÇ           // Mark guard page as non-present
    ‚îÇ       ‚îÇ       ‚îÇ           if (guard_pages_enabled && i == initial_pages - 1) {
    ‚îÇ       ‚îÇ       ‚îÇ               flags = PAGING_NO_EXECUTE; // Guard page - no access
    ‚îÇ       ‚îÇ       ‚îÇ           }
    ‚îÇ       ‚îÇ       ‚îÇ           
    ‚îÇ       ‚îÇ       ‚îÇ           if (!paging_map_page(virtual_addr, physical_page, flags)) {
    ‚îÇ       ‚îÇ       ‚îÇ               serial_puts("[HEAP] ERROR: Failed to map heap page!\n");
    ‚îÇ       ‚îÇ       ‚îÇ               pmm_free_page(physical_page);
    ‚îÇ       ‚îÇ       ‚îÇ               heap_emergency_lockdown();
    ‚îÇ       ‚îÇ       ‚îÇ               return;
    ‚îÇ       ‚îÇ       ‚îÇ           }
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // Initialize heap structure
    ‚îÇ       ‚îÇ       ‚îÇ       kernel_heap.start = (void*)HEAP_START;
    ‚îÇ       ‚îÇ       ‚îÇ       kernel_heap.end = (void*)(HEAP_START + HEAP_INITIAL_SIZE);
    ‚îÇ       ‚îÇ       ‚îÇ       kernel_heap.total_size = HEAP_INITIAL_SIZE;
    ‚îÇ       ‚îÇ       ‚îÇ       kernel_heap.used_size = sizeof(struct heap_block);
    ‚îÇ       ‚îÇ       ‚îÇ       kernel_heap.alloc_count = 0;
    ‚îÇ       ‚îÇ       ‚îÇ       kernel_heap.free_count = 0;
    ‚îÇ       ‚îÇ       ‚îÇ       kernel_heap.corruption_count = 0;
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // Create first free block with security features
    ‚îÇ       ‚îÇ       ‚îÇ       struct heap_block* first_block = (struct heap_block*)HEAP_START;
    ‚îÇ       ‚îÇ       ‚îÇ       size_t first_block_size = HEAP_INITIAL_SIZE - sizeof(struct heap_block);
    ‚îÇ       ‚îÇ       ‚îÇ       initialize_block(first_block, first_block_size, 0, false, 0);
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       kernel_heap.first_block = first_block;
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts("[HEAP] Secure kernel heap initialized with canaries and checksums\n");
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   // Secure memory allocation with comprehensive checking
    ‚îÇ       ‚îÇ       ‚îÇ   void* kmalloc(size_t size) {
    ‚îÇ       ‚îÇ       ‚îÇ       return kmalloc_protected(size, 0);
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   void* kmalloc_protected(size_t size, uint8_t protection_flags) {
    ‚îÇ       ‚îÇ       ‚îÇ       if (lockdown_mode) {
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts("[HEAP SECURITY] Allocation blocked - system in lockdown!\n");
    ‚îÇ       ‚îÇ       ‚îÇ           kernel_heap.stats.failed_allocations++;
    ‚îÇ       ‚îÇ       ‚îÇ           return NULL;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // Input validation
    ‚îÇ       ‚îÇ       ‚îÇ       if (size == 0 || size > HEAP_MAX_ALLOC_SIZE) {
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts("[HEAP SECURITY] Invalid allocation size requested!\n");
    ‚îÇ       ‚îÇ       ‚îÇ           kernel_heap.stats.failed_allocations++;
    ‚îÇ       ‚îÇ       ‚îÇ           return NULL;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // Align size
    ‚îÇ       ‚îÇ       ‚îÇ       size = (size + HEAP_ALIGNMENT - 1) & ~(HEAP_ALIGNMENT - 1);
    ‚îÇ       ‚îÇ       ‚îÇ       if (size < HEAP_MIN_ALLOC_SIZE) {
    ‚îÇ       ‚îÇ       ‚îÇ           size = HEAP_MIN_ALLOC_SIZE;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // Check heap integrity before allocation
    ‚îÇ       ‚îÇ       ‚îÇ       if (!heap_validate_all_blocks()) {
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts("[HEAP SECURITY] Heap corruption detected before allocation!\n");
    ‚îÇ       ‚îÇ       ‚îÇ           heap_emergency_lockdown();
    ‚îÇ       ‚îÇ       ‚îÇ           return NULL;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       struct heap_block* best_fit = find_best_fit_block(size);
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       if (best_fit == NULL) {
    ‚îÇ       ‚îÇ       ‚îÇ           kernel_heap.stats.failed_allocations++;
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts("[HEAP] No suitable block found, allocation failed\n");
    ‚îÇ       ‚îÇ       ‚îÇ           return NULL;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // Split block if it's significantly larger
    ‚îÇ       ‚îÇ       ‚îÇ       if (best_fit->size >= size + sizeof(struct heap_block) + HEAP_MIN_ALLOC_SIZE) {
    ‚îÇ       ‚îÇ       ‚îÇ           struct heap_block* new_block = (struct heap_block*)(
    ‚îÇ       ‚îÇ       ‚îÇ               (uint8_t*)best_fit + sizeof(struct heap_block) + size);
    ‚îÇ       ‚îÇ       ‚îÇ           
    ‚îÇ       ‚îÇ       ‚îÇ           size_t new_block_size = best_fit->size - size - sizeof(struct heap_block);
    ‚îÇ       ‚îÇ       ‚îÇ           initialize_block(new_block, new_block_size, 0, false, 0);
    ‚îÇ       ‚îÇ       ‚îÇ           
    ‚îÇ       ‚îÇ       ‚îÇ           new_block->next = best_fit->next;
    ‚îÇ       ‚îÇ       ‚îÇ           new_block->prev = best_fit;
    ‚îÇ       ‚îÇ       ‚îÇ           
    ‚îÇ       ‚îÇ       ‚îÇ           if (best_fit->next != NULL) {
    ‚îÇ       ‚îÇ       ‚îÇ               best_fit->next->prev = new_block;
    ‚îÇ       ‚îÇ       ‚îÇ           }
    ‚îÇ       ‚îÇ       ‚îÇ           
    ‚îÇ       ‚îÇ       ‚îÇ           best_fit->size = size;
    ‚îÇ       ‚îÇ       ‚îÇ           best_fit->next = new_block;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // Mark block as used with protection flags
    ‚îÇ       ‚îÇ       ‚îÇ       best_fit->used = true;
    ‚îÇ       ‚îÇ       ‚îÇ       best_fit->protection_flags = protection_flags;
    ‚îÇ       ‚îÇ       ‚îÇ       best_fit->requested_size = size;
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // Update checksum for the modified block
    ‚îÇ       ‚îÇ       ‚îÇ       best_fit->checksum = 0;
    ‚îÇ       ‚îÇ       ‚îÇ       best_fit->checksum = calculate_checksum(best_fit);
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       kernel_heap.used_size += best_fit->size + sizeof(struct heap_block);
    ‚îÇ       ‚îÇ       ‚îÇ       kernel_heap.alloc_count++;
    ‚îÇ       ‚îÇ       ‚îÇ       kernel_heap.stats.total_allocations++;
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // Apply memory poisoning
    ‚îÇ       ‚îÇ       ‚îÇ       if (poisoning_enabled) {
    ‚îÇ       ‚îÇ       ‚îÇ           memset(best_fit->allocation_ptr, HEAP_ALLOC_POISON, best_fit->size);
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // Verify the allocation
    ‚îÇ       ‚îÇ       ‚îÇ       if (!heap_validate_block(best_fit)) {
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts("[HEAP SECURITY] Allocation created corrupted block!\n");
    ‚îÇ       ‚îÇ       ‚îÇ           kfree(best_fit->allocation_ptr); // Clean up
    ‚îÇ       ‚îÇ       ‚îÇ           return NULL;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       return best_fit->allocation_ptr;
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   // Secure memory deallocation
    ‚îÇ       ‚îÇ       ‚îÇ   void kfree(void* ptr) {
    ‚îÇ       ‚îÇ       ‚îÇ       if (lockdown_mode) {
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts("[HEAP SECURITY] Free operation blocked - system in lockdown!\n");
    ‚îÇ       ‚îÇ       ‚îÇ           return;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       if (ptr == NULL) {
    ‚îÇ       ‚îÇ       ‚îÇ           return;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // Get the block structure
    ‚îÇ       ‚îÇ       ‚îÇ       struct heap_block* block = (struct heap_block*)((uint8_t*)ptr - sizeof(struct heap_block));
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // Validate pointer before proceeding
    ‚îÇ       ‚îÇ       ‚îÇ       if (!heap_is_valid_pointer(ptr)) {
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts("[HEAP SECURITY] Invalid pointer passed to kfree!\n");
    ‚îÇ       ‚îÇ       ‚îÇ           kernel_heap.stats.failed_allocations++;
    ‚îÇ       ‚îÇ       ‚îÇ           return;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // Validate block integrity
    ‚îÇ       ‚îÇ       ‚îÇ       if (!heap_validate_block(block)) {
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts("[HEAP SECURITY] Cannot free corrupted block!\n");
    ‚îÇ       ‚îÇ       ‚îÇ           heap_emergency_lockdown();
    ‚îÇ       ‚îÇ       ‚îÇ           return;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       if (!block->used) {
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts("[HEAP SECURITY] Double free detected!\n");
    ‚îÇ       ‚îÇ       ‚îÇ           kernel_heap.stats.double_free_attempts++;
    ‚îÇ       ‚îÇ       ‚îÇ           heap_emergency_lockdown();
    ‚îÇ       ‚îÇ       ‚îÇ           return;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // Mark as free and update metadata
    ‚îÇ       ‚îÇ       ‚îÇ       block->used = false;
    ‚îÇ       ‚îÇ       ‚îÇ       block->protection_flags = 0;
    ‚îÇ       ‚îÇ       ‚îÇ       kernel_heap.used_size -= block->size + sizeof(struct heap_block);
    ‚îÇ       ‚îÇ       ‚îÇ       kernel_heap.free_count++;
    ‚îÇ       ‚îÇ       ‚îÇ       kernel_heap.stats.total_frees++;
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // Apply free poisoning
    ‚îÇ       ‚îÇ       ‚îÇ       if (poisoning_enabled) {
    ‚îÇ       ‚îÇ       ‚îÇ           memset(block->allocation_ptr, HEAP_FREE_POISON, block->size);
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // Update checksum
    ‚îÇ       ‚îÇ       ‚îÇ       block->checksum = 0;
    ‚îÇ       ‚îÇ       ‚îÇ       block->checksum = calculate_checksum(block);
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // Coalesce with adjacent free blocks
    ‚îÇ       ‚îÇ       ‚îÇ       if (block->prev != NULL && !block->prev->used && heap_validate_block(block->prev)) {
    ‚îÇ       ‚îÇ       ‚îÇ           block->prev->size += block->size + sizeof(struct heap_block);
    ‚îÇ       ‚îÇ       ‚îÇ           block->prev->next = block->next;
    ‚îÇ       ‚îÇ       ‚îÇ           
    ‚îÇ       ‚îÇ       ‚îÇ           if (block->next != NULL) {
    ‚îÇ       ‚îÇ       ‚îÇ               block->next->prev = block->prev;
    ‚îÇ       ‚îÇ       ‚îÇ           }
    ‚îÇ       ‚îÇ       ‚îÇ           
    ‚îÇ       ‚îÇ       ‚îÇ           // Update checksum of merged block
    ‚îÇ       ‚îÇ       ‚îÇ           block->prev->checksum = 0;
    ‚îÇ       ‚îÇ       ‚îÇ           block->prev->checksum = calculate_checksum(block->prev);
    ‚îÇ       ‚îÇ       ‚îÇ           
    ‚îÇ       ‚îÇ       ‚îÇ           block = block->prev;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       if (block->next != NULL && !block->next->used && heap_validate_block(block->next)) {
    ‚îÇ       ‚îÇ       ‚îÇ           block->size += block->next->size + sizeof(struct heap_block);
    ‚îÇ       ‚îÇ       ‚îÇ           block->next = block->next->next;
    ‚îÇ       ‚îÇ       ‚îÇ           
    ‚îÇ       ‚îÇ       ‚îÇ           if (block->next != NULL) {
    ‚îÇ       ‚îÇ       ‚îÇ               block->next->prev = block;
    ‚îÇ       ‚îÇ       ‚îÇ           }
    ‚îÇ       ‚îÇ       ‚îÇ           
    ‚îÇ       ‚îÇ       ‚îÇ           // Update checksum
    ‚îÇ       ‚îÇ       ‚îÇ           block->checksum = 0;
    ‚îÇ       ‚îÇ       ‚îÇ           block->checksum = calculate_checksum(block);
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   // Validate all blocks in the heap
    ‚îÇ       ‚îÇ       ‚îÇ   bool heap_validate_all_blocks(void) {
    ‚îÇ       ‚îÇ       ‚îÇ       struct heap_block* current = kernel_heap.first_block;
    ‚îÇ       ‚îÇ       ‚îÇ       bool all_valid = true;
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       while (current != NULL) {
    ‚îÇ       ‚îÇ       ‚îÇ           if (!heap_validate_block(current)) {
    ‚îÇ       ‚îÇ       ‚îÇ               all_valid = false;
    ‚îÇ       ‚îÇ       ‚îÇ               kernel_heap.corruption_count++;
    ‚îÇ       ‚îÇ       ‚îÇ           }
    ‚îÇ       ‚îÇ       ‚îÇ           current = current->next;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       if (!all_valid) {
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts("[HEAP SECURITY] Heap validation failed!\n");
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       return all_valid;
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   // Check if pointer is valid for this heap
    ‚îÇ       ‚îÇ       ‚îÇ   bool heap_is_valid_pointer(void* ptr) {
    ‚îÇ       ‚îÇ       ‚îÇ       if (ptr == NULL) return false;
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t addr = (uint64_t)ptr;
    ‚îÇ       ‚îÇ       ‚îÇ       if (addr < (uint64_t)kernel_heap.start || addr >= (uint64_t)kernel_heap.end) {
    ‚îÇ       ‚îÇ       ‚îÇ           return false;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // Check if pointer points to a valid allocation area
    ‚îÇ       ‚îÇ       ‚îÇ       struct heap_block* block = (struct heap_block*)((uint8_t*)ptr - sizeof(struct heap_block));
    ‚îÇ       ‚îÇ       ‚îÇ       if ((uint64_t)block < (uint64_t)kernel_heap.start || 
    ‚îÇ       ‚îÇ       ‚îÇ           (uint64_t)block >= (uint64_t)kernel_heap.end) {
    ‚îÇ       ‚îÇ       ‚îÇ           return false;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       return heap_validate_block(block);
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   // Additional security functions...
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   void* kcalloc(size_t num, size_t size) {
    ‚îÇ       ‚îÇ       ‚îÇ       size_t total_size = num * size;
    ‚îÇ       ‚îÇ       ‚îÇ       void* ptr = kmalloc(total_size);
    ‚îÇ       ‚îÇ       ‚îÇ       if (ptr != NULL) {
    ‚îÇ       ‚îÇ       ‚îÇ           memset(ptr, 0, total_size); // Always zero initialized
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       return ptr;
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   void* krealloc(void* ptr, size_t size) {
    ‚îÇ       ‚îÇ       ‚îÇ       if (ptr == NULL) return kmalloc(size);
    ‚îÇ       ‚îÇ       ‚îÇ       if (size == 0) {
    ‚îÇ       ‚îÇ       ‚îÇ           kfree(ptr);
    ‚îÇ       ‚îÇ       ‚îÇ           return NULL;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       if (!heap_is_valid_pointer(ptr)) {
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts("[HEAP SECURITY] Invalid pointer in krealloc!\n");
    ‚îÇ       ‚îÇ       ‚îÇ           return NULL;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       struct heap_block* block = (struct heap_block*)((uint8_t*)ptr - sizeof(struct heap_block));
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       if (size <= block->size) {
    ‚îÇ       ‚îÇ       ‚îÇ           return ptr; // Existing block is large enough
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       void* new_ptr = kmalloc(size);
    ‚îÇ       ‚îÇ       ‚îÇ       if (new_ptr != NULL) {
    ‚îÇ       ‚îÇ       ‚îÇ           memcpy(new_ptr, ptr, block->requested_size);
    ‚îÇ       ‚îÇ       ‚îÇ           kfree(ptr);
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       return new_ptr;
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   // Debug functions
    ‚îÇ       ‚îÇ       ‚îÇ   void heap_dump_blocks(void) {
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts("[HEAP] Heap block dump:\n");
    ‚îÇ       ‚îÇ       ‚îÇ       struct heap_block* current = kernel_heap.first_block;
    ‚îÇ       ‚îÇ       ‚îÇ       size_t block_num = 0;
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       while (current != NULL) {
    ‚îÇ       ‚îÇ       ‚îÇ           printf("  Block %d: addr=0x%x, size=%d, used=%s, checksum=0x%x\n",
    ‚îÇ       ‚îÇ       ‚îÇ                  block_num++, (uint64_t)current, current->size, 
    ‚îÇ       ‚îÇ       ‚îÇ                  current->used ? "yes" : "no", current->checksum);
    ‚îÇ       ‚îÇ       ‚îÇ           current = current->next;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   void heap_print_stats(void) {
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts("[HEAP] Security Statistics:\n");
    ‚îÇ       ‚îÇ       ‚îÇ       printf("  Total allocations: %d\n", kernel_heap.stats.total_allocations);
    ‚îÇ       ‚îÇ       ‚îÇ       printf("  Total frees: %d\n", kernel_heap.stats.total_frees);
    ‚îÇ       ‚îÇ       ‚îÇ       printf("  Failed allocations: %d\n", kernel_heap.stats.failed_allocations);
    ‚îÇ       ‚îÇ       ‚îÇ       printf("  Double free attempts: %d\n", kernel_heap.stats.double_free_attempts);
    ‚îÇ       ‚îÇ       ‚îÇ       printf("  Buffer overflows detected: %d\n", kernel_heap.stats.buffer_overflow_detected);
    ‚îÇ       ‚îÇ       ‚îÇ       printf("  Use-after-free detected: %d\n", kernel_heap.stats.use_after_free_detected);
    ‚îÇ       ‚îÇ       ‚îÇ       printf("  Total corruptions: %d\n", kernel_heap.corruption_count);
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   void heap_enable_poisoning(bool enable) {
    ‚îÇ       ‚îÇ       ‚îÇ       poisoning_enabled = enable;
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts(enable ? 
    ‚îÇ       ‚îÇ       ‚îÇ           "[HEAP] Memory poisoning enabled\n" : 
    ‚îÇ       ‚îÇ       ‚îÇ           "[HEAP] Memory poisoning disabled\n");
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   void heap_enable_guard_pages(bool enable) {
    ‚îÇ       ‚îÇ       ‚îÇ       guard_pages_enabled = enable;
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts(enable ?
    ‚îÇ       ‚îÇ       ‚îÇ           "[HEAP] Guard pages enabled\n" :
    ‚îÇ       ‚îÇ       ‚îÇ           "[HEAP] Guard pages disabled\n");
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   // Utility functions
    ‚îÇ       ‚îÇ       ‚îÇ   size_t heap_get_total_size(void) { return kernel_heap.total_size; }
    ‚îÇ       ‚îÇ       ‚îÇ   size_t heap_get_used_size(void) { return kernel_heap.used_size; }
    ‚îÇ       ‚îÇ       ‚îÇ   size_t heap_get_free_size(void) { return kernel_heap.total_size - kernel_heap.used_size; }
    ‚îÇ       ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ paging.c
    ‚îÇ       ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ       ‚îú‚îÄ‚îÄ CONTENT:
    ‚îÇ       ‚îÇ       ‚îÇ   #include "include/memory/paging.h"
    ‚îÇ       ‚îÇ       ‚îÇ   #include "include/memory/pmm.h"
    ‚îÇ       ‚îÇ       ‚îÇ   #include "include/drivers/serial.h"
    ‚îÇ       ‚îÇ       ‚îÇ   #include "libc/string.h"
    ‚îÇ       ‚îÇ       ‚îÇ   #include "libc/stdio.h"
    ‚îÇ       ‚îÇ       ‚îÇ   #include "include/interrupts/isr.h"
    ‚îÇ       ‚îÇ       ‚îÇ   #include "include/interrupts/idt.h"
    ‚îÇ       ‚îÇ       ‚îÇ   #include <limine.h>
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   static volatile struct limine_hhdm_response *current_hhdm_response = NULL;
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   void paging_init(volatile struct limine_hhdm_response *hhdm_response) {
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts("[PAGING] Initializing paging...\n");
    ‚îÇ       ‚îÇ       ‚îÇ       current_hhdm_response = hhdm_response;
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // –ü—Ä–æ–≤–µ—Ä–∏–º, –≤–∫–ª—é—á–µ–Ω –ª–∏ —É–∂–µ –ø–µ–π–¥–∂–∏–Ω–≥
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t cr0;
    ‚îÇ       ‚îÇ       ‚îÇ       asm volatile("mov %%cr0, %0" : "=r"(cr0));
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t cr4;
    ‚îÇ       ‚îÇ       ‚îÇ       asm volatile("mov %%cr4, %0" : "=r"(cr4));
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts("[PAGING] CR0: 0x");
    ‚îÇ       ‚îÇ       ‚îÇ       char buffer[32];
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts(itoa(cr0, buffer, 16));
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts("\n");
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts("[PAGING] CR4: 0x");
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts(itoa(cr4, buffer, 16));
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts("\n");
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // –ü—Ä–æ–≤–µ—Ä–∏–º –±–∏—Ç PG (Page Enable) –≤ CR0
    ‚îÇ       ‚îÇ       ‚îÇ       if (cr0 & (1UL << 31)) {
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts("[PAGING] Paging is already enabled by bootloader\n");
    ‚îÇ       ‚îÇ       ‚îÇ           
    ‚îÇ       ‚îÇ       ‚îÇ           // –ü–æ–ª—É—á–∏–º —Ç–µ–∫—É—â–∏–π CR3
    ‚îÇ       ‚îÇ       ‚îÇ           uint64_t current_cr3 = paging_get_cr3();
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts("[PAGING] Current CR3: 0x");
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts(itoa(current_cr3, buffer, 16));
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts("\n");
    ‚îÇ       ‚îÇ       ‚îÇ           
    ‚îÇ       ‚îÇ       ‚îÇ           if (current_hhdm_response) {
    ‚îÇ       ‚îÇ       ‚îÇ               serial_puts("[PAGING] HHDM offset: 0x");
    ‚îÇ       ‚îÇ       ‚îÇ               serial_puts(itoa(current_hhdm_response->offset, buffer, 16));
    ‚îÇ       ‚îÇ       ‚îÇ               serial_puts("\n");
    ‚îÇ       ‚îÇ       ‚îÇ               
    ‚îÇ       ‚îÇ       ‚îÇ               // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º CR3 –≤ –≤–∏—Ä—Ç—É–∞–ª—å–Ω—ã–π –∞–¥—Ä–µ—Å —á–µ—Ä–µ–∑ HHDM
    ‚îÇ       ‚îÇ       ‚îÇ               uint64_t cr3_virtual = current_cr3 + current_hhdm_response->offset;
    ‚îÇ       ‚îÇ       ‚îÇ               serial_puts("[PAGING] CR3 virtual address: 0x");
    ‚îÇ       ‚îÇ       ‚îÇ               serial_puts(itoa(cr3_virtual, buffer, 16));
    ‚îÇ       ‚îÇ       ‚îÇ               serial_puts("\n");
    ‚îÇ       ‚îÇ       ‚îÇ           }
    ‚îÇ       ‚îÇ       ‚îÇ           
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts("[PAGING] Using existing page tables from bootloader\n");
    ‚îÇ       ‚îÇ       ‚îÇ           return;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       if (!current_hhdm_response) {
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts("[PAGING] ERROR: No HHDM response!\n");
    ‚îÇ       ‚îÇ       ‚îÇ           return;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts("[PAGING] HHDM offset: 0x");
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts(itoa(current_hhdm_response->offset, buffer, 16));
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts("\n");
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts("[PAGING] Paging setup complete\n");
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   void paging_load_cr3(uint64_t cr3_value) {
    ‚îÇ       ‚îÇ       ‚îÇ       asm volatile("mov %0, %%cr3" :: "r"(cr3_value));
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   uint64_t paging_get_cr3(void) {
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t cr3;
    ‚îÇ       ‚îÇ       ‚îÇ       asm volatile("mov %%cr3, %0" : "=r"(cr3));
    ‚îÇ       ‚îÇ       ‚îÇ       return cr3;
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   void paging_invalidate_tlb(uint64_t virtual_addr) {
    ‚îÇ       ‚îÇ       ‚îÇ       asm volatile("invlpg (%0)" :: "r"(virtual_addr) : "memory");
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   bool paging_map_page(uint64_t virtual_addr, uint64_t physical_addr, uint64_t flags) {
    ‚îÇ       ‚îÇ       ‚îÇ       if (!current_hhdm_response) {
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts("[PAGING] ERROR: No HHDM response for mapping!\n");
    ‚îÇ       ‚îÇ       ‚îÇ           return false;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â—É—é —Ç–∞–±–ª–∏—Ü—É —Å—Ç—Ä–∞–Ω–∏—Ü
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t cr3 = paging_get_cr3();
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t* pml4 = (uint64_t*)(cr3 + current_hhdm_response->offset);
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // –í—ã—á–∏—Å–ª—è–µ–º –∏–Ω–¥–µ–∫—Å—ã –≤ —Ç–∞–±–ª–∏—Ü–∞—Ö —Å—Ç—Ä–∞–Ω–∏—Ü
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t pml4_index = (virtual_addr >> 39) & 0x1FF;
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t pdp_index = (virtual_addr >> 30) & 0x1FF;
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t pd_index = (virtual_addr >> 21) & 0x1FF;
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t pt_index = (virtual_addr >> 12) & 0x1FF;
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // –ü—Ä–æ–≤–µ—Ä—è–µ–º PML4 entry
    ‚îÇ       ‚îÇ       ‚îÇ       if (!(pml4[pml4_index] & PAGING_PRESENT)) {
    ‚îÇ       ‚îÇ       ‚îÇ           // –í—ã–¥–µ–ª—è–µ–º –Ω–æ–≤—É—é PDP —Ç–∞–±–ª–∏—Ü—É
    ‚îÇ       ‚îÇ       ‚îÇ           uint64_t pdp_physical = pmm_alloc_page();
    ‚îÇ       ‚îÇ       ‚îÇ           if (!pdp_physical) {
    ‚îÇ       ‚îÇ       ‚îÇ               serial_puts("[PAGING] ERROR: Failed to allocate PDP table!\n");
    ‚îÇ       ‚îÇ       ‚îÇ               return false;
    ‚îÇ       ‚îÇ       ‚îÇ           }
    ‚îÇ       ‚îÇ       ‚îÇ           
    ‚îÇ       ‚îÇ       ‚îÇ           uint64_t* pdp = (uint64_t*)(pdp_physical + current_hhdm_response->offset);
    ‚îÇ       ‚îÇ       ‚îÇ           memset(pdp, 0, PAGE_SIZE_4K);
    ‚îÇ       ‚îÇ       ‚îÇ           
    ‚îÇ       ‚îÇ       ‚îÇ           // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∑–∞–ø–∏—Å—å –≤ PML4
    ‚îÇ       ‚îÇ       ‚îÇ           pml4[pml4_index] = pdp_physical | PAGING_PRESENT | PAGING_WRITABLE | PAGING_USER;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t* pdp = (uint64_t*)((pml4[pml4_index] & ~0xFFF) + current_hhdm_response->offset);
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // –ü—Ä–æ–≤–µ—Ä—è–µ–º PDP entry
    ‚îÇ       ‚îÇ       ‚îÇ       if (!(pdp[pdp_index] & PAGING_PRESENT)) {
    ‚îÇ       ‚îÇ       ‚îÇ           // –í—ã–¥–µ–ª—è–µ–º –Ω–æ–≤—É—é PD —Ç–∞–±–ª–∏—Ü—É
    ‚îÇ       ‚îÇ       ‚îÇ           uint64_t pd_physical = pmm_alloc_page();
    ‚îÇ       ‚îÇ       ‚îÇ           if (!pd_physical) {
    ‚îÇ       ‚îÇ       ‚îÇ               serial_puts("[PAGING] ERROR: Failed to allocate PD table!\n");
    ‚îÇ       ‚îÇ       ‚îÇ               return false;
    ‚îÇ       ‚îÇ       ‚îÇ           }
    ‚îÇ       ‚îÇ       ‚îÇ           
    ‚îÇ       ‚îÇ       ‚îÇ           uint64_t* pd = (uint64_t*)(pd_physical + current_hhdm_response->offset);
    ‚îÇ       ‚îÇ       ‚îÇ           memset(pd, 0, PAGE_SIZE_4K);
    ‚îÇ       ‚îÇ       ‚îÇ           
    ‚îÇ       ‚îÇ       ‚îÇ           // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∑–∞–ø–∏—Å—å –≤ PDP
    ‚îÇ       ‚îÇ       ‚îÇ           pdp[pdp_index] = pd_physical | PAGING_PRESENT | PAGING_WRITABLE | PAGING_USER;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t* pd = (uint64_t*)((pdp[pdp_index] & ~0xFFF) + current_hhdm_response->offset);
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // –ü—Ä–æ–≤–µ—Ä—è–µ–º PD entry
    ‚îÇ       ‚îÇ       ‚îÇ       if (!(pd[pd_index] & PAGING_PRESENT)) {
    ‚îÇ       ‚îÇ       ‚îÇ           // –í—ã–¥–µ–ª—è–µ–º –Ω–æ–≤—É—é PT —Ç–∞–±–ª–∏—Ü—É
    ‚îÇ       ‚îÇ       ‚îÇ           uint64_t pt_physical = pmm_alloc_page();
    ‚îÇ       ‚îÇ       ‚îÇ           if (!pt_physical) {
    ‚îÇ       ‚îÇ       ‚îÇ               serial_puts("[PAGING] ERROR: Failed to allocate PT table!\n");
    ‚îÇ       ‚îÇ       ‚îÇ               return false;
    ‚îÇ       ‚îÇ       ‚îÇ           }
    ‚îÇ       ‚îÇ       ‚îÇ           
    ‚îÇ       ‚îÇ       ‚îÇ           uint64_t* pt = (uint64_t*)(pt_physical + current_hhdm_response->offset);
    ‚îÇ       ‚îÇ       ‚îÇ           memset(pt, 0, PAGE_SIZE_4K);
    ‚îÇ       ‚îÇ       ‚îÇ           
    ‚îÇ       ‚îÇ       ‚îÇ           // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∑–∞–ø–∏—Å—å –≤ PD
    ‚îÇ       ‚îÇ       ‚îÇ           pd[pd_index] = pt_physical | PAGING_PRESENT | PAGING_WRITABLE | PAGING_USER;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t* pt = (uint64_t*)((pd[pd_index] & ~0xFFF) + current_hhdm_response->offset);
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∑–∞–ø–∏—Å—å –≤ —Ç–∞–±–ª–∏—Ü–µ —Å—Ç—Ä–∞–Ω–∏—Ü
    ‚îÇ       ‚îÇ       ‚îÇ       pt[pt_index] = physical_addr | flags | PAGING_PRESENT;
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // –ò–Ω–≤–∞–ª–∏–¥–∏—Ä—É–µ–º TLB
    ‚îÇ       ‚îÇ       ‚îÇ       paging_invalidate_tlb(virtual_addr);
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       char buffer[64];
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts("[PAGING] Mapped virtual 0x");
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts(itoa(virtual_addr, buffer, 16));
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts(" to physical 0x");
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts(itoa(physical_addr, buffer, 16));
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts("\n");
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       return true;
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   bool paging_unmap_page(uint64_t virtual_addr) {
    ‚îÇ       ‚îÇ       ‚îÇ       if (!current_hhdm_response) {
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts("[PAGING] ERROR: No HHDM response for unmapping!\n");
    ‚îÇ       ‚îÇ       ‚îÇ           return false;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â—É—é —Ç–∞–±–ª–∏—Ü—É —Å—Ç—Ä–∞–Ω–∏—Ü
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t cr3 = paging_get_cr3();
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t* pml4 = (uint64_t*)(cr3 + current_hhdm_response->offset);
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // –í—ã—á–∏—Å–ª—è–µ–º –∏–Ω–¥–µ–∫—Å—ã –≤ —Ç–∞–±–ª–∏—Ü–∞—Ö —Å—Ç—Ä–∞–Ω–∏—Ü
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t pml4_index = (virtual_addr >> 39) & 0x1FF;
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t pdp_index = (virtual_addr >> 30) & 0x1FF;
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t pd_index = (virtual_addr >> 21) & 0x1FF;
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t pt_index = (virtual_addr >> 12) & 0x1FF;
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –≤—Å–µ—Ö —É—Ä–æ–≤–Ω–µ–π —Ç–∞–±–ª–∏—Ü
    ‚îÇ       ‚îÇ       ‚îÇ       if (!(pml4[pml4_index] & PAGING_PRESENT)) {
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts("[PAGING] ERROR: PML4 entry not present!\n");
    ‚îÇ       ‚îÇ       ‚îÇ           return false;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t* pdp = (uint64_t*)((pml4[pml4_index] & ~0xFFF) + current_hhdm_response->offset);
    ‚îÇ       ‚îÇ       ‚îÇ       if (!(pdp[pdp_index] & PAGING_PRESENT)) {
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts("[PAGING] ERROR: PDP entry not present!\n");
    ‚îÇ       ‚îÇ       ‚îÇ           return false;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t* pd = (uint64_t*)((pdp[pdp_index] & ~0xFFF) + current_hhdm_response->offset);
    ‚îÇ       ‚îÇ       ‚îÇ       if (!(pd[pd_index] & PAGING_PRESENT)) {
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts("[PAGING] ERROR: PD entry not present!\n");
    ‚îÇ       ‚îÇ       ‚îÇ           return false;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t* pt = (uint64_t*)((pd[pd_index] & ~0xFFF) + current_hhdm_response->offset);
    ‚îÇ       ‚îÇ       ‚îÇ       if (!(pt[pt_index] & PAGING_PRESENT)) {
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts("[PAGING] ERROR: Page table entry not present!\n");
    ‚îÇ       ‚îÇ       ‚îÇ           return false;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // –û—Å–≤–æ–±–æ–∂–¥–∞–µ–º —Ñ–∏–∑–∏—á–µ—Å–∫—É—é —Å—Ç—Ä–∞–Ω–∏—Ü—É
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t physical_addr = pt[pt_index] & ~0xFFF;
    ‚îÇ       ‚îÇ       ‚îÇ       pmm_free_page(physical_addr);
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // –û—á–∏—â–∞–µ–º –∑–∞–ø–∏—Å—å –≤ —Ç–∞–±–ª–∏—Ü–µ —Å—Ç—Ä–∞–Ω–∏—Ü
    ‚îÇ       ‚îÇ       ‚îÇ       pt[pt_index] = 0;
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // –ò–Ω–≤–∞–ª–∏–¥–∏—Ä—É–µ–º TLB
    ‚îÇ       ‚îÇ       ‚îÇ       paging_invalidate_tlb(virtual_addr);
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       char buffer[64];
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts("[PAGING] Unmapped virtual 0x");
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts(itoa(virtual_addr, buffer, 16));
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts("\n");
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       return true;
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤–∏—Ä—Ç—É–∞–ª—å–Ω–æ–≥–æ –∞–¥—Ä–µ—Å–∞
    ‚îÇ       ‚îÇ       ‚îÇ   bool paging_is_mapped(uint64_t virtual_addr) {
    ‚îÇ       ‚îÇ       ‚îÇ       if (!current_hhdm_response) return false;
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t cr3 = paging_get_cr3();
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t* pml4 = (uint64_t*)(cr3 + current_hhdm_response->offset);
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t pml4_index = (virtual_addr >> 39) & 0x1FF;
    ‚îÇ       ‚îÇ       ‚îÇ       if (!(pml4[pml4_index] & PAGING_PRESENT)) return false;
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t* pdp = (uint64_t*)((pml4[pml4_index] & ~0xFFF) + current_hhdm_response->offset);
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t pdp_index = (virtual_addr >> 30) & 0x1FF;
    ‚îÇ       ‚îÇ       ‚îÇ       if (!(pdp[pdp_index] & PAGING_PRESENT)) return false;
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t* pd = (uint64_t*)((pdp[pdp_index] & ~0xFFF) + current_hhdm_response->offset);
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t pd_index = (virtual_addr >> 21) & 0x1FF;
    ‚îÇ       ‚îÇ       ‚îÇ       if (!(pd[pd_index] & PAGING_PRESENT)) return false;
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t* pt = (uint64_t*)((pd[pd_index] & ~0xFFF) + current_hhdm_response->offset);
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t pt_index = (virtual_addr >> 12) & 0x1FF;
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       return (pt[pt_index] & PAGING_PRESENT) != 0;
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   uint64_t paging_get_physical_address(uint64_t virtual_addr) {
    ‚îÇ       ‚îÇ       ‚îÇ       if (!current_hhdm_response) {
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts("[PAGING_DEBUG] ERROR: No HHDM response!\n");
    ‚îÇ       ‚îÇ       ‚îÇ           return 0;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       char buffer[64];
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts("[PAGING_DEBUG] Looking up virtual: 0x");
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts(itoa(virtual_addr, buffer, 16));
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts("\n");
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // –¢–û–õ–¨–ö–û –¥–ª—è –Ω–∞—Å—Ç–æ—è—â–∏—Ö HHDM –∞–¥—Ä–µ—Å–æ–≤ (–ø—Ä—è–º–æ–µ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ)
    ‚îÇ       ‚îÇ       ‚îÇ       // HHDM –¥–∏–∞–ø–∞–∑–æ–Ω: 0xffff800000000000 - 0xffff87ffffffffff
    ‚îÇ       ‚îÇ       ‚îÇ       if (virtual_addr >= current_hhdm_response->offset && 
    ‚îÇ       ‚îÇ       ‚îÇ           virtual_addr < (current_hhdm_response->offset + 0x8000000000)) {
    ‚îÇ       ‚îÇ       ‚îÇ           uint64_t physical = virtual_addr - current_hhdm_response->offset;
    ‚îÇ       ‚îÇ       ‚îÇ           
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts("[PAGING_DEBUG] HHDM conversion: Virtual 0x");
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts(itoa(virtual_addr, buffer, 16));
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts(" -> Physical 0x");
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts(itoa(physical, buffer, 16));
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts("\n");
    ‚îÇ       ‚îÇ       ‚îÇ           
    ‚îÇ       ‚îÇ       ‚îÇ           return physical;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // –î–ª—è –≤—Å–µ—Ö –æ—Å—Ç–∞–ª—å–Ω—ã—Ö –∞–¥—Ä–µ—Å–æ–≤ (–≤–∫–ª—é—á–∞—è –∞–¥—Ä–µ—Å–∞ —è–¥—Ä–∞) –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ç–∞–±–ª–∏—Ü—ã —Å—Ç—Ä–∞–Ω–∏—Ü
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts("[PAGING_DEBUG] Using page table lookup for: 0x");
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts(itoa(virtual_addr, buffer, 16));
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts("\n");
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t cr3 = paging_get_cr3();
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t* pml4 = (uint64_t*)(cr3 + current_hhdm_response->offset);
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t pml4_index = (virtual_addr >> 39) & 0x1FF;
    ‚îÇ       ‚îÇ       ‚îÇ       if (!(pml4[pml4_index] & PAGING_PRESENT)) {
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts("[PAGING_DEBUG] PML4 entry not present\n");
    ‚îÇ       ‚îÇ       ‚îÇ           return 0;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t* pdp = (uint64_t*)((pml4[pml4_index] & ~0xFFF) + current_hhdm_response->offset);
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t pdp_index = (virtual_addr >> 30) & 0x1FF;
    ‚îÇ       ‚îÇ       ‚îÇ       if (!(pdp[pdp_index] & PAGING_PRESENT)) {
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts("[PAGING_DEBUG] PDP entry not present\n");
    ‚îÇ       ‚îÇ       ‚îÇ           return 0;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t* pd = (uint64_t*)((pdp[pdp_index] & ~0xFFF) + current_hhdm_response->offset);
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t pd_index = (virtual_addr >> 21) & 0x1FF;
    ‚îÇ       ‚îÇ       ‚îÇ       if (!(pd[pd_index] & PAGING_PRESENT)) {
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts("[PAGING_DEBUG] PD entry not present\n");
    ‚îÇ       ‚îÇ       ‚îÇ           return 0;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t* pt = (uint64_t*)((pd[pd_index] & ~0xFFF) + current_hhdm_response->offset);
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t pt_index = (virtual_addr >> 12) & 0x1FF;
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       if (!(pt[pt_index] & PAGING_PRESENT)) {
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts("[PAGING_DEBUG] Page table entry not present\n");
    ‚îÇ       ‚îÇ       ‚îÇ           return 0;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // –ü–æ–ª—É—á–∞–µ–º —Ñ–∏–∑–∏—á–µ—Å–∫–∏–π –∞–¥—Ä–µ—Å –∏–∑ PTE
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t physical = pt[pt_index] & ~0xFFF;
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts("[PAGING_DEBUG] Page table lookup: Virtual 0x");
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts(itoa(virtual_addr, buffer, 16));
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts(" -> PTE: 0x");
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts(itoa(pt[pt_index], buffer, 16));
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts(" -> Physical: 0x");
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts(itoa(physical, buffer, 16));
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts("\n");
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       return physical;
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   void* paging_physical_to_virtual(uint64_t physical_addr) {
    ‚îÇ       ‚îÇ       ‚îÇ       if (!current_hhdm_response) {
    ‚îÇ       ‚îÇ       ‚îÇ           return (void*)physical_addr;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       void* virtual_addr = (void*)(physical_addr + current_hhdm_response->offset);
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // –û—Ç–ª–∞–¥–æ—á–Ω—ã–π –≤—ã–≤–æ–¥
    ‚îÇ       ‚îÇ       ‚îÇ       char buffer[64];
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts("[PAGING_DEBUG] Physical to virtual: Physical 0x");
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts(itoa(physical_addr, buffer, 16));
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts(" -> Virtual 0x");
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts(itoa((uint64_t)virtual_addr, buffer, 16));
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts("\n");
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       return virtual_addr;
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   uint64_t paging_virtual_to_physical(void* virtual_addr) {
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t vaddr = (uint64_t)virtual_addr;
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // –û—Ç–ª–∞–¥–æ—á–Ω—ã–π –≤—ã–≤–æ–¥
    ‚îÇ       ‚îÇ       ‚îÇ       char buffer[64];
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts("[PAGING_DEBUG] Virtual to physical: Virtual 0x");
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts(itoa(vaddr, buffer, 16));
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts("\n");
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // –ï—Å–ª–∏ –∞–¥—Ä–µ—Å —É–∂–µ –≤ HHDM —Ä–µ–≥–∏–æ–Ω–µ, –ø—Ä–æ—Å—Ç–æ –≤—ã—á–∏—Ç–∞–µ–º offset
    ‚îÇ       ‚îÇ       ‚îÇ       if (current_hhdm_response && vaddr >= current_hhdm_response->offset) {
    ‚îÇ       ‚îÇ       ‚îÇ           uint64_t physical = vaddr - current_hhdm_response->offset;
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts("[PAGING_DEBUG] Using HHDM conversion -> Physical 0x");
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts(itoa(physical, buffer, 16));
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts("\n");
    ‚îÇ       ‚îÇ       ‚îÇ           return physical;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // –î–ª—è –æ–±—ã—á–Ω—ã—Ö –≤–∏—Ä—Ç—É–∞–ª—å–Ω—ã—Ö –∞–¥—Ä–µ—Å–æ–≤ –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ç–∞–±–ª–∏—Ü—ã —Å—Ç—Ä–∞–Ω–∏—Ü
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t physical = paging_get_physical_address(vaddr);
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts("[PAGING_DEBUG] Using page table conversion -> Physical 0x");
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts(itoa(physical, buffer, 16));
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts("\n");
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       return physical;
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   void* paging_hhdm_to_virtual(uint64_t physical_addr) {
    ‚îÇ       ‚îÇ       ‚îÇ       return paging_physical_to_virtual(physical_addr);
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   void handle_page_fault(struct registers *regs) {
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t fault_address;
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t error_code = regs->err_code;
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // –ü–æ–ª—É—á–∞–µ–º –∞–¥—Ä–µ—Å —Å–±–æ—è –∏–∑ CR2
    ‚îÇ       ‚îÇ       ‚îÇ       asm volatile("mov %%cr2, %0" : "=r"(fault_address));
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // –í—ã–≤–æ–¥–∏–º –∫—Ä–∞—Å–∏–≤—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –Ω–∞ —ç–∫—Ä–∞–Ω
    ‚îÇ       ‚îÇ       ‚îÇ       printf("\n=== PAGE FAULT DETECTED ===\n");
    ‚îÇ       ‚îÇ       ‚îÇ       printf("Fault Address: 0x%x\n", fault_address);
    ‚îÇ       ‚îÇ       ‚îÇ       printf("Error Code: 0x%x\n", error_code);
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // –î–µ—Ç–∞–ª—å–Ω—ã–π –∞–Ω–∞–ª–∏–∑ –∫–æ–¥–∞ –æ—à–∏–±–∫–∏
    ‚îÇ       ‚îÇ       ‚îÇ       if (error_code & PF_PRESENT) {
    ‚îÇ       ‚îÇ       ‚îÇ           printf("Type: Protection Violation\n");
    ‚îÇ       ‚îÇ       ‚îÇ           if (error_code & PF_WRITE) {
    ‚îÇ       ‚îÇ       ‚îÇ               printf("Operation: Write to read-only page\n");
    ‚îÇ       ‚îÇ       ‚îÇ           } else {
    ‚îÇ       ‚îÇ       ‚îÇ               printf("Operation: Read from protected page\n");
    ‚îÇ       ‚îÇ       ‚îÇ           }
    ‚îÇ       ‚îÇ       ‚îÇ       } else {
    ‚îÇ       ‚îÇ       ‚îÇ           printf("Type: Page Not Present\n");
    ‚îÇ       ‚îÇ       ‚îÇ           printf("Operation: %s\n", (error_code & PF_WRITE) ? "Write" : "Read");
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       printf("Access Mode: %s\n", (error_code & PF_USER) ? "User" : "Kernel");
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // –ü—ã—Ç–∞–µ–º—Å—è –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å —Å–±–æ–π
    ‚îÇ       ‚îÇ       ‚îÇ       if (!(error_code & PF_PRESENT)) {
    ‚îÇ       ‚îÇ       ‚îÇ           // –°—Ç—Ä–∞–Ω–∏—Ü–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç - –ø—Ä–æ–±—É–µ–º –≤—ã–¥–µ–ª–∏—Ç—å
    ‚îÇ       ‚îÇ       ‚îÇ           uint64_t page_base = fault_address & ~0xFFF;
    ‚îÇ       ‚îÇ       ‚îÇ           
    ‚îÇ       ‚îÇ       ‚îÇ           // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –ª–∏ –∞–¥—Ä–µ—Å –≤ –¥–æ–ø—É—Å—Ç–∏–º–æ–º –¥–∏–∞–ø–∞–∑–æ–Ω–µ —è–¥—Ä–∞
    ‚îÇ       ‚îÇ       ‚îÇ           if (fault_address >= KERNEL_VIRTUAL_BASE && fault_address < KERNEL_VIRTUAL_BASE + 0x10000000) {
    ‚îÇ       ‚îÇ       ‚îÇ               printf("Attempting to map kernel page at 0x%x...\n", page_base);
    ‚îÇ       ‚îÇ       ‚îÇ               
    ‚îÇ       ‚îÇ       ‚îÇ               uint64_t physical_page = pmm_alloc_page();
    ‚îÇ       ‚îÇ       ‚îÇ               if (physical_page) {
    ‚îÇ       ‚îÇ       ‚îÇ                   if (paging_map_page(page_base, physical_page, PAGING_PRESENT | PAGING_WRITABLE)) {
    ‚îÇ       ‚îÇ       ‚îÇ                       printf("Successfully mapped page\n");
    ‚îÇ       ‚îÇ       ‚îÇ                       memset((void*)page_base, 0, PAGE_SIZE_4K); // –û—á–∏—â–∞–µ–º —Å—Ç—Ä–∞–Ω–∏—Ü—É
    ‚îÇ       ‚îÇ       ‚îÇ                       printf("Page zero-initialized\n");
    ‚îÇ       ‚îÇ       ‚îÇ                       printf("=== PAGE FAULT RESOLVED ===\n\n");
    ‚îÇ       ‚îÇ       ‚îÇ                       return; // –£—Å–ø–µ—à–Ω–æ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–æ!
    ‚îÇ       ‚îÇ       ‚îÇ                   }
    ‚îÇ       ‚îÇ       ‚îÇ                   pmm_free_page(physical_page);
    ‚îÇ       ‚îÇ       ‚îÇ               }
    ‚îÇ       ‚îÇ       ‚îÇ               printf("Failed to map page\n");
    ‚îÇ       ‚îÇ       ‚îÇ           } else {
    ‚îÇ       ‚îÇ       ‚îÇ               printf("Address outside kernel range\n");
    ‚îÇ       ‚îÇ       ‚îÇ           }
    ‚îÇ       ‚îÇ       ‚îÇ       } else {
    ‚îÇ       ‚îÇ       ‚îÇ           printf("Protection violation - cannot handle automatically\n");
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // –ï—Å–ª–∏ –Ω–µ —Å–º–æ–≥–ª–∏ –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å - –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞
    ‚îÇ       ‚îÇ       ‚îÇ       printf("\n!!! UNRECOVERABLE PAGE FAULT !!!\n");
    ‚îÇ       ‚îÇ       ‚îÇ       printf("System Halted.\n");
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // –ë–µ—Å–∫–æ–Ω–µ—á–Ω—ã–π —Ü–∏–∫–ª
    ‚îÇ       ‚îÇ       ‚îÇ       for(;;) {
    ‚îÇ       ‚îÇ       ‚îÇ           asm volatile("hlt");
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   void handle_double_fault(struct registers *regs) {
    ‚îÇ       ‚îÇ       ‚îÇ       printf("\n!!! DOUBLE FAULT DETECTED !!!\n");
    ‚îÇ       ‚îÇ       ‚îÇ       printf("Error Code: 0x%x\n", regs->err_code);
    ‚îÇ       ‚îÇ       ‚îÇ       printf("This is a critical system error.\n");
    ‚îÇ       ‚îÇ       ‚îÇ       printf("Possible causes:\n");
    ‚îÇ       ‚îÇ       ‚îÇ       printf(" - Stack overflow/corruption\n");
    ‚îÇ       ‚îÇ       ‚îÇ       printf(" - Interrupt handler failure\n"); 
    ‚îÇ       ‚îÇ       ‚îÇ       printf(" - Kernel memory corruption\n");
    ‚îÇ       ‚îÇ       ‚îÇ       printf("System Halted.\n");
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       for(;;) {
    ‚îÇ       ‚îÇ       ‚îÇ           asm volatile("hlt");
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   void handle_general_protection_fault(struct registers *regs) {
    ‚îÇ       ‚îÇ       ‚îÇ       printf("\n!!! GENERAL PROTECTION FAULT !!!\n");
    ‚îÇ       ‚îÇ       ‚îÇ       printf("Error Code: 0x%x\n", regs->err_code);
    ‚îÇ       ‚îÇ       ‚îÇ       printf("Instruction Pointer: 0x%x\n", regs->rip);
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –∫–æ–¥ –æ—à–∏–±–∫–∏
    ‚îÇ       ‚îÇ       ‚îÇ       if (regs->err_code == 0) {
    ‚îÇ       ‚îÇ       ‚îÇ           printf("Type: Null selector reference\n");
    ‚îÇ       ‚îÇ       ‚îÇ       } else {
    ‚îÇ       ‚îÇ       ‚îÇ           printf("Type: Privilege violation or invalid segment access\n");
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –º–æ–∂–Ω–æ –ª–∏ –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å (–¥–ª—è –Ω–µ–∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö GPF)
    ‚îÇ       ‚îÇ       ‚îÇ       if (regs->err_code == 0) {
    ‚îÇ       ‚îÇ       ‚îÇ           printf("Non-critical GPF, attempting to continue...\n");
    ‚îÇ       ‚îÇ       ‚îÇ           return;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       printf("Critical GPF - System Halted.\n");
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       for(;;) {
    ‚îÇ       ‚îÇ       ‚îÇ           asm volatile("hlt");
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   // Secure page mapping with additional checks
    ‚îÇ       ‚îÇ       ‚îÇ   bool paging_map_page_secure(uint64_t virtual_addr, uint64_t physical_addr, 
    ‚îÇ       ‚îÇ       ‚îÇ                              uint64_t flags, bool require_guard_pages) {
    ‚îÇ       ‚îÇ       ‚îÇ       // Validate addresses
    ‚îÇ       ‚îÇ       ‚îÇ       if (virtual_addr == 0 || physical_addr == 0) {
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts("[PAGING SECURITY] Attempt to map NULL address!\n");
    ‚îÇ       ‚îÇ       ‚îÇ           return false;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // Check for kernel space violations
    ‚îÇ       ‚îÇ       ‚îÇ       if ((virtual_addr >= 0xFFFF800000000000 && virtual_addr < 0xFFFF800000000000 + 0x80000000) &&
    ‚îÇ       ‚îÇ       ‚îÇ           !(flags & PAGING_USER)) {
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts("[PAGING SECURITY] User mapping in kernel space!\n");
    ‚îÇ       ‚îÇ       ‚îÇ           return false;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // Add guard pages if requested
    ‚îÇ       ‚îÇ       ‚îÇ       if (require_guard_pages) {
    ‚îÇ       ‚îÇ       ‚îÇ           // Map previous page as guard
    ‚îÇ       ‚îÇ       ‚îÇ           uint64_t guard_addr = virtual_addr - PAGE_SIZE_4K;
    ‚îÇ       ‚îÇ       ‚îÇ           if (!paging_map_page(guard_addr, pmm_alloc_page(), PAGING_NO_EXECUTE)) {
    ‚îÇ       ‚îÇ       ‚îÇ               serial_puts("[PAGING SECURITY] Failed to create guard page!\n");
    ‚îÇ       ‚îÇ       ‚îÇ               return false;
    ‚îÇ       ‚îÇ       ‚îÇ           }
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       return paging_map_page(virtual_addr, physical_addr, flags);
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   // Validate page table integrity
    ‚îÇ       ‚îÇ       ‚îÇ   bool paging_validate_integrity(void) {
    ‚îÇ       ‚îÇ       ‚îÇ       if (!current_hhdm_response) return false;
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t cr3 = paging_get_cr3();
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t* pml4 = (uint64_t*)(cr3 + current_hhdm_response->offset);
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // Check PML4 self-reference
    ‚îÇ       ‚îÇ       ‚îÇ       if ((pml4[511] & PAGING_PRESENT) == 0) {
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts("[PAGING SECURITY] PML4 self-reference missing!\n");
    ‚îÇ       ‚îÇ       ‚îÇ           return false;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // Basic sanity checks on kernel mappings
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t kernel_base = 0xFFFFFFFF80000000;
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t pml4_index = (kernel_base >> 39) & 0x1FF;
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       if ((pml4[pml4_index] & PAGING_PRESENT) == 0) {
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts("[PAGING SECURITY] Kernel space not mapped!\n");
    ‚îÇ       ‚îÇ       ‚îÇ           return false;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       return true;
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ pmm.c
    ‚îÇ       ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ       ‚îú‚îÄ‚îÄ CONTENT:
    ‚îÇ       ‚îÇ       ‚îÇ   #include "include/memory/pmm.h"
    ‚îÇ       ‚îÇ       ‚îÇ   #include "include/memory/paging.h"
    ‚îÇ       ‚îÇ       ‚îÇ   #include "include/drivers/serial.h"
    ‚îÇ       ‚îÇ       ‚îÇ   #include "libc/string.h"
    ‚îÇ       ‚îÇ       ‚îÇ   #include "libc/stdio.h"
    ‚îÇ       ‚îÇ       ‚îÇ   #include <limine.h>
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   // –°–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å —Å —Ä–∞–∑–Ω—ã–º–∏ –≤–µ—Ä—Å–∏—è–º–∏ Limine
    ‚îÇ       ‚îÇ       ‚îÇ   #ifndef LIMINE_MEMMAP_EXECUTABLE_AND_MODULES
    ‚îÇ       ‚îÇ       ‚îÇ       #ifdef LIMINE_MEMMAP_KERNEL_AND_MODULES
    ‚îÇ       ‚îÇ       ‚îÇ           #define LIMINE_MEMMAP_EXECUTABLE_AND_MODULES LIMINE_MEMMAP_KERNEL_AND_MODULES
    ‚îÇ       ‚îÇ       ‚îÇ       #else
    ‚îÇ       ‚îÇ       ‚îÇ           #define LIMINE_MEMMAP_EXECUTABLE_AND_MODULES 10  // –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
    ‚îÇ       ‚îÇ       ‚îÇ       #endif
    ‚îÇ       ‚îÇ       ‚îÇ   #endif
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   static volatile struct limine_memmap_response *current_memmap_response = NULL;
    ‚îÇ       ‚îÇ       ‚îÇ   static volatile struct limine_hhdm_response *current_hhdm_response = NULL;
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   // Bitmap for tracking physical pages
    ‚îÇ       ‚îÇ       ‚îÇ   static uint8_t* bitmap = NULL;
    ‚îÇ       ‚îÇ       ‚îÇ   static uint64_t bitmap_size = 0;
    ‚îÇ       ‚îÇ       ‚îÇ   static uint64_t total_pages = 0;
    ‚îÇ       ‚îÇ       ‚îÇ   static uint64_t used_pages = 0;
    ‚îÇ       ‚îÇ       ‚îÇ   static uint64_t total_memory = 0;
    ‚îÇ       ‚îÇ       ‚îÇ   static uint64_t bitmap_pages = 0;
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   // Helper functions
    ‚îÇ       ‚îÇ       ‚îÇ   static void bitmap_set(uint64_t bit) {
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t byte = bit / 8;
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t offset = bit % 8;
    ‚îÇ       ‚îÇ       ‚îÇ       bitmap[byte] |= (1 << offset);
    ‚îÇ       ‚îÇ       ‚îÇ       used_pages++;
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   static void bitmap_clear(uint64_t bit) {
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t byte = bit / 8;
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t offset = bit % 8;
    ‚îÇ       ‚îÇ       ‚îÇ       bitmap[byte] &= ~(1 << offset);
    ‚îÇ       ‚îÇ       ‚îÇ       used_pages--;
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   static bool bitmap_test(uint64_t bit) {
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t byte = bit / 8;
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t offset = bit % 8;
    ‚îÇ       ‚îÇ       ‚îÇ       return (bitmap[byte] & (1 << offset)) != 0;
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   static uint64_t find_free_page(void) {
    ‚îÇ       ‚îÇ       ‚îÇ       if (!current_memmap_response) {
    ‚îÇ       ‚îÇ       ‚îÇ           return (uint64_t)-1;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ       // –ù–∞—á–∏–Ω–∞–µ–º –ø–æ–∏—Å–∫ —Å –ø–µ—Ä–≤–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü—ã, –ø—Ä–æ–ø—É—Å–∫–∞—è –Ω—É–ª–µ–≤—É—é
    ‚îÇ       ‚îÇ       ‚îÇ       for (uint64_t i = 1; i < total_pages; i++) {
    ‚îÇ       ‚îÇ       ‚îÇ           if (!bitmap_test(i)) {
    ‚îÇ       ‚îÇ       ‚îÇ               // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Å—Ç—Ä–∞–Ω–∏—Ü–∞ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ –¥–æ—Å—Ç—É–ø–Ω–∞
    ‚îÇ       ‚îÇ       ‚îÇ               bool in_usable_region = false;
    ‚îÇ       ‚îÇ       ‚îÇ               for (uint64_t j = 0; j < current_memmap_response->entry_count; j++) {
    ‚îÇ       ‚îÇ       ‚îÇ                   struct limine_memmap_entry* entry = current_memmap_response->entries[j];
    ‚îÇ       ‚îÇ       ‚îÇ                   if (entry->type == LIMINE_MEMMAP_USABLE) {
    ‚îÇ       ‚îÇ       ‚îÇ                       uint64_t page_addr = i * PAGE_SIZE_4K;
    ‚îÇ       ‚îÇ       ‚îÇ                       if (page_addr >= entry->base && page_addr < entry->base + entry->length) {
    ‚îÇ       ‚îÇ       ‚îÇ                           in_usable_region = true;
    ‚îÇ       ‚îÇ       ‚îÇ                           break;
    ‚îÇ       ‚îÇ       ‚îÇ                       }
    ‚îÇ       ‚îÇ       ‚îÇ                   }
    ‚îÇ       ‚îÇ       ‚îÇ               }
    ‚îÇ       ‚îÇ       ‚îÇ               
    ‚îÇ       ‚îÇ       ‚îÇ               if (in_usable_region) {
    ‚îÇ       ‚îÇ       ‚îÇ                   return i;
    ‚îÇ       ‚îÇ       ‚îÇ               }
    ‚îÇ       ‚îÇ       ‚îÇ           }
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       return (uint64_t)-1;
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   void pmm_init(volatile struct limine_memmap_response *memmap_response,
    ‚îÇ       ‚îÇ       ‚îÇ                 volatile struct limine_hhdm_response *hhdm_response) {
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts("[PMM] Initializing Physical Memory Manager...\n");
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // –°–æ—Ö—Ä–∞–Ω—è–µ–º —É–∫–∞–∑–∞—Ç–µ–ª–∏ –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤ –¥—Ä—É–≥–∏—Ö —Ñ—É–Ω–∫—Ü–∏—è—Ö
    ‚îÇ       ‚îÇ       ‚îÇ       current_memmap_response = memmap_response;
    ‚îÇ       ‚îÇ       ‚îÇ       current_hhdm_response = hhdm_response;
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       if (!current_memmap_response) {
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts("[PMM] ERROR: No memory map response!\n");
    ‚îÇ       ‚îÇ       ‚îÇ           return;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       if (!current_hhdm_response) {
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts("[PMM] ERROR: No HHDM response!\n");
    ‚îÇ       ‚îÇ       ‚îÇ           return;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // Calculate total memory and find largest usable region for bitmap
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t highest_address = 0;
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t largest_region_size = 0;
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t largest_region_base = 0;
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts("[PMM] Memory map entries:\n");
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       for (uint64_t i = 0; i < current_memmap_response->entry_count; i++) {
    ‚îÇ       ‚îÇ       ‚îÇ           struct limine_memmap_entry* entry = current_memmap_response->entries[i];
    ‚îÇ       ‚îÇ       ‚îÇ           
    ‚îÇ       ‚îÇ       ‚îÇ           char type_str[32];
    ‚îÇ       ‚îÇ       ‚îÇ           switch (entry->type) {
    ‚îÇ       ‚îÇ       ‚îÇ               case LIMINE_MEMMAP_USABLE:
    ‚îÇ       ‚îÇ       ‚îÇ                   strcpy(type_str, "USABLE");
    ‚îÇ       ‚îÇ       ‚îÇ                   break;
    ‚îÇ       ‚îÇ       ‚îÇ               case LIMINE_MEMMAP_RESERVED:
    ‚îÇ       ‚îÇ       ‚îÇ                   strcpy(type_str, "RESERVED");
    ‚îÇ       ‚îÇ       ‚îÇ                   break;
    ‚îÇ       ‚îÇ       ‚îÇ               case LIMINE_MEMMAP_ACPI_RECLAIMABLE:
    ‚îÇ       ‚îÇ       ‚îÇ                   strcpy(type_str, "ACPI_RECLAIMABLE");
    ‚îÇ       ‚îÇ       ‚îÇ                   break;
    ‚îÇ       ‚îÇ       ‚îÇ               case LIMINE_MEMMAP_ACPI_NVS:
    ‚îÇ       ‚îÇ       ‚îÇ                   strcpy(type_str, "ACPI_NVS");
    ‚îÇ       ‚îÇ       ‚îÇ                   break;
    ‚îÇ       ‚îÇ       ‚îÇ               case LIMINE_MEMMAP_BAD_MEMORY:
    ‚îÇ       ‚îÇ       ‚îÇ                   strcpy(type_str, "BAD_MEMORY");
    ‚îÇ       ‚îÇ       ‚îÇ                   break;
    ‚îÇ       ‚îÇ       ‚îÇ               case LIMINE_MEMMAP_BOOTLOADER_RECLAIMABLE:
    ‚îÇ       ‚îÇ       ‚îÇ                   strcpy(type_str, "BOOTLOADER_RECLAIM");
    ‚îÇ       ‚îÇ       ‚îÇ                   break;
    ‚îÇ       ‚îÇ       ‚îÇ               case LIMINE_MEMMAP_EXECUTABLE_AND_MODULES:
    ‚îÇ       ‚îÇ       ‚îÇ                   strcpy(type_str, "KERNEL");
    ‚îÇ       ‚îÇ       ‚îÇ                   break;
    ‚îÇ       ‚îÇ       ‚îÇ               case LIMINE_MEMMAP_FRAMEBUFFER:
    ‚îÇ       ‚îÇ       ‚îÇ                   strcpy(type_str, "FRAMEBUFFER");
    ‚îÇ       ‚îÇ       ‚îÇ                   break;
    ‚îÇ       ‚îÇ       ‚îÇ               default:
    ‚îÇ       ‚îÇ       ‚îÇ                   strcpy(type_str, "UNKNOWN");
    ‚îÇ       ‚îÇ       ‚îÇ                   break;
    ‚îÇ       ‚îÇ       ‚îÇ           }
    ‚îÇ       ‚îÇ       ‚îÇ           
    ‚îÇ       ‚îÇ       ‚îÇ           char buffer[64];
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts("  [");
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts(itoa(i, buffer, 10));
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts("] Base: 0x");
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts(itoa(entry->base, buffer, 16));
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts(", Length: 0x");
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts(itoa(entry->length, buffer, 16));
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts(", Type: ");
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts(type_str);
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts("\n");
    ‚îÇ       ‚îÇ       ‚îÇ           
    ‚îÇ       ‚îÇ       ‚îÇ           total_memory += entry->length;
    ‚îÇ       ‚îÇ       ‚îÇ           
    ‚îÇ       ‚îÇ       ‚îÇ           if (entry->type == LIMINE_MEMMAP_USABLE) {
    ‚îÇ       ‚îÇ       ‚îÇ               uint64_t end = entry->base + entry->length;
    ‚îÇ       ‚îÇ       ‚îÇ               if (end > highest_address) {
    ‚îÇ       ‚îÇ       ‚îÇ                   highest_address = end;
    ‚îÇ       ‚îÇ       ‚îÇ               }
    ‚îÇ       ‚îÇ       ‚îÇ               
    ‚îÇ       ‚îÇ       ‚îÇ               // Find largest usable region for bitmap
    ‚îÇ       ‚îÇ       ‚îÇ               if (entry->length > largest_region_size) {
    ‚îÇ       ‚îÇ       ‚îÇ                   largest_region_size = entry->length;
    ‚îÇ       ‚îÇ       ‚îÇ                   largest_region_base = entry->base;
    ‚îÇ       ‚îÇ       ‚îÇ               }
    ‚îÇ       ‚îÇ       ‚îÇ           }
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // Calculate total pages (4KB each)
    ‚îÇ       ‚îÇ       ‚îÇ       total_pages = highest_address / PAGE_SIZE_4K;
    ‚îÇ       ‚îÇ       ‚îÇ       bitmap_size = (total_pages + 7) / 8; // Round up to nearest byte
    ‚îÇ       ‚îÇ       ‚îÇ       bitmap_pages = (bitmap_size + PAGE_SIZE_4K - 1) / PAGE_SIZE_4K;
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts("[PMM] Total memory: ");
    ‚îÇ       ‚îÇ       ‚îÇ       char buffer[32];
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts(itoa(total_memory / 1024 / 1024, buffer, 10));
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts(" MB\n");
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts("[PMM] Total pages: ");
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts(itoa(total_pages, buffer, 10));
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts(" (");
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts(itoa(total_pages * PAGE_SIZE_4K / 1024 / 1024, buffer, 10));
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts(" MB)\n");
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts("[PMM] Bitmap size: ");
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts(itoa(bitmap_size, buffer, 10));
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts(" bytes (");
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts(itoa(bitmap_pages, buffer, 10));
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts(" pages)\n");
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // Find a location for the bitmap in the largest usable region
    ‚îÇ       ‚îÇ       ‚îÇ       if (largest_region_base == 0 || largest_region_size < bitmap_size) {
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts("[PMM] ERROR: No suitable region for bitmap!\n");
    ‚îÇ       ‚îÇ       ‚îÇ           return;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // Place bitmap at the beginning of the largest region
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t bitmap_physical = largest_region_base;
    ‚îÇ       ‚îÇ       ‚îÇ       bitmap = (uint8_t*)(bitmap_physical + current_hhdm_response->offset);
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // Initialize bitmap (all pages are free initially)
    ‚îÇ       ‚îÇ       ‚îÇ       memset(bitmap, 0, bitmap_size);
    ‚îÇ       ‚îÇ       ‚îÇ       used_pages = 0;
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts("[PMM] Bitmap placed at physical: 0x");
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts(itoa(bitmap_physical, buffer, 16));
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts(", virtual: 0x");
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts(itoa((uint64_t)bitmap, buffer, 16));
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts("\n");
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // Mark all non-usable memory as used
    ‚îÇ       ‚îÇ       ‚îÇ       for (uint64_t i = 0; i < current_memmap_response->entry_count; i++) {
    ‚îÇ       ‚îÇ       ‚îÇ           struct limine_memmap_entry* entry = current_memmap_response->entries[i];
    ‚îÇ       ‚îÇ       ‚îÇ           
    ‚îÇ       ‚îÇ       ‚îÇ           if (entry->type != LIMINE_MEMMAP_USABLE) {
    ‚îÇ       ‚îÇ       ‚îÇ               // Mark this region as used in bitmap
    ‚îÇ       ‚îÇ       ‚îÇ               uint64_t start_page = entry->base / PAGE_SIZE_4K;
    ‚îÇ       ‚îÇ       ‚îÇ               uint64_t end_page = (entry->base + entry->length + PAGE_SIZE_4K - 1) / PAGE_SIZE_4K;
    ‚îÇ       ‚îÇ       ‚îÇ               
    ‚îÇ       ‚îÇ       ‚îÇ               for (uint64_t page = start_page; page < end_page; page++) {
    ‚îÇ       ‚îÇ       ‚îÇ                   if (page < total_pages) {
    ‚îÇ       ‚îÇ       ‚îÇ                       bitmap_set(page);
    ‚îÇ       ‚îÇ       ‚îÇ                   }
    ‚îÇ       ‚îÇ       ‚îÇ               }
    ‚îÇ       ‚îÇ       ‚îÇ           }
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // Mark the bitmap region itself as used
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t bitmap_start_page = bitmap_physical / PAGE_SIZE_4K;
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t bitmap_end_page = (bitmap_physical + bitmap_size + PAGE_SIZE_4K - 1) / PAGE_SIZE_4K;
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       for (uint64_t page = bitmap_start_page; page < bitmap_end_page; page++) {
    ‚îÇ       ‚îÇ       ‚îÇ           if (page < total_pages) {
    ‚îÇ       ‚îÇ       ‚îÇ               bitmap_set(page);
    ‚îÇ       ‚îÇ       ‚îÇ           }
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts("[PMM] Initial memory state: ");
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts(itoa(used_pages, buffer, 10));
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts(" pages used, ");
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts(itoa(total_pages - used_pages, buffer, 10));
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts(" pages free\n");
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts("[PMM] Physical Memory Manager initialized successfully\n");
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   uint64_t pmm_alloc_page(void) {
    ‚îÇ       ‚îÇ       ‚îÇ       if (!bitmap) {
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts("[PMM] ERROR: PMM not initialized!\n");
    ‚îÇ       ‚îÇ       ‚îÇ           return 0;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t page = find_free_page();
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       if (page == (uint64_t)-1) {
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts("[PMM] ERROR: Out of physical memory!\n");
    ‚îÇ       ‚îÇ       ‚îÇ           return 0;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       bitmap_set(page);
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       char buffer[32];
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts("[PMM] Allocated page: 0x");
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts(itoa(page * PAGE_SIZE_4K, buffer, 16));
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts(" (");
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts(itoa(page, buffer, 10));
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts(")\n");
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       return page * PAGE_SIZE_4K;
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   void pmm_free_page(uint64_t physical_addr) {
    ‚îÇ       ‚îÇ       ‚îÇ       if (!bitmap) {
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts("[PMM] ERROR: PMM not initialized!\n");
    ‚îÇ       ‚îÇ       ‚îÇ           return;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t page = physical_addr / PAGE_SIZE_4K;
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       if (page >= total_pages) {
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts("[PMM] ERROR: Attempt to free invalid page!\n");
    ‚îÇ       ‚îÇ       ‚îÇ           return;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       if (!bitmap_test(page)) {
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts("[PMM] WARNING: Page already free!\n");
    ‚îÇ       ‚îÇ       ‚îÇ           return;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       bitmap_clear(page);
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       char buffer[32];
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts("[PMM] Freed page: 0x");
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts(itoa(physical_addr, buffer, 16));
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts(" (");
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts(itoa(page, buffer, 10));
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts(")\n");
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   uint64_t pmm_get_free_memory(void) {
    ‚îÇ       ‚îÇ       ‚îÇ       return (total_pages - used_pages) * PAGE_SIZE_4K;
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   uint64_t pmm_get_used_memory(void) {
    ‚îÇ       ‚îÇ       ‚îÇ       return used_pages * PAGE_SIZE_4K;
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   uint64_t pmm_get_total_memory(void) {
    ‚îÇ       ‚îÇ       ‚îÇ       return total_pages * PAGE_SIZE_4K;
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   void pmm_dump_memory_map(void) {
    ‚îÇ       ‚îÇ       ‚îÇ       if (!current_memmap_response) {
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts("[PMM] ERROR: No memory map available!\n");
    ‚îÇ       ‚îÇ       ‚îÇ           return;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts("[PMM] Memory Map Dump:\n");
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       char buffer[64];
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t total_usable = 0;
    ‚îÇ       ‚îÇ       ‚îÇ       uint64_t total_reserved = 0;
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       for (uint64_t i = 0; i < current_memmap_response->entry_count; i++) {
    ‚îÇ       ‚îÇ       ‚îÇ           struct limine_memmap_entry* entry = current_memmap_response->entries[i];
    ‚îÇ       ‚îÇ       ‚îÇ           
    ‚îÇ       ‚îÇ       ‚îÇ           char type_str[32];
    ‚îÇ       ‚îÇ       ‚îÇ           switch (entry->type) {
    ‚îÇ       ‚îÇ       ‚îÇ               case LIMINE_MEMMAP_USABLE: 
    ‚îÇ       ‚îÇ       ‚îÇ                   strcpy(type_str, "USABLE"); 
    ‚îÇ       ‚îÇ       ‚îÇ                   total_usable += entry->length;
    ‚îÇ       ‚îÇ       ‚îÇ                   break;
    ‚îÇ       ‚îÇ       ‚îÇ               case LIMINE_MEMMAP_RESERVED: 
    ‚îÇ       ‚îÇ       ‚îÇ                   strcpy(type_str, "RESERVED"); 
    ‚îÇ       ‚îÇ       ‚îÇ                   total_reserved += entry->length;
    ‚îÇ       ‚îÇ       ‚îÇ                   break;
    ‚îÇ       ‚îÇ       ‚îÇ               case LIMINE_MEMMAP_ACPI_RECLAIMABLE: strcpy(type_str, "ACPI_RECLAIM"); break;
    ‚îÇ       ‚îÇ       ‚îÇ               case LIMINE_MEMMAP_ACPI_NVS: strcpy(type_str, "ACPI_NVS"); break;
    ‚îÇ       ‚îÇ       ‚îÇ               case LIMINE_MEMMAP_BAD_MEMORY: strcpy(type_str, "BAD"); break;
    ‚îÇ       ‚îÇ       ‚îÇ               case LIMINE_MEMMAP_BOOTLOADER_RECLAIMABLE: strcpy(type_str, "BOOTLOADER"); break;
    ‚îÇ       ‚îÇ       ‚îÇ               case LIMINE_MEMMAP_EXECUTABLE_AND_MODULES: strcpy(type_str, "KERNEL"); break;
    ‚îÇ       ‚îÇ       ‚îÇ               case LIMINE_MEMMAP_FRAMEBUFFER: strcpy(type_str, "FRAMEBUFFER"); break;
    ‚îÇ       ‚îÇ       ‚îÇ               default: strcpy(type_str, "UNKNOWN"); break;
    ‚îÇ       ‚îÇ       ‚îÇ           }
    ‚îÇ       ‚îÇ       ‚îÇ           
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts("  ");
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts(type_str);
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts(": 0x");
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts(itoa(entry->base, buffer, 16));
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts(" - 0x");
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts(itoa(entry->base + entry->length - 1, buffer, 16));
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts(" (");
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts(itoa(entry->length / 1024 / 1024, buffer, 10));
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts(" MB)\n");
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // –í—ã–≤–æ–¥ —Å—É–º–º–∞—Ä–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts("[PMM] Summary: ");
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts(itoa(total_usable / 1024 / 1024, buffer, 10));
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts(" MB usable, ");
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts(itoa(total_reserved / 1024 / 1024, buffer, 10));
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts(" MB reserved\n");
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       // –¢–æ—á–Ω–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ PMM
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts("[PMM] PMM Stats: ");
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts(itoa(pmm_get_free_memory() / 1024 / 1024, buffer, 10));
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts(" MB free, ");
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts(itoa(pmm_get_used_memory() / 1024, buffer, 10));
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts(" KB used, ");
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts(itoa(total_pages, buffer, 10));
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts(" total pages\n");
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ security.c
    ‚îÇ       ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ       ‚îú‚îÄ‚îÄ CONTENT:
    ‚îÇ       ‚îÇ       ‚îÇ   #include "include/memory/security.h"
    ‚îÇ       ‚îÇ       ‚îÇ   #include "include/memory/heap.h"
    ‚îÇ       ‚îÇ       ‚îÇ   #include "include/memory/paging.h"
    ‚îÇ       ‚îÇ       ‚îÇ   #include "include/drivers/serial.h"
    ‚îÇ       ‚îÇ       ‚îÇ   #include "libc/string.h"
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   static uint64_t stack_canary = 0;
    ‚îÇ       ‚îÇ       ‚îÇ   static bool security_initialized = false;
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   // Initialize memory security subsystem
    ‚îÇ       ‚îÇ       ‚îÇ   void memory_security_init(void) {
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts("[SECURITY] Initializing memory security subsystem...\n");
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       stack_protector_init();
    ‚îÇ       ‚îÇ       ‚îÇ       heap_enable_poisoning(true);
    ‚îÇ       ‚îÇ       ‚îÇ       heap_enable_guard_pages(true);
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       security_initialized = true;
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts("[SECURITY] Memory security initialized\n");
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   // Generate random stack canary
    ‚îÇ       ‚îÇ       ‚îÇ   uint64_t generate_stack_canary(void) {
    ‚îÇ       ‚îÇ       ‚îÇ       // Simple PRNG for demonstration - replace with hardware RNG if available
    ‚îÇ       ‚îÇ       ‚îÇ       static uint64_t seed = 0x123456789ABCDEF0;
    ‚îÇ       ‚îÇ       ‚îÇ       seed = (seed * 6364136223846793005ULL) + 1;
    ‚îÇ       ‚îÇ       ‚îÇ       return seed ^ 0xDEADBEEFCAFEBABE;
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   void stack_protector_init(void) {
    ‚îÇ       ‚îÇ       ‚îÇ       stack_canary = generate_stack_canary();
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts("[SECURITY] Stack protector initialized\n");
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   bool stack_protector_check(void) {
    ‚îÇ       ‚îÇ       ‚îÇ       // This would be called from exception handlers
    ‚îÇ       ‚îÇ       ‚îÇ       // For now, just return true - real implementation would check canary
    ‚îÇ       ‚îÇ       ‚îÇ       return true;
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   // Comprehensive memory security check
    ‚îÇ       ‚îÇ       ‚îÇ   void memory_security_check(void) {
    ‚îÇ       ‚îÇ       ‚îÇ       if (!security_initialized) {
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts("[SECURITY] Security subsystem not initialized!\n");
    ‚îÇ       ‚îÇ       ‚îÇ           return;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       serial_puts("[SECURITY] Performing memory security audit...\n");
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       bool heap_ok = heap_validate_all_blocks();
    ‚îÇ       ‚îÇ       ‚îÇ       bool stack_ok = stack_protector_check();
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       if (!heap_ok) {
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts("[SECURITY] CRITICAL: Heap integrity check failed!\n");
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       if (!stack_ok) {
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts("[SECURITY] CRITICAL: Stack corruption detected!\n");
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       if (heap_ok && stack_ok) {
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts("[SECURITY] Memory security audit passed\n");
    ‚îÇ       ‚îÇ       ‚îÇ       } else {
    ‚îÇ       ‚îÇ       ‚îÇ           serial_puts("[SECURITY] Memory security audit FAILED!\n");
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   // Secure memory zeroing that won't be optimized away
    ‚îÇ       ‚îÇ       ‚îÇ   void secure_memzero(void* ptr, size_t size) {
    ‚îÇ       ‚îÇ       ‚îÇ       if (ptr == NULL || size == 0) return;
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       volatile uint8_t* p = (volatile uint8_t*)ptr;
    ‚îÇ       ‚îÇ       ‚îÇ       while (size--) {
    ‚îÇ       ‚îÇ       ‚îÇ           *p++ = 0;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ   
    ‚îÇ       ‚îÇ       ‚îÇ   // Secure memset that won't be optimized away
    ‚îÇ       ‚îÇ       ‚îÇ   void secure_memset(void* ptr, int value, size_t size) {
    ‚îÇ       ‚îÇ       ‚îÇ       if (ptr == NULL || size == 0) return;
    ‚îÇ       ‚îÇ       ‚îÇ       
    ‚îÇ       ‚îÇ       ‚îÇ       volatile uint8_t* p = (volatile uint8_t*)ptr;
    ‚îÇ       ‚îÇ       ‚îÇ       while (size--) {
    ‚îÇ       ‚îÇ       ‚îÇ           *p++ = (uint8_t)value;
    ‚îÇ       ‚îÇ       ‚îÇ       }
    ‚îÇ       ‚îÇ       ‚îÇ   }
    ‚îÇ       ‚îÇ       ‚îÇ
    ‚îÇ       ‚îú‚îÄ‚îÄ simd
    ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ simd.c
    ‚îÇ       ‚îÇ       ‚îÇ
    ‚îÇ       ‚îÇ       ‚îú‚îÄ‚îÄ CONTENT:
    ‚îÇ       ‚îÇ       ‚îÇ   <empty>
    ‚îÇ       ‚îÇ       ‚îÇ
    ‚îÇ       ‚îî‚îÄ‚îÄ sys
    ‚îÇ           ‚îú‚îÄ‚îÄ gdt.c
    ‚îÇ               ‚îÇ
    ‚îÇ               ‚îú‚îÄ‚îÄ CONTENT:
    ‚îÇ               ‚îÇ   #include "include/sys/gdt.h"
    ‚îÇ               ‚îÇ   #include "include/drivers/serial.h"
    ‚îÇ               ‚îÇ   #include <stddef.h>
    ‚îÇ               ‚îÇ   
    ‚îÇ               ‚îÇ   // GDT —Ç–∞–±–ª–∏—Ü–∞ (8 –∑–∞–ø–∏—Å–µ–π)
    ‚îÇ               ‚îÇ   static struct gdt_entry gdt[8] = {0};
    ‚îÇ               ‚îÇ   static struct gdt_ptr gdtp;
    ‚îÇ               ‚îÇ   
    ‚îÇ               ‚îÇ   // –í–Ω–µ—à–Ω—è—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ GDT
    ‚îÇ               ‚îÇ   extern void gdt_flush(uint64_t gdt_ptr);
    ‚îÇ               ‚îÇ   
    ‚îÇ               ‚îÇ   static void gdt_set_entry(int index, uint32_t base, uint32_t limit, uint8_t access, uint8_t granularity) {
    ‚îÇ               ‚îÇ       gdt[index].limit_low = limit & 0xFFFF;
    ‚îÇ               ‚îÇ       gdt[index].base_low = base & 0xFFFF;
    ‚îÇ               ‚îÇ       gdt[index].base_middle = (base >> 16) & 0xFF;
    ‚îÇ               ‚îÇ       gdt[index].access = access;
    ‚îÇ               ‚îÇ       gdt[index].granularity = (limit >> 16) & 0x0F;
    ‚îÇ               ‚îÇ       gdt[index].granularity |= granularity & 0xF0;
    ‚îÇ               ‚îÇ       gdt[index].base_high = (base >> 24) & 0xFF;
    ‚îÇ               ‚îÇ   }
    ‚îÇ               ‚îÇ   
    ‚îÇ               ‚îÇ   void gdt_init(void) {
    ‚îÇ               ‚îÇ       serial_puts("[GDT] Initializing GDT...\n");
    ‚îÇ               ‚îÇ       
    ‚îÇ               ‚îÇ       // Null descriptor (–æ–±—è–∑–∞—Ç–µ–ª–µ–Ω)
    ‚îÇ               ‚îÇ       gdt_set_entry(0, 0, 0, 0, 0);
    ‚îÇ               ‚îÇ       
    ‚îÇ               ‚îÇ       // Kernel Code Segment (index 1)
    ‚îÇ               ‚îÇ       gdt_set_entry(1, 0, 0xFFFFF, 
    ‚îÇ               ‚îÇ                    GDT_ACCESS_PRESENT | GDT_ACCESS_RING0 | GDT_ACCESS_SEGMENT | 
    ‚îÇ               ‚îÇ                    GDT_ACCESS_EXECUTABLE | GDT_ACCESS_READ_WRITE,
    ‚îÇ               ‚îÇ                    GDT_GRANULARITY_4K | GDT_GRANULARITY_LONG | 0xF);
    ‚îÇ               ‚îÇ       
    ‚îÇ               ‚îÇ       // Kernel Data Segment (index 2)
    ‚îÇ               ‚îÇ       gdt_set_entry(2, 0, 0xFFFFF,
    ‚îÇ               ‚îÇ                    GDT_ACCESS_PRESENT | GDT_ACCESS_RING0 | GDT_ACCESS_SEGMENT | 
    ‚îÇ               ‚îÇ                    GDT_ACCESS_READ_WRITE,
    ‚îÇ               ‚îÇ                    GDT_GRANULARITY_4K | 0xF);
    ‚îÇ               ‚îÇ       
    ‚îÇ               ‚îÇ       // –û—Å—Ç–∞–ª—å–Ω—ã–µ –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä—ã –æ—Å—Ç–∞–≤–ª—è–µ–º –Ω—É–ª–µ–≤—ã–º–∏ –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ —Å Limine
    ‚îÇ               ‚îÇ       
    ‚îÇ               ‚îÇ       // –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º —É–∫–∞–∑–∞—Ç–µ–ª—å GDT
    ‚îÇ               ‚îÇ       gdtp.limit = sizeof(gdt) - 1;
    ‚îÇ               ‚îÇ       gdtp.base = (uint64_t)&gdt;
    ‚îÇ               ‚îÇ       
    ‚îÇ               ‚îÇ       serial_puts("[GDT] GDT entries set up\n");
    ‚îÇ               ‚îÇ   }
    ‚îÇ               ‚îÇ   
    ‚îÇ               ‚îÇ   void gdt_load(void) {
    ‚îÇ               ‚îÇ       serial_puts("[GDT] Loading GDT...\n");
    ‚îÇ               ‚îÇ       gdt_flush((uint64_t)&gdtp);
    ‚îÇ               ‚îÇ   }
    ‚îÇ               ‚îÇ   
    ‚îÇ               ‚îÇ   const struct gdt_entry* gdt_get_descriptor(int index) {
    ‚îÇ               ‚îÇ       if (index >= 0 && index < 8) {
    ‚îÇ               ‚îÇ           return &gdt[index];
    ‚îÇ               ‚îÇ       }
    ‚îÇ               ‚îÇ       return NULL;
    ‚îÇ               ‚îÇ   }
    ‚îÇ               ‚îÇ
    ‚îÇ           ‚îî‚îÄ‚îÄ gdt_asm.S
    ‚îÇ               ‚îÇ
    ‚îÇ               ‚îú‚îÄ‚îÄ CONTENT:
    ‚îÇ               ‚îÇ   .section .text
    ‚îÇ               ‚îÇ   .global gdt_flush
    ‚îÇ               ‚îÇ   
    ‚îÇ               ‚îÇ   gdt_flush:
    ‚îÇ               ‚îÇ       // rdi —Å–æ–¥–µ—Ä–∂–∏—Ç —É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ struct gdt_ptr
    ‚îÇ               ‚îÇ       lgdt (%rdi)
    ‚îÇ               ‚îÇ       
    ‚îÇ               ‚îÇ       // –û–±–Ω–æ–≤–ª—è–µ–º —Å–µ–≥–º–µ–Ω—Ç–Ω—ã–µ —Ä–µ–≥–∏—Å—Ç—Ä—ã
    ‚îÇ               ‚îÇ       mov $0x10, %ax    // Kernel Data Segment selector (8-–π –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä * 8 = 0x10)
    ‚îÇ               ‚îÇ       mov %ax, %ds
    ‚îÇ               ‚îÇ       mov %ax, %es
    ‚îÇ               ‚îÇ       mov %ax, %fs
    ‚îÇ               ‚îÇ       mov %ax, %gs
    ‚îÇ               ‚îÇ       mov %ax, %ss
    ‚îÇ               ‚îÇ       
    ‚îÇ               ‚îÇ       // –î–µ–ª–∞–µ–º –¥–∞–ª—å–Ω–∏–π –ø–µ—Ä–µ—Ö–æ–¥ –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è CS
    ‚îÇ               ‚îÇ       pushq $0x08       // Kernel Code Segment selector (7-–π –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä * 8 = 0x08)
    ‚îÇ               ‚îÇ       lea .flush_here(%rip), %rax
    ‚îÇ               ‚îÇ       pushq %rax
    ‚îÇ               ‚îÇ       lretq
    ‚îÇ               ‚îÇ   
    ‚îÇ               ‚îÇ   .flush_here:
    ‚îÇ               ‚îÇ       ret
    ‚îÇ               ‚îÇ
    ‚îú‚îÄ‚îÄ limine-tools
    ‚îÇ   ‚îú‚îÄ‚îÄ cc-runtime
    ‚îÇ       ‚îî‚îÄ‚îÄ <—Å–∫—Ä—ã—Ç–æ: —Å–∏—Å—Ç–µ–º–Ω–∞—è/–±–∏–Ω–∞—Ä–Ω–∞—è –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è>
    ‚îÇ   ‚îú‚îÄ‚îÄ freestnd-c-hdrs
    ‚îÇ       ‚îî‚îÄ‚îÄ <—Å–∫—Ä—ã—Ç–æ: —Å–∏—Å—Ç–µ–º–Ω–∞—è/–±–∏–Ω–∞—Ä–Ω–∞—è –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è>
    ‚îÇ   ‚îú‚îÄ‚îÄ limine
    ‚îÇ       ‚îî‚îÄ‚îÄ <—Å–∫—Ä—ã—Ç–æ: —Å–∏—Å—Ç–µ–º–Ω–∞—è/–±–∏–Ω–∞—Ä–Ω–∞—è –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è>
    ‚îÇ   ‚îú‚îÄ‚îÄ limine-protocol
    ‚îÇ       ‚îî‚îÄ‚îÄ <—Å–∫—Ä—ã—Ç–æ: —Å–∏—Å—Ç–µ–º–Ω–∞—è/–±–∏–Ω–∞—Ä–Ω–∞—è –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è>
    ‚îÇ   ‚îî‚îÄ‚îÄ ovmf
    ‚îÇ       ‚îî‚îÄ‚îÄ <—Å–∫—Ä—ã—Ç–æ: —Å–∏—Å—Ç–µ–º–Ω–∞—è/–±–∏–Ω–∞—Ä–Ω–∞—è –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è>
    ‚îú‚îÄ‚îÄ limine.conf
        ‚îÇ
        ‚îú‚îÄ‚îÄ CONTENT:
        ‚îÇ   # Timeout in seconds that Limine will use before automatically booting.
        ‚îÇ   timeout: 3
        ‚îÇ   
        ‚îÇ   # The entry name that will be displayed in the boot menu.
        ‚îÇ   /DEER OS v0.0.1
        ‚îÇ       # We use the Limine boot protocol.
        ‚îÇ       protocol: limine
        ‚îÇ   
        ‚îÇ       # Path to the kernel to boot. boot():/ represents the partition on which limine.conf is located.
        ‚îÇ       path: boot():/boot/kernel
        ‚îÇ       resolution: 800x600
        ‚îÇ
    ‚îî‚îÄ‚îÄ os-config.json
        ‚îÇ
        ‚îú‚îÄ‚îÄ CONTENT:
        ‚îÇ   {
        ‚îÇ       "name": "DEER",
        ‚îÇ       "version": "v0.0.1",
        ‚îÇ       "description": "A 64-bit operating system for extreme conditions.",
        ‚îÇ       "author": "VeoQeo",
        ‚îÇ       "arch": "x86_64",
        ‚îÇ       "bootloader": "limine",
        ‚îÇ       "website": null,
        ‚îÇ       "license": "MIT"
        ‚îÇ   }
        ‚îÇ
