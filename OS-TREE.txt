ğŸ“ OS Project Tree (with text file contents)
================================================================================
â””â”€â”€ 
    â”œâ”€â”€ LICENSE
        â”‚
        â”œâ”€â”€ CONTENT:
        â”‚   Copyright (C) 2023-2025 mintsuki and contributors.
        â”‚   
        â”‚   Permission to use, copy, modify, and/or distribute this software for any
        â”‚   purpose with or without fee is hereby granted.
        â”‚   
        â”‚   THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
        â”‚   REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
        â”‚   FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
        â”‚   INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
        â”‚   LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
        â”‚   OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
        â”‚   PERFORMANCE OF THIS SOFTWARE.
        â”‚
    â”œâ”€â”€ OS-TREE.txt
        â”‚
        â”œâ”€â”€ CONTENT:
        â”‚   <empty>
        â”‚
    â”œâ”€â”€ build.py
        â”‚
        â”œâ”€â”€ CONTENT:
        â”‚   #!/usr/bin/env python3
        â”‚   
        â”‚   import os
        â”‚   import sys
        â”‚   import subprocess
        â”‚   import argparse
        â”‚   from pathlib import Path
        â”‚   import json
        â”‚   import time
        â”‚   
        â”‚   
        â”‚   def run(cmd, check=True, shell=False, cwd=None):
        â”‚       """Ğ£Ğ½Ğ¸Ğ²ĞµÑ€ÑĞ°Ğ»ÑŒĞ½Ğ°Ñ Ğ¾Ğ±Ñ‘Ñ€Ñ‚ĞºĞ° Ğ´Ğ»Ñ Ğ²Ñ‹Ğ¿Ğ¾Ğ»Ğ½ĞµĞ½Ğ¸Ñ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´."""
        â”‚       print(f"[RUN] {' '.join(cmd) if isinstance(cmd, list) else cmd}")
        â”‚       result = subprocess.run(cmd, shell=shell, check=check, cwd=cwd)
        â”‚       return result
        â”‚   
        â”‚   
        â”‚   class Builder:
        â”‚       def __init__(self, name=None, version=None):
        â”‚           self.ensure_config()  # â† Ğ”Ğ¾Ğ±Ğ°Ğ²Ğ»ĞµĞ½Ğ¾
        â”‚   
        â”‚           self.ARCH = "x86_64"
        â”‚           self.OUTPUT = "kernel"
        â”‚           self.KERNEL_DIR = Path("kernel")
        â”‚           self.BUILD_DIR = self.KERNEL_DIR / f"bin-{self.ARCH}"
        â”‚           self.OBJ_DIR = self.KERNEL_DIR / f"obj-{self.ARCH}"
        â”‚           self.LINKER_SCRIPT = self.KERNEL_DIR / "linker-scripts" / f"{self.ARCH}.lds"
        â”‚   
        â”‚           TOOLS_DIR = Path("limine-tools")
        â”‚           self.LIMINE_DIR = TOOLS_DIR / "limine"
        â”‚           self.OVMF_DIR = TOOLS_DIR / "ovmf"
        â”‚           self.OVMF_FILE = self.OVMF_DIR / f"ovmf-code-{self.ARCH}.fd"
        â”‚   
        â”‚           self.ISO_DIR = Path("iso_root")
        â”‚           self.ISO_FILE = Path("deer-v0.0.1.iso")
        â”‚           self.HDD_FILE = Path("deer-v0.0.1.hdd")
        â”‚   
        â”‚           self.QEMU = f"qemu-system-{self.ARCH}"
        â”‚   
        â”‚           # Ğ—Ğ°Ğ³Ñ€ÑƒĞ¶Ğ°ĞµĞ¼ ĞºĞ¾Ğ½Ñ„Ğ¸Ğ³
        â”‚           with open("os-config.json", 'r', encoding='utf-8') as f:
        â”‚               config = json.load(f)
        â”‚           self.OS_NAME = name or config.get("name", "DEER")
        â”‚           self.OS_VERSION = version or config.get("version", "v0.0.1")
        â”‚   
        â”‚           # Ğ“ĞµĞ½ĞµÑ€Ğ°Ñ†Ğ¸Ñ Ğ¸Ğ¼ĞµĞ½Ğ¸ ISO
        â”‚           timestamp = time.strftime("%Y%m%d-%H%M%S")
        â”‚           safe_name = "".join(c for c in self.OS_NAME if c.isalnum() or c in "._-")
        â”‚           safe_version = "".join(c for c in self.OS_VERSION if c.isalnum() or c in "._-")
        â”‚           self.FINAL_ISO_NAME = f"{safe_name}.{safe_version}-{timestamp}.iso"
        â”‚   
        â”‚           self.DEMO_ISO_DIR = Path("demo_iso")
        â”‚           self.DEMO_ISO_DIR.mkdir(exist_ok=True)
        â”‚   
        â”‚       def clean(self):
        â”‚           """ĞÑ‡Ğ¸ÑÑ‚Ğ¸Ñ‚ÑŒ Ğ²Ñ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ğµ Ñ„Ğ°Ğ¹Ğ»Ñ‹ ÑĞ±Ğ¾Ñ€ĞºĞ¸ Ğ¸ ISO."""
        â”‚           cleaned = []
        â”‚           if self.BUILD_DIR.exists():
        â”‚               run(["rm", "-rf", str(self.BUILD_DIR)])
        â”‚               cleaned.append(str(self.BUILD_DIR))
        â”‚           if self.OBJ_DIR.exists():
        â”‚               run(["rm", "-rf", str(self.OBJ_DIR)])
        â”‚               cleaned.append(str(self.OBJ_DIR))
        â”‚           if self.ISO_DIR.exists():
        â”‚               run(["rm", "-rf", str(self.ISO_DIR)])
        â”‚               cleaned.append(str(self.ISO_DIR))
        â”‚           if self.ISO_FILE.exists():
        â”‚               self.ISO_FILE.unlink()
        â”‚               cleaned.append(str(self.ISO_FILE))
        â”‚   
        â”‚           if cleaned:
        â”‚               print(f"[OK] ĞÑ‡Ğ¸Ñ‰ĞµĞ½Ğ¾: {', '.join(cleaned)}")
        â”‚           else:
        â”‚               print("[OK] ĞĞµÑ‡ĞµĞ³Ğ¾ Ñ‡Ğ¸ÑÑ‚Ğ¸Ñ‚ÑŒ.")
        â”‚   
        â”‚       def distclean(self):
        â”‚           """ĞŸĞ¾Ğ»Ğ½Ğ°Ñ Ğ¾Ñ‡Ğ¸ÑÑ‚ĞºĞ°: Ğ²ĞºĞ»ÑÑ‡Ğ°Ñ Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚Ğ¸."""
        â”‚           self.clean()
        â”‚           tools_dir = Path("limine-tools")
        â”‚           if tools_dir.exists():
        â”‚               run(["rm", "-rf", str(tools_dir)])
        â”‚           deps_flag = self.KERNEL_DIR / ".deps-obtained"
        â”‚           if deps_flag.exists():
        â”‚               deps_flag.unlink()
        â”‚           print("[OK] ĞŸĞ¾Ğ»Ğ½Ğ°Ñ Ğ¾Ñ‡Ğ¸ÑÑ‚ĞºĞ° Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½Ğ°.")
        â”‚   
        â”‚       def ensure_deps(self):
        â”‚           deps_flag = self.KERNEL_DIR / ".deps-obtained"
        â”‚           if not deps_flag.exists():
        â”‚               print("[!] Ğ—Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚Ğ¸ Ğ½Ğµ ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ñ‹. Ğ—Ğ°Ğ¿ÑƒÑĞºĞ°ĞµĞ¼ get-deps...")
        â”‚               run(["./get-deps"], cwd=str(self.KERNEL_DIR))
        â”‚               deps_flag.touch()
        â”‚       
        â”‚       def ensure_config(self):
        â”‚           """Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‘Ñ‚ os-config.json, ĞµÑĞ»Ğ¸ Ğ¾Ğ½ Ğ½Ğµ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒĞµÑ‚."""
        â”‚           config_path = Path("os-config.json")
        â”‚           if config_path.exists():
        â”‚               return
        â”‚   
        â”‚           print(f"[*] Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ ĞºĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ğ¾Ğ½Ğ½Ğ¾Ğ³Ğ¾ Ñ„Ğ°Ğ¹Ğ»Ğ° {config_path}...")
        â”‚   
        â”‚           config_data = {
        â”‚               "name": "DEER",
        â”‚               "version": "v0.0.1",
        â”‚               "description": "A 64-bit operating system for extreme conditions.",
        â”‚               "author": "VeoQeo",
        â”‚               "arch": "x86_64",
        â”‚               "bootloader": "limine",
        â”‚               "website": None,
        â”‚               "license": "MIT"
        â”‚           }
        â”‚   
        â”‚           with open(config_path, 'w', encoding='utf-8') as f:
        â”‚               json.dump(config_data, f, indent=4, ensure_ascii=False)
        â”‚   
        â”‚           print(f"[OK] ĞšĞ¾Ğ½Ñ„Ğ¸Ğ³ÑƒÑ€Ğ°Ñ†Ğ¸Ñ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ° Ğ² {config_path}")
        â”‚   
        â”‚       def ensure_linker_scripts(self):
        â”‚           """Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‘Ñ‚ Ğ¿Ğ°Ğ¿ĞºÑƒ linker-scripts Ğ¸ Ñ„Ğ°Ğ¹Ğ» x86_64.lds, ĞµÑĞ»Ğ¸ Ğ¸Ñ… Ğ½ĞµÑ‚."""
        â”‚           script_dir = self.KERNEL_DIR / "linker-scripts"
        â”‚           script_file = script_dir / "x86_64.lds"
        â”‚   
        â”‚           if not script_file.exists():
        â”‚               print(f"[*] Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ {script_file}...")
        â”‚   
        â”‚               lds_content = '''OUTPUT_FORMAT(elf64-x86-64)
        â”‚   
        â”‚   ENTRY(kernel_main)
        â”‚   
        â”‚   PHDRS
        â”‚   {
        â”‚       limine_requests PT_LOAD;
        â”‚       text PT_LOAD;
        â”‚       rodata PT_LOAD;
        â”‚       data PT_LOAD;
        â”‚   }
        â”‚   
        â”‚   SECTIONS
        â”‚   {
        â”‚       . = 0xffffffff80000000;
        â”‚   
        â”‚       .limine_requests : {
        â”‚           KEEP(*(.limine_requests_start))
        â”‚           KEEP(*(.limine_requests))
        â”‚           KEEP(*(.limine_requests_end))
        â”‚       } :limine_requests
        â”‚   
        â”‚       . = ALIGN(CONSTANT(MAXPAGESIZE));
        â”‚   
        â”‚       .text : {
        â”‚           *(.text .text.*)
        â”‚       } :text
        â”‚   
        â”‚       . = ALIGN(CONSTANT(MAXPAGESIZE));
        â”‚   
        â”‚       .rodata : {
        â”‚           *(.rodata .rodata.*)
        â”‚       } :rodata
        â”‚   
        â”‚       .note.gnu.build-id : {
        â”‚           *(.note.gnu.build-id)
        â”‚       } :rodata
        â”‚   
        â”‚       . = ALIGN(CONSTANT(MAXPAGESIZE));
        â”‚   
        â”‚       .data : {
        â”‚           *(.data .data.*)
        â”‚       } :data
        â”‚   
        â”‚       .bss : {
        â”‚           *(.bss .bss.*)
        â”‚           *(COMMON)
        â”‚       } :data
        â”‚   
        â”‚       /DISCARD/ : {
        â”‚           *(.eh_frame*)
        â”‚           *(.note .note.*)
        â”‚       }
        â”‚   }
        â”‚   '''
        â”‚               script_dir.mkdir(exist_ok=True)
        â”‚               with open(script_file, 'w', encoding='utf-8') as f:
        â”‚                   f.write(lds_content.strip() + '\n')
        â”‚               print(f"[OK] Ğ¤Ğ°Ğ¹Ğ» {script_file} ÑĞ¾Ğ·Ğ´Ğ°Ğ½.")
        â”‚           else:
        â”‚               print(f"[OK] Ğ›Ğ¸Ğ½ĞºĞµÑ€-ÑĞºÑ€Ğ¸Ğ¿Ñ‚ ÑƒĞ¶Ğµ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒĞµÑ‚: {script_file}")
        â”‚   
        â”‚       def build_kernel(self):
        â”‚           print("[*] Ğ¡Ğ±Ğ¾Ñ€ĞºĞ° ÑĞ´Ñ€Ğ° Ğ´Ğ»Ñ x86_64...")
        â”‚   
        â”‚           # Ğ“Ğ°Ñ€Ğ°Ğ½Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼ Ğ½Ğ°Ğ»Ğ¸Ñ‡Ğ¸Ğµ linker-scripts/x86_64.lds
        â”‚           self.ensure_linker_scripts()
        â”‚   
        â”‚           from glob import glob
        â”‚           c_files = [Path(f) for f in glob("src/**/*.c", recursive=True, root_dir=self.KERNEL_DIR)]
        â”‚           s_files = [Path(f) for f in glob("src/**/*.S", recursive=True, root_dir=self.KERNEL_DIR)]
        â”‚           asm_files = [Path(f) for f in glob("src/**/*.asm", recursive=True, root_dir=self.KERNEL_DIR)]
        â”‚   
        â”‚           arch_c = [Path(f) for f in glob("src/arch/x86_64/**/*.c", recursive=True, root_dir=self.KERNEL_DIR)]
        â”‚           arch_s = [Path(f) for f in glob("src/arch/x86_64/**/*.S", recursive=True, root_dir=self.KERNEL_DIR)]
        â”‚           arch_asm = [Path(f) for f in glob("src/arch/x86_64/**/*.asm", recursive=True, root_dir=self.KERNEL_DIR)]
        â”‚   
        â”‚           all_c = c_files + arch_c
        â”‚           all_s = s_files + arch_s
        â”‚           all_asm = asm_files + arch_asm
        â”‚   
        â”‚           objects = []
        â”‚   
        â”‚           CC = os.getenv("CC", "gcc")
        â”‚           LD = os.getenv("LD", "ld")
        â”‚           NASM = "nasm"
        â”‚   
        â”‚           # ĞÑĞ½Ğ¾Ğ²Ğ½Ñ‹Ğµ Ñ„Ğ»Ğ°Ğ³Ğ¸ ĞºĞ¾Ğ¼Ğ¿Ğ¸Ğ»ÑÑ†Ğ¸Ğ¸ (Ğ±ĞµĞ· SSE)
        â”‚           CFLAGS = [
        â”‚               "-g", "-O2", "-pipe", "-Wall", "-Wextra", "-std=gnu11",
        â”‚               "-ffreestanding", "-fno-stack-protector",
        â”‚               "-fno-stack-check", "-fno-lto", "-fno-PIC",
        â”‚               "-ffunction-sections", "-fdata-sections",
        â”‚               "-m64", "-march=x86-64", "-mabi=sysv",
        â”‚               "-mno-80387", "-mno-mmx", "-mno-sse", "-mno-sse2",
        â”‚               "-mno-red-zone", "-mcmodel=kernel"
        â”‚           ]
        â”‚   
        â”‚           # Ğ¡Ğ¿ĞµÑ†Ğ¸Ğ°Ğ»ÑŒĞ½Ñ‹Ğµ Ñ„Ğ»Ğ°Ğ³Ğ¸ Ğ´Ğ»Ñ SIMD Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ² Ğ¸ kernel.c (Ñ SSE)
        â”‚           SIMD_CFLAGS = [
        â”‚               "-g", "-O2", "-pipe", "-Wall", "-Wextra", "-std=gnu11",
        â”‚               "-ffreestanding", "-fno-stack-protector",
        â”‚               "-fno-stack-check", "-fno-lto", "-fno-PIC",
        â”‚               "-ffunction-sections", "-fdata-sections",
        â”‚               "-m64", "-march=x86-64", "-mabi=sysv",
        â”‚               "-mno-80387", "-mno-mmx", 
        â”‚               # Ğ’ĞšĞ›Ğ®Ğ§ĞĞ•Ğœ SSE Ğ”Ğ›Ğ¯ SIMD Ğ¤ĞĞ™Ğ›ĞĞ’ Ğ˜ KERNEL.C:
        â”‚               "-msse", "-msse2",
        â”‚               "-mno-red-zone", "-mcmodel=kernel"
        â”‚           ]
        â”‚   
        â”‚           CPPFLAGS = [
        â”‚               f"-I{self.KERNEL_DIR}/src",
        â”‚               f"-I{self.KERNEL_DIR}/../limine-tools/limine-protocol/include",
        â”‚               f"-isystem{self.KERNEL_DIR}/../limine-tools/freestnd-c-hdrs/include",
        â”‚               "-nostdinc",
        â”‚               "-DLIMINE_API_REVISION=3",
        â”‚               "-MMD", "-MP"
        â”‚           ]
        â”‚   
        â”‚           LDFLAGS = [
        â”‚               "-nostdlib", "-static",
        â”‚               "-z", "max-page-size=0x1000",
        â”‚               "--gc-sections",
        â”‚               f"-T{self.LINKER_SCRIPT}"
        â”‚           ]
        â”‚   
        â”‚           os.makedirs(self.OBJ_DIR, exist_ok=True)
        â”‚   
        â”‚           # ĞšĞ¾Ğ¼Ğ¿Ğ¸Ğ»ÑÑ†Ğ¸Ñ .c Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ²
        â”‚           for src in all_c:
        â”‚               rel_src = Path("src") / src
        â”‚               obj = self.OBJ_DIR / rel_src.with_suffix(".c.o")
        â”‚               os.makedirs(obj.parent, exist_ok=True)
        â”‚               
        â”‚               # Ğ’Ñ‹Ğ±Ğ¸Ñ€Ğ°ĞµĞ¼ Ñ„Ğ»Ğ°Ğ³Ğ¸ Ğ² Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚Ğ¸ Ğ¾Ñ‚ Ñ„Ğ°Ğ¹Ğ»Ğ°
        â”‚               src_str = str(src)
        â”‚               if "simd" in src_str.lower() or "kernel.c" in src_str:
        â”‚                   # Ğ”Ğ»Ñ SIMD Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ² Ğ¸ kernel.c Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ ÑĞ¿ĞµÑ†Ğ¸Ğ°Ğ»ÑŒĞ½Ñ‹Ğµ Ñ„Ğ»Ğ°Ğ³Ğ¸
        â”‚                   print(f"[*] ĞšĞ¾Ğ¼Ğ¿Ğ¸Ğ»ÑÑ†Ğ¸Ñ Ñ SSE: {src}")
        â”‚                   cmd = [CC] + SIMD_CFLAGS + CPPFLAGS + ["-c", str(self.KERNEL_DIR / src), "-o", str(obj)]
        â”‚               else:
        â”‚                   # Ğ”Ğ»Ñ Ğ²ÑĞµÑ… Ğ¾ÑÑ‚Ğ°Ğ»ÑŒĞ½Ñ‹Ñ… Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ² - Ğ¾Ğ±Ñ‹Ñ‡Ğ½Ñ‹Ğµ Ñ„Ğ»Ğ°Ğ³Ğ¸
        â”‚                   cmd = [CC] + CFLAGS + CPPFLAGS + ["-c", str(self.KERNEL_DIR / src), "-o", str(obj)]
        â”‚               
        â”‚               run(cmd)
        â”‚               objects.append(obj)
        â”‚   
        â”‚           # ĞšĞ¾Ğ¼Ğ¿Ğ¸Ğ»ÑÑ†Ğ¸Ñ .S Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ² (Ğ°ÑÑĞµĞ¼Ğ±Ğ»ĞµÑ€) - Ğ²ÑĞµĞ³Ğ´Ğ° Ğ±ĞµĞ· SSE
        â”‚           for src in all_s:
        â”‚               rel_src = Path("src") / src
        â”‚               obj = self.OBJ_DIR / rel_src.with_suffix(".S.o")
        â”‚               os.makedirs(obj.parent, exist_ok=True)
        â”‚               cmd = [CC] + CFLAGS + CPPFLAGS + ["-c", str(self.KERNEL_DIR / src), "-o", str(obj)]
        â”‚               run(cmd)
        â”‚               objects.append(obj)
        â”‚   
        â”‚           # ĞšĞ¾Ğ¼Ğ¿Ğ¸Ğ»ÑÑ†Ğ¸Ñ .asm Ñ‡ĞµÑ€ĞµĞ· NASM
        â”‚           NASMFLAGS = ["-g", "-F", "dwarf", "-Wall", "-f", "elf64"]
        â”‚           for src in all_asm:
        â”‚               rel_src = Path("src") / src
        â”‚               obj = self.OBJ_DIR / rel_src.with_suffix(".asm.o")
        â”‚               os.makedirs(obj.parent, exist_ok=True)
        â”‚               cmd = [NASM] + NASMFLAGS + [str(self.KERNEL_DIR / src), "-o", str(obj)]
        â”‚               run(cmd)
        â”‚               objects.append(obj)
        â”‚   
        â”‚           # ĞšĞ¾Ğ½Ğ²ĞµÑ€Ñ‚Ğ¸Ñ€ÑƒĞµĞ¼ font.psf Ğ² Ğ¾Ğ±ÑŠĞµĞºÑ‚Ğ½Ñ‹Ğ¹ Ñ„Ğ°Ğ¹Ğ»
        â”‚           font_psf = self.KERNEL_DIR / "src" / "font.psf"
        â”‚           font_o = self.OBJ_DIR / "font.o"
        â”‚   
        â”‚           if font_psf.exists():
        â”‚               print("[*] ĞšĞ¾Ğ½Ğ²ĞµÑ€Ñ‚Ğ°Ñ†Ğ¸Ñ font.psf -> font.o...")
        â”‚               run([
        â”‚                   "objcopy",
        â”‚                   "-I", "binary",
        â”‚                   "-O", "elf64-x86-64",
        â”‚                   "-B", "i386",
        â”‚                   "--redefine-sym", "_binary_kernel_src_font_psf_start=_binary_font_psf_start",
        â”‚                   "--redefine-sym", "_binary_kernel_src_font_psf_end=_binary_font_psf_end",
        â”‚                   "--redefine-sym", "_binary_kernel_src_font_psf_size=_binary_font_psf_size",
        â”‚                   str(font_psf),
        â”‚                   str(font_o)
        â”‚               ])
        â”‚               objects.append(font_o)
        â”‚           else:
        â”‚               print(f"[!] Ğ¤Ğ°Ğ¹Ğ» ÑˆÑ€Ğ¸Ñ„Ñ‚Ğ° Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½: {font_psf}")
        â”‚               sys.exit(1)
        â”‚   
        â”‚           # Ğ›Ğ¸Ğ½ĞºĞ¾Ğ²ĞºĞ°
        â”‚           kernel_out = self.BUILD_DIR / self.OUTPUT
        â”‚           os.makedirs(self.BUILD_DIR, exist_ok=True)
        â”‚           link_cmd = [LD] + LDFLAGS + [str(obj) for obj in objects] + ["-o", str(kernel_out)]
        â”‚           run(link_cmd)
        â”‚           print(f"[OK] Ğ¯Ğ´Ñ€Ğ¾ ÑĞ¾Ğ±Ñ€Ğ°Ğ½Ğ¾: {kernel_out}")
        â”‚   
        â”‚       def clone_limine(self):
        â”‚           if not self.LIMINE_DIR.parent.exists():
        â”‚               self.LIMINE_DIR.parent.mkdir(parents=True, exist_ok=True)
        â”‚   
        â”‚           if not self.LIMINE_DIR.exists():
        â”‚               print("[*] ĞšĞ»Ğ¾Ğ½Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Limine binary release Ğ² limine-tools/limine...")
        â”‚               run([
        â”‚                   "git", "clone",
        â”‚                   "--branch", "v10.x-binary",
        â”‚                   "--depth", "1",
        â”‚                   "https://codeberg.org/Limine/Limine.git",
        â”‚                   str(self.LIMINE_DIR)
        â”‚               ])
        â”‚           run(["make"], cwd=self.LIMINE_DIR)
        â”‚   
        â”‚       def download_ovmf(self):
        â”‚           if not self.OVMF_FILE.parent.exists():
        â”‚               self.OVMF_FILE.parent.mkdir(parents=True, exist_ok=True)
        â”‚   
        â”‚           if not self.OVMF_FILE.exists():
        â”‚               print("[*] Ğ¡ĞºĞ°Ñ‡Ğ¸Ğ²Ğ°Ğ½Ğ¸Ğµ OVMF Ğ² limine-tools/ovmf...")
        â”‚               url = "https://github.com/osdev0/edk2-ovmf-nightly/releases/latest/download/ovmf-code-x86_64.fd"
        â”‚               run(["curl", "-Lo", str(self.OVMF_FILE), url])
        â”‚   
        â”‚       def create_iso(self):
        â”‚           if self.ISO_FILE.exists():
        â”‚               print(f"[*] ISO ÑƒĞ¶Ğµ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒĞµÑ‚ â€” Ğ¿Ñ€Ğ¾Ğ¿ÑƒÑĞºĞ°ĞµĞ¼ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ.")
        â”‚               return
        â”‚   
        â”‚           print("[*] Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ ISO...")
        â”‚   
        â”‚           if self.ISO_DIR.exists():
        â”‚               run(["rm", "-rf", str(self.ISO_DIR)])
        â”‚   
        â”‚           boot_dir = self.ISO_DIR / "boot"
        â”‚           limine_dir = boot_dir / "limine"
        â”‚           efi_dir = self.ISO_DIR / "EFI" / "BOOT"
        â”‚   
        â”‚           for d in [boot_dir, limine_dir, efi_dir]:
        â”‚               d.mkdir(parents=True, exist_ok=True)
        â”‚   
        â”‚           kernel_src = self.BUILD_DIR / self.OUTPUT
        â”‚           run(["cp", str(kernel_src), str(boot_dir / "kernel")])
        â”‚           run(["cp", "limine.conf", str(limine_dir)])
        â”‚   
        â”‚           # ĞšĞ¾Ğ¿Ğ¸Ñ€ÑƒĞµĞ¼ Ñ„Ğ°Ğ¹Ğ»Ñ‹ Limine Ğ¸Ğ· limine-tools
        â”‚           files_to_copy = [
        â”‚               ("limine-bios.sys", "boot/limine"),
        â”‚               ("limine-bios-cd.bin", "boot/limine"),
        â”‚               ("limine-uefi-cd.bin", "boot/limine"),
        â”‚               ("BOOTX64.EFI", "EFI/BOOT"),
        â”‚               ("BOOTIA32.EFI", "EFI/BOOT"),
        â”‚           ]
        â”‚   
        â”‚           for src, dst in files_to_copy:
        â”‚               run(["cp", str(self.LIMINE_DIR / src), str(self.ISO_DIR / dst)])
        â”‚   
        â”‚           # Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‘Ğ¼ ISO
        â”‚           xorriso_cmd = [
        â”‚               "xorriso", "-as", "mkisofs", "-R", "-r", "-J",
        â”‚               "-b", "boot/limine/limine-bios-cd.bin",
        â”‚               "-no-emul-boot", "-boot-load-size", "4", "-boot-info-table",
        â”‚               "-hfsplus", "-apm-block-size", "2048",
        â”‚               "--efi-boot", "boot/limine/limine-uefi-cd.bin",
        â”‚               "-efi-boot-part", "--efi-boot-image", "--protective-msdos-label",
        â”‚               str(self.ISO_DIR), "-o", str(self.ISO_FILE)
        â”‚           ]
        â”‚           run(xorriso_cmd)
        â”‚   
        â”‚           # Ğ£ÑÑ‚Ğ°Ğ½Ğ°Ğ²Ğ»Ğ¸Ğ²Ğ°ĞµĞ¼ Limine Ğ² Ğ¾Ğ±Ñ€Ğ°Ğ·
        â”‚           run([str(self.LIMINE_DIR / "limine"), "bios-install", str(self.ISO_FILE)])
        â”‚           print(f"[OK] ISO ÑĞ¾Ğ·Ğ´Ğ°Ğ½: {self.ISO_FILE}")
        â”‚   
        â”‚       def save_demo_iso(self):
        â”‚           """ĞšĞ¾Ğ¿Ğ¸Ñ€ÑƒĞµÑ‚ ISO Ğ² demo_iso/ Ñ Ğ¸Ğ¼ĞµĞ½ĞµĞ¼ NAME.VERSION-TIMESTAMP.iso"""
        â”‚           dest = self.DEMO_ISO_DIR / self.FINAL_ISO_NAME
        â”‚           run(["cp", str(self.ISO_FILE), str(dest)])
        â”‚           print(f"[OK] ISO ÑĞ¾Ñ…Ñ€Ğ°Ğ½Ñ‘Ğ½ ĞºĞ°Ğº: {dest}")
        â”‚   
        â”‚       def run_qemu_uefi(self, cleanup_after=False):
        â”‚           if not self.ISO_FILE.exists():
        â”‚               print(f"[!] ISO Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½: {self.ISO_FILE}")
        â”‚               sys.exit(1)
        â”‚           self.download_ovmf()
        â”‚           cmd = (
        â”‚               f"{self.QEMU} -M q35 "
        â”‚               f"-drive if=pflash,unit=0,format=raw,file={self.OVMF_FILE},readonly=on "
        â”‚               f"-cdrom {self.ISO_FILE} -m 2G "
        â”‚               "-serial stdio" 
        â”‚           )
        â”‚           try:
        â”‚               run(cmd, shell=True)
        â”‚           finally:
        â”‚               if cleanup_after:
        â”‚                   print("\n[CLEANUP] Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚Ğ¸Ğµ QEMU â€” Ğ·Ğ°Ğ¿ÑƒÑĞº Ğ¾Ñ‡Ğ¸ÑÑ‚ĞºĞ¸...")
        â”‚                   self.clean()
        â”‚   
        â”‚       def _is_text_file(self, path: Path) -> bool:
        â”‚           """ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµÑ‚, ÑĞ²Ğ»ÑĞµÑ‚ÑÑ Ğ»Ğ¸ Ñ„Ğ°Ğ¹Ğ» Ñ‚ĞµĞºÑÑ‚Ğ¾Ğ²Ñ‹Ğ¼ (Ğ±ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾ Ñ‡Ğ¸Ñ‚Ğ°ĞµĞ¼Ñ‹Ğ¼)."""
        â”‚           try:
        â”‚               with open(path, 'r', encoding='utf-8') as f:
        â”‚                   f.read(1024)
        â”‚               return True
        â”‚           except (UnicodeDecodeError, PermissionError, IsADirectoryError, FileNotFoundError):
        â”‚               return False
        â”‚   
        â”‚       def generate_tree_with_content(self, output_file="OS-TREE.txt"):
        â”‚           """Ğ“ĞµĞ½ĞµÑ€Ğ¸Ñ€ÑƒĞµÑ‚ OS-TREE.txt Ñ Ğ´ĞµÑ€ĞµĞ²Ğ¾Ğ¼ Ğ¿Ñ€Ğ¾ĞµĞºÑ‚Ğ° Ğ¸ ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ¸Ğ¼Ñ‹Ğ¼ Ñ‚ĞµĞºÑÑ‚Ğ¾Ğ²Ñ‹Ñ… Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ² (Ñ Ğ¸ÑĞºĞ»ÑÑ‡ĞµĞ½Ğ¸ÑĞ¼Ğ¸)."""
        â”‚           print(f"[*] Ğ“ĞµĞ½ĞµÑ€Ğ°Ñ†Ğ¸Ñ Ğ´ĞµÑ€ĞµĞ²Ğ° ÑĞ¸ÑÑ‚ĞµĞ¼Ñ‹ Ğ² {output_file}...")
        â”‚   
        â”‚           with open(output_file, "w", encoding="utf-8") as out:
        â”‚               root = Path(".")
        â”‚   
        â”‚               skip_dirs = {
        â”‚                   "bin-x86_64", "obj-x86_64",
        â”‚                   "cc-runtime", "freestnd-c-hdrs",
        â”‚                   "limine-protocol", "ovmf", "limine"
        â”‚               }
        â”‚   
        â”‚               exclude_dirs = {"__pycache__", ".git", "iso_root"}
        â”‚               exclude_files = {"*.o", "*.d", "*.fd", "*.iso", "*.hdd", "*.pyc"}
        â”‚   
        â”‚               def should_exclude(p: Path):
        â”‚                   if any(part.startswith('.') for part in p.parts):
        â”‚                       return True
        â”‚                   if any(excl in str(p) for excl in exclude_dirs):
        â”‚                       return True
        â”‚                   if any(p.match(pattern) for pattern in exclude_files):
        â”‚                       return True
        â”‚                   return False
        â”‚   
        â”‚               def write_tree(path: Path, prefix="", is_last=True):
        â”‚                   connector = "â””â”€â”€ " if is_last else "â”œâ”€â”€ "
        â”‚                   out.write(f"{prefix}{connector}{path.name}\n")
        â”‚   
        â”‚                   if path.is_dir():
        â”‚                       if path.name in skip_dirs:
        â”‚                           out.write(f"{prefix}    â””â”€â”€ <ÑĞºÑ€Ñ‹Ñ‚Ğ¾: ÑĞ¸ÑÑ‚ĞµĞ¼Ğ½Ğ°Ñ/Ğ±Ğ¸Ğ½Ğ°Ñ€Ğ½Ğ°Ñ Ğ´Ğ¸Ñ€ĞµĞºÑ‚Ğ¾Ñ€Ğ¸Ñ>\n")
        â”‚                           return
        â”‚                       children = sorted([p for p in path.iterdir() if not should_exclude(p)])
        â”‚                       for i, child in enumerate(children):
        â”‚                           extension = "    " if is_last else "â”‚   "
        â”‚                           write_tree(child, prefix + extension, i == len(children) - 1)
        â”‚                   else:
        â”‚                       if path.name == "build.py":
        â”‚                           try:
        â”‚                               out.write(f"{prefix}    â”‚\n")
        â”‚                               out.write(f"{prefix}    â”œâ”€â”€ CONTENT:\n")
        â”‚                               with open(path, 'r', encoding='utf-8') as f:
        â”‚                                   content = f.read().strip()
        â”‚                                   lines = content.splitlines() or ["<empty>"]
        â”‚                                   for line in lines:
        â”‚                                       out.write(f"{prefix}    â”‚   {line}\n")
        â”‚                               out.write(f"{prefix}    â”‚\n")
        â”‚                           except Exception as e:
        â”‚                               out.write(f"{prefix}    â”‚   <Ğ¾ÑˆĞ¸Ğ±ĞºĞ° Ñ‡Ñ‚ĞµĞ½Ğ¸Ñ: {e}>\n")
        â”‚                           return
        â”‚   
        â”‚                       if self._is_text_file(path):
        â”‚                           try:
        â”‚                               out.write(f"{prefix}    â”‚\n")
        â”‚                               out.write(f"{prefix}    â”œâ”€â”€ CONTENT:\n")
        â”‚                               with open(path, 'r', encoding='utf-8') as f:
        â”‚                                   content = f.read().strip()
        â”‚                                   lines = content.splitlines() or ["<empty>"]
        â”‚                                   for line in lines:
        â”‚                                       out.write(f"{prefix}    â”‚   {line}\n")
        â”‚                               out.write(f"{prefix}    â”‚\n")
        â”‚                           except Exception as e:
        â”‚                               out.write(f"{prefix}    â”‚   <Ğ¾ÑˆĞ¸Ğ±ĞºĞ° Ñ‡Ñ‚ĞµĞ½Ğ¸Ñ: {e}>\n")
        â”‚   
        â”‚               out.write("ğŸ“ OS Project Tree (with text file contents)\n")
        â”‚               out.write("=" * 80 + "\n")
        â”‚               write_tree(root)
        â”‚   
        â”‚           print(f"[OK] Ğ”ĞµÑ€ĞµĞ²Ğ¾ Ñ ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ¸Ğ¼Ñ‹Ğ¼ ÑĞ¾Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¾ Ğ² {output_file}")
        â”‚   
        â”‚   
        â”‚   def main():
        â”‚       parser = argparse.ArgumentParser(
        â”‚           description="Ğ¡Ğ±Ğ¾Ñ€ĞºĞ° Ğ¸ Ğ·Ğ°Ğ¿ÑƒÑĞº DEER OS (x86_64)"
        â”‚       )
        â”‚       parser.add_argument("--run", action="store_true",
        â”‚                           help="ĞĞ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸ ÑĞ¾Ğ±Ñ€Ğ°Ñ‚ÑŒ Ğ¸ Ğ·Ğ°Ğ¿ÑƒÑÑ‚Ğ¸Ñ‚ÑŒ Ğ² QEMU (UEFI Ğ¿Ğ¾ ÑƒĞ¼Ğ¾Ğ»Ñ‡Ğ°Ğ½Ğ¸Ñ)")
        â”‚       parser.add_argument("--clean", action="store_true",
        â”‚                           help="ĞÑ‡Ğ¸ÑÑ‚Ğ¸Ñ‚ÑŒ Ğ¾Ğ±ÑŠĞµĞºÑ‚Ğ½Ñ‹Ğµ Ñ„Ğ°Ğ¹Ğ»Ñ‹ (Ğ±ĞµĞ· Ğ¿Ğ¾ÑĞ»ĞµĞ´ÑƒÑÑ‰ĞµĞ¹ ÑĞ±Ğ¾Ñ€ĞºĞ¸)")
        â”‚       parser.add_argument("--distclean", action="store_true",
        â”‚                           help="ĞŸĞ¾Ğ»Ğ½Ğ°Ñ Ğ¾Ñ‡Ğ¸ÑÑ‚ĞºĞ°: ÑƒĞ´Ğ°Ğ»Ğ¸Ñ‚ÑŒ Ğ²ÑÑ‘, Ğ²ĞºĞ»ÑÑ‡Ğ°Ñ Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚Ğ¸ Ğ¸ Ğ¾Ğ±Ñ€Ğ°Ğ·Ñ‹")
        â”‚       parser.add_argument("--tree", action="store_true",
        â”‚                           help="Ğ¡Ğ³ĞµĞ½ĞµÑ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ OS-TREE.txt Ñ Ğ´ĞµÑ€ĞµĞ²Ğ¾Ğ¼ Ğ¸ ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ¸Ğ¼Ñ‹Ğ¼ Ñ‚ĞµĞºÑÑ‚Ğ¾Ğ²Ñ‹Ñ… Ñ„Ğ°Ğ¹Ğ»Ğ¾Ğ²")
        â”‚       parser.add_argument("--name", type=str,
        â”‚                           help="Ğ˜Ğ¼Ñ ĞĞ¡ (Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€, MyDeer)")
        â”‚       parser.add_argument("--version", type=str,
        â”‚                           help="Ğ’ĞµÑ€ÑĞ¸Ñ ĞĞ¡ (Ğ½Ğ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€, v0.1-alpha)")
        â”‚   
        â”‚       args = parser.parse_args()
        â”‚       builder = Builder(name=args.name, version=args.version)
        â”‚   
        â”‚       if args.clean:
        â”‚           builder.clean()
        â”‚       elif args.distclean:
        â”‚           builder.distclean()
        â”‚       elif args.tree:
        â”‚           builder.generate_tree_with_content()
        â”‚       elif args.run:
        â”‚           builder.ensure_deps()
        â”‚           builder.build_kernel()
        â”‚           builder.clone_limine()
        â”‚           builder.create_iso()
        â”‚           builder.save_demo_iso()  # Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ ISO Ñ Ğ¸Ğ¼ĞµĞ½ĞµĞ¼ Ğ¸ Ğ²Ñ€ĞµĞ¼ĞµĞ½ĞµĞ¼
        â”‚           builder.generate_tree_with_content()
        â”‚           builder.run_qemu_uefi(cleanup_after=True)
        â”‚       else:
        â”‚           parser.print_help()
        â”‚   
        â”‚   
        â”‚   if __name__ == "__main__":
        â”‚       main()
        â”‚
    â”œâ”€â”€ demo_iso
    â”œâ”€â”€ kernel
    â”‚   â”œâ”€â”€ bin-x86_64
    â”‚       â””â”€â”€ <ÑĞºÑ€Ñ‹Ñ‚Ğ¾: ÑĞ¸ÑÑ‚ĞµĞ¼Ğ½Ğ°Ñ/Ğ±Ğ¸Ğ½Ğ°Ñ€Ğ½Ğ°Ñ Ğ´Ğ¸Ñ€ĞµĞºÑ‚Ğ¾Ñ€Ğ¸Ñ>
    â”‚   â”œâ”€â”€ get-deps
    â”‚       â”‚
    â”‚       â”œâ”€â”€ CONTENT:
    â”‚       â”‚   #!/bin/sh
    â”‚       â”‚   
    â”‚       â”‚   set -e
    â”‚       â”‚   
    â”‚       â”‚   srcdir="$(dirname "$0")"
    â”‚       â”‚   cd "$srcdir"
    â”‚       â”‚   
    â”‚       â”‚   clone_repo_commit() {
    â”‚       â”‚       local url="$1"
    â”‚       â”‚       local dir="../limine-tools/$2"
    â”‚       â”‚       local commit="$3"
    â”‚       â”‚   
    â”‚       â”‚       if test -d "$dir/.git"; then
    â”‚       â”‚           git -C "$dir" reset --hard
    â”‚       â”‚           git -C "$dir" clean -fd
    â”‚       â”‚           git -C "$dir" -c advice.detachedHead=false checkout "$commit" || exit 1
    â”‚       â”‚       else
    â”‚       â”‚           rm -rf "$dir"
    â”‚       â”‚           git clone "$url" "$dir"
    â”‚       â”‚           git -C "$dir" -c advice.detachedHead=false checkout "$commit" || exit 1
    â”‚       â”‚       fi
    â”‚       â”‚   }
    â”‚       â”‚   
    â”‚       â”‚   # Ğ¡Ğ¾Ğ·Ğ´Ğ°Ñ‘Ğ¼ Ğ´Ğ¸Ñ€ĞµĞºÑ‚Ğ¾Ñ€Ğ¸Ñ limine-tools Ğ¿Ñ€Ğ¸ Ğ½ĞµĞ¾Ğ±Ñ…Ğ¾Ğ´Ğ¸Ğ¼Ğ¾ÑÑ‚Ğ¸
    â”‚       â”‚   mkdir -p ../limine-tools
    â”‚       â”‚   
    â”‚       â”‚   rm -f .deps-obtained
    â”‚       â”‚   
    â”‚       â”‚   clone_repo_commit https://codeberg.org/OSDev/freestnd-c-hdrs-0bsd.git freestnd-c-hdrs 5e4e9e70278fe89ea328d359a58aff4f4a94b165
    â”‚       â”‚   clone_repo_commit https://codeberg.org/OSDev/cc-runtime.git cc-runtime dae79833b57a01b9fd3e359ee31def69f5ae899b
    â”‚       â”‚   clone_repo_commit https://codeberg.org/Limine/limine-protocol.git limine-protocol fedf97facd1c473ee8720f8dfd5a71d03490d928
    â”‚       â”‚   
    â”‚       â”‚   touch .deps-obtained
    â”‚       â”‚   echo "
    â”‚       â”‚   Dependencies obtained successfully.
    â”‚       â”‚   "
    â”‚       â”‚
    â”‚   â”œâ”€â”€ linker-scripts
    â”‚   â”‚   â””â”€â”€ x86_64.lds
    â”‚   â”‚       â”‚
    â”‚   â”‚       â”œâ”€â”€ CONTENT:
    â”‚   â”‚       â”‚   OUTPUT_FORMAT(elf64-x86-64)
    â”‚   â”‚       â”‚   
    â”‚   â”‚       â”‚   ENTRY(kernel_main)
    â”‚   â”‚       â”‚   
    â”‚   â”‚       â”‚   PHDRS
    â”‚   â”‚       â”‚   {
    â”‚   â”‚       â”‚       limine_requests PT_LOAD;
    â”‚   â”‚       â”‚       text PT_LOAD;
    â”‚   â”‚       â”‚       rodata PT_LOAD;
    â”‚   â”‚       â”‚       data PT_LOAD;
    â”‚   â”‚       â”‚   }
    â”‚   â”‚       â”‚   
    â”‚   â”‚       â”‚   SECTIONS
    â”‚   â”‚       â”‚   {
    â”‚   â”‚       â”‚       . = 0xffffffff80000000;
    â”‚   â”‚       â”‚   
    â”‚   â”‚       â”‚       .limine_requests : {
    â”‚   â”‚       â”‚           KEEP(*(.limine_requests_start))
    â”‚   â”‚       â”‚           KEEP(*(.limine_requests))
    â”‚   â”‚       â”‚           KEEP(*(.limine_requests_end))
    â”‚   â”‚       â”‚       } :limine_requests
    â”‚   â”‚       â”‚   
    â”‚   â”‚       â”‚       . = ALIGN(CONSTANT(MAXPAGESIZE));
    â”‚   â”‚       â”‚   
    â”‚   â”‚       â”‚       .text : {
    â”‚   â”‚       â”‚           *(.text .text.*)
    â”‚   â”‚       â”‚       } :text
    â”‚   â”‚       â”‚   
    â”‚   â”‚       â”‚       . = ALIGN(CONSTANT(MAXPAGESIZE));
    â”‚   â”‚       â”‚   
    â”‚   â”‚       â”‚       .rodata : {
    â”‚   â”‚       â”‚           *(.rodata .rodata.*)
    â”‚   â”‚       â”‚       } :rodata
    â”‚   â”‚       â”‚   
    â”‚   â”‚       â”‚       .note.gnu.build-id : {
    â”‚   â”‚       â”‚           *(.note.gnu.build-id)
    â”‚   â”‚       â”‚       } :rodata
    â”‚   â”‚       â”‚   
    â”‚   â”‚       â”‚       . = ALIGN(CONSTANT(MAXPAGESIZE));
    â”‚   â”‚       â”‚   
    â”‚   â”‚       â”‚       .data : {
    â”‚   â”‚       â”‚           *(.data .data.*)
    â”‚   â”‚       â”‚       } :data
    â”‚   â”‚       â”‚   
    â”‚   â”‚       â”‚       .bss : {
    â”‚   â”‚       â”‚           *(.bss .bss.*)
    â”‚   â”‚       â”‚           *(COMMON)
    â”‚   â”‚       â”‚       } :data
    â”‚   â”‚       â”‚   
    â”‚   â”‚       â”‚       /DISCARD/ : {
    â”‚   â”‚       â”‚           *(.eh_frame*)
    â”‚   â”‚       â”‚           *(.note .note.*)
    â”‚   â”‚       â”‚       }
    â”‚   â”‚       â”‚   }
    â”‚   â”‚       â”‚
    â”‚   â”œâ”€â”€ obj-x86_64
    â”‚       â””â”€â”€ <ÑĞºÑ€Ñ‹Ñ‚Ğ¾: ÑĞ¸ÑÑ‚ĞµĞ¼Ğ½Ğ°Ñ/Ğ±Ğ¸Ğ½Ğ°Ñ€Ğ½Ğ°Ñ Ğ´Ğ¸Ñ€ĞµĞºÑ‚Ğ¾Ñ€Ğ¸Ñ>
    â”‚   â””â”€â”€ src
    â”‚       â”œâ”€â”€ drivers
    â”‚       â”‚   â”œâ”€â”€ pic.c
    â”‚       â”‚       â”‚
    â”‚       â”‚       â”œâ”€â”€ CONTENT:
    â”‚       â”‚       â”‚   #include "include/drivers/pic.h"
    â”‚       â”‚       â”‚   #include "include/drivers/io.h"
    â”‚       â”‚       â”‚   #include "include/drivers/serial.h"
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   void pic_remap(void) {
    â”‚       â”‚       â”‚       serial_puts("[PIC] Remapping PIC...\n");
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ Ğ¼Ğ°ÑĞºĞ¸
    â”‚       â”‚       â”‚       uint8_t pic1_mask = inb(PIC1_DATA);
    â”‚       â”‚       â”‚       uint8_t pic2_mask = inb(PIC2_DATA);
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // ICW1 - Ğ¸Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ
    â”‚       â”‚       â”‚       outb(PIC1_COMMAND, PIC_ICW1_INIT | PIC_ICW1_ICW4);
    â”‚       â”‚       â”‚       outb(PIC2_COMMAND, PIC_ICW1_INIT | PIC_ICW1_ICW4);
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // ICW2 - ÑĞ¼ĞµÑ‰ĞµĞ½Ğ¸Ñ
    â”‚       â”‚       â”‚       outb(PIC1_DATA, PIC1_OFFSET);   // IRQ 0-7 -> INT 32-39
    â”‚       â”‚       â”‚       outb(PIC2_DATA, PIC2_OFFSET);   // IRQ 8-15 -> INT 40-47
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // ICW3 - ĞºĞ°ÑĞºĞ°Ğ´Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ
    â”‚       â”‚       â”‚       outb(PIC1_DATA, 0x04);          // PIC1 Ğ¸Ğ¼ĞµĞµÑ‚ slave Ğ½Ğ° IRQ2
    â”‚       â”‚       â”‚       outb(PIC2_DATA, 0x02);          // PIC2 cascade identity
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // ICW4 - Ğ´Ğ¾Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ°Ñ Ğ¸Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ
    â”‚       â”‚       â”‚       outb(PIC1_DATA, PIC_ICW4_8086);
    â”‚       â”‚       â”‚       outb(PIC2_DATA, PIC_ICW4_8086);
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Ğ’Ğ¾ÑÑÑ‚Ğ°Ğ½Ğ°Ğ²Ğ»Ğ¸Ğ²Ğ°ĞµĞ¼ Ğ¼Ğ°ÑĞºĞ¸
    â”‚       â”‚       â”‚       outb(PIC1_DATA, pic1_mask);
    â”‚       â”‚       â”‚       outb(PIC2_DATA, pic2_mask);
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       serial_puts("[PIC] PIC remapped to 0x20-0x2F\n");
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   void pic_send_eoi(uint8_t irq) {
    â”‚       â”‚       â”‚       if (irq >= 8) {
    â”‚       â”‚       â”‚           outb(PIC2_COMMAND, PIC_EOI);
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       outb(PIC1_COMMAND, PIC_EOI);
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   void pic_disable(void) {
    â”‚       â”‚       â”‚       // ĞœĞ°ÑĞºĞ¸Ñ€ÑƒĞµĞ¼ Ğ²ÑĞµ IRQ
    â”‚       â”‚       â”‚       outb(PIC1_DATA, 0xFF);
    â”‚       â”‚       â”‚       outb(PIC2_DATA, 0xFF);
    â”‚       â”‚       â”‚       serial_puts("[PIC] PIC disabled\n");
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   void pic_mask_irq(uint8_t irq) {
    â”‚       â”‚       â”‚       uint16_t port;
    â”‚       â”‚       â”‚       uint8_t value;
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       if (irq < 8) {
    â”‚       â”‚       â”‚           port = PIC1_DATA;
    â”‚       â”‚       â”‚       } else {
    â”‚       â”‚       â”‚           port = PIC2_DATA;
    â”‚       â”‚       â”‚           irq -= 8;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       value = inb(port) | (1 << irq);
    â”‚       â”‚       â”‚       outb(port, value);
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   void pic_unmask_irq(uint8_t irq) {
    â”‚       â”‚       â”‚       uint16_t port;
    â”‚       â”‚       â”‚       uint8_t value;
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       if (irq < 8) {
    â”‚       â”‚       â”‚           port = PIC1_DATA;
    â”‚       â”‚       â”‚       } else {
    â”‚       â”‚       â”‚           port = PIC2_DATA;
    â”‚       â”‚       â”‚           irq -= 8;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       value = inb(port) & ~(1 << irq);
    â”‚       â”‚       â”‚       outb(port, value);
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚
    â”‚       â”‚   â”œâ”€â”€ pit.c
    â”‚       â”‚       â”‚
    â”‚       â”‚       â”œâ”€â”€ CONTENT:
    â”‚       â”‚       â”‚   #include "include/drivers/pit.h"
    â”‚       â”‚       â”‚   #include "include/drivers/io.h"
    â”‚       â”‚       â”‚   #include "include/drivers/serial.h"
    â”‚       â”‚       â”‚   #include "libc/string.h" 
    â”‚       â”‚       â”‚   #include "libc/stdio.h"
    â”‚       â”‚       â”‚   #include "include/graphics/fb.h"
    â”‚       â”‚       â”‚   #include "include/graphics/font.h"
    â”‚       â”‚       â”‚   #include "include/graphics/color.h"
    â”‚       â”‚       â”‚   #include <limine.h>
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   volatile uint64_t pit_ticks = 0;
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   void pit_init(void) {
    â”‚       â”‚       â”‚       serial_puts("[PIT] Initializing PIT...\n");
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Ğ£ÑÑ‚Ğ°Ğ½Ğ°Ğ²Ğ»Ğ¸Ğ²Ğ°ĞµĞ¼ Ñ‡Ğ°ÑÑ‚Ğ¾Ñ‚Ñƒ
    â”‚       â”‚       â”‚       pit_set_frequency(PIT_DIVIDER);
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       serial_puts("[PIT] PIT initialized at 1000 Hz\n");
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   void pit_set_frequency(uint32_t divider) {
    â”‚       â”‚       â”‚       uint32_t divisor = PIT_BASE_FREQ / divider;
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñƒ PIT
    â”‚       â”‚       â”‚       outb(PIT_COMMAND, PIT_CHANNEL0_SEL | PIT_ACCESS_LOHI | PIT_MODE3);
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Ğ£ÑÑ‚Ğ°Ğ½Ğ°Ğ²Ğ»Ğ¸Ğ²Ğ°ĞµĞ¼ Ğ´ĞµĞ»Ğ¸Ñ‚ĞµĞ»ÑŒ
    â”‚       â”‚       â”‚       outb(PIT_CHANNEL0, divisor & 0xFF);
    â”‚       â”‚       â”‚       outb(PIT_CHANNEL0, (divisor >> 8) & 0xFF);
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   uint64_t pit_get_ticks(void) {
    â”‚       â”‚       â”‚       return pit_ticks;
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   void pit_sleep(uint64_t ms) {
    â”‚       â”‚       â”‚       uint64_t target_ticks = pit_ticks + ms;
    â”‚       â”‚       â”‚       while (pit_ticks < target_ticks) {
    â”‚       â”‚       â”‚           asm volatile("hlt");
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   // ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº Ğ¿Ñ€ĞµÑ€Ñ‹Ğ²Ğ°Ğ½Ğ¸Ñ Ñ‚Ğ°Ğ¹Ğ¼ĞµÑ€Ğ°
    â”‚       â”‚       â”‚   void pit_timer_handler(struct registers *regs) {
    â”‚       â”‚       â”‚       (void)regs; 
    â”‚       â”‚       â”‚       pit_ticks++;
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚
    â”‚       â”‚   â””â”€â”€ serial.c
    â”‚       â”‚       â”‚
    â”‚       â”‚       â”œâ”€â”€ CONTENT:
    â”‚       â”‚       â”‚   #include <stdint.h>
    â”‚       â”‚       â”‚   #include <stddef.h>
    â”‚       â”‚       â”‚   #include "../include/drivers/io.h"
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   #define SERIAL_PORT 0x3F8  // COM1
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   static int is_initialized = 0;
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   void serial_init(void) {
    â”‚       â”‚       â”‚       if (is_initialized) return;
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚       // ĞÑ‚ĞºĞ»ÑÑ‡Ğ°ĞµĞ¼ Ğ¿Ñ€ĞµÑ€Ñ‹Ğ²Ğ°Ğ½Ğ¸Ñ
    â”‚       â”‚       â”‚       outb(SERIAL_PORT + 1, 0x00);
    â”‚       â”‚       â”‚       // Ğ£ÑÑ‚Ğ°Ğ½Ğ°Ğ²Ğ»Ğ¸Ğ²Ğ°ĞµĞ¼ ÑĞºĞ¾Ñ€Ğ¾ÑÑ‚ÑŒ: Divisor Latch Access Bit (DLAB)
    â”‚       â”‚       â”‚       outb(SERIAL_PORT + 3, 0x80);
    â”‚       â”‚       â”‚       // Ğ”ĞµĞ»Ğ¸Ñ‚ĞµĞ»ÑŒ ÑĞºĞ¾Ñ€Ğ¾ÑÑ‚Ğ¸: 115200 / 115200 = 1 (ÑĞºĞ¾Ñ€Ğ¾ÑÑ‚ÑŒ: 115200)
    â”‚       â”‚       â”‚       outb(SERIAL_PORT + 0, 0x01);
    â”‚       â”‚       â”‚       outb(SERIAL_PORT + 1, 0x00);
    â”‚       â”‚       â”‚       // 8 Ğ±Ğ¸Ñ‚ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…, Ğ½ĞµÑ‚ Ñ‡Ñ‘Ñ‚Ğ½Ğ¾ÑÑ‚Ğ¸, 1 ÑÑ‚Ğ¾Ğ¿-Ğ±Ğ¸Ñ‚
    â”‚       â”‚       â”‚       outb(SERIAL_PORT + 3, 0x03);
    â”‚       â”‚       â”‚       // Ğ’ĞºĞ»ÑÑ‡Ğ°ĞµĞ¼ FIFO, Ğ¾Ñ‡Ğ¸Ñ‰Ğ°ĞµĞ¼ Ğ±ÑƒÑ„ĞµÑ€Ñ‹
    â”‚       â”‚       â”‚       outb(SERIAL_PORT + 2, 0xC7);
    â”‚       â”‚       â”‚       // IRQs enabled, RTS/DSR set
    â”‚       â”‚       â”‚       outb(SERIAL_PORT + 4, 0x0B);
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚       is_initialized = 1;
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   // Ğ–Ğ´Ñ‘Ğ¼, Ğ¿Ğ¾ĞºĞ° Ğ¿Ğ¾Ñ€Ñ‚ Ğ±ÑƒĞ´ĞµÑ‚ Ğ³Ğ¾Ñ‚Ğ¾Ğ² Ğº Ğ¿ĞµÑ€ĞµĞ´Ğ°Ñ‡Ğµ
    â”‚       â”‚       â”‚   static void serial_wait_ready(void) {
    â”‚       â”‚       â”‚       while ((inb(SERIAL_PORT + 5) & 0x20) == 0);
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   // ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ¾Ğ´Ğ¸Ğ½ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»
    â”‚       â”‚       â”‚   void serial_putc(char c) {
    â”‚       â”‚       â”‚       if (!is_initialized) serial_init();
    â”‚       â”‚       â”‚       if (c == '\n') {
    â”‚       â”‚       â”‚           serial_putc('\r');  // \n â†’ \r\n
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       serial_wait_ready();
    â”‚       â”‚       â”‚       outb(SERIAL_PORT, c);
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   // ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ÑŒ ÑÑ‚Ñ€Ğ¾ĞºÑƒ
    â”‚       â”‚       â”‚   void serial_puts(const char *str) {
    â”‚       â”‚       â”‚       while (*str) {
    â”‚       â”‚       â”‚           serial_putc(*str++);
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚
    â”‚       â”œâ”€â”€ font.psf
    â”‚       â”œâ”€â”€ graphics
    â”‚       â”‚   â”œâ”€â”€ banner.c
    â”‚       â”‚       â”‚
    â”‚       â”‚       â”œâ”€â”€ CONTENT:
    â”‚       â”‚       â”‚   #include <stdint.h>
    â”‚       â”‚       â”‚   #include <limine.h>
    â”‚       â”‚       â”‚   #include "../include/graphics/fb.h"
    â”‚       â”‚       â”‚   #include "../include/graphics/font.h"
    â”‚       â”‚       â”‚   #include "../include/graphics/banner.h"
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   void draw_deer_banner(struct limine_framebuffer *fb, uint32_t x, uint32_t y, uint32_t color) {
    â”‚       â”‚       â”‚       const char *banner_lines[] = {
    â”‚       â”‚       â”‚           "                                                                                   ",
    â”‚       â”‚       â”‚           "                                                                                   ",
    â”‚       â”‚       â”‚           "DDDDDDDDDDDDD      EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEERRRRRRRRRRRRRRRRR   ",
    â”‚       â”‚       â”‚           "D::::::::::::DDD   E::::::::::::::::::::EE::::::::::::::::::::ER::::::::::::::::R  ",
    â”‚       â”‚       â”‚           "D:::::::::::::::DD E::::::::::::::::::::EE::::::::::::::::::::ER::::::RRRRRR:::::R ",
    â”‚       â”‚       â”‚           "DDD:::::DDDDD:::::DEE::::::EEEEEEEEE::::EEE::::::EEEEEEEEE::::ERR:::::R     R:::::R",
    â”‚       â”‚       â”‚           "  D:::::D    D:::::D E:::::E       EEEEEE  E:::::E       EEEEEE  R::::R     R:::::R",
    â”‚       â”‚       â”‚           "  D:::::D     D:::::DE:::::E               E:::::E               R::::R     R:::::R",
    â”‚       â”‚       â”‚           "  D:::::D     D:::::DE::::::EEEEEEEEEE     E::::::EEEEEEEEEE     R::::RRRRRR:::::R ",
    â”‚       â”‚       â”‚           "  D:::::D     D:::::DE:::::::::::::::E     E:::::::::::::::E     R:::::::::::::RR  ",
    â”‚       â”‚       â”‚           "  D:::::D     D:::::DE:::::::::::::::E     E:::::::::::::::E     R::::RRRRRR:::::R ",
    â”‚       â”‚       â”‚           "  D:::::D     D:::::DE::::::EEEEEEEEEE     E::::::EEEEEEEEEE     R::::R     R:::::R",
    â”‚       â”‚       â”‚           "  D:::::D     D:::::DE:::::E               E:::::E               R::::R     R:::::R",
    â”‚       â”‚       â”‚           "  D:::::D    D:::::D E:::::E       EEEEEE  E:::::E       EEEEEE  R::::R     R:::::R",
    â”‚       â”‚       â”‚           "DDD:::::DDDDD:::::DEE::::::EEEEEEEE:::::EEE::::::EEEEEEEE:::::ERR:::::R     R:::::R",
    â”‚       â”‚       â”‚           "D:::::::::::::::DD E::::::::::::::::::::EE::::::::::::::::::::ER::::::R     R:::::R",
    â”‚       â”‚       â”‚           "D::::::::::::DDD   E::::::::::::::::::::EE::::::::::::::::::::ER::::::R     R:::::R",
    â”‚       â”‚       â”‚           "DDDDDDDDDDDDD      EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEERRRRRRRR     RRRRRRR",
    â”‚       â”‚       â”‚           "                                                                                   ",
    â”‚       â”‚       â”‚           "                                                                                   ",
    â”‚       â”‚       â”‚           "                                                                                   ",
    â”‚       â”‚       â”‚           "                                                                                   ",
    â”‚       â”‚       â”‚           "                                                                                   ",
    â”‚       â”‚       â”‚           "                                                                                   ",
    â”‚       â”‚       â”‚           "                                                                                   "
    â”‚       â”‚       â”‚       };
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       uint32_t current_y = y;
    â”‚       â”‚       â”‚       for (int i = 0; i < 25; i++) {
    â”‚       â”‚       â”‚           fb_draw_string(fb, banner_lines[i], x, current_y, color);
    â”‚       â”‚       â”‚           current_y += 16; // ĞŸĞµÑ€ĞµÑ…Ğ¾Ğ´ Ğ½Ğ° ÑĞ»ĞµĞ´ÑƒÑÑ‰ÑƒÑ ÑÑ‚Ñ€Ğ¾ĞºÑƒ (Ğ²Ñ‹ÑĞ¾Ñ‚Ğ° ÑˆÑ€Ğ¸Ñ„Ñ‚Ğ°)
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚
    â”‚       â”‚   â””â”€â”€ fb.c
    â”‚       â”‚       â”‚
    â”‚       â”‚       â”œâ”€â”€ CONTENT:
    â”‚       â”‚       â”‚   #include <stdint.h>
    â”‚       â”‚       â”‚   #include <stddef.h>
    â”‚       â”‚       â”‚   #include <limine.h>
    â”‚       â”‚       â”‚   #include "../include/graphics/fb.h"
    â”‚       â”‚       â”‚   #include "../include/graphics/font.h"
    â”‚       â”‚       â”‚   #include "../include/graphics/color.h"
    â”‚       â”‚       â”‚   #include "../libc/string.h"
    â”‚       â”‚       â”‚   #include "../include/drivers/serial.h"
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   void fb_draw_pixel(struct limine_framebuffer *fb, uint32_t x, uint32_t y, uint32_t color) {
    â”‚       â”‚       â”‚       if (x >= fb->width || y >= fb->height) return;
    â”‚       â”‚       â”‚       uint32_t *fb_ptr = (uint32_t *)fb->address;
    â”‚       â”‚       â”‚       uint32_t pitch = fb->pitch / 4;
    â”‚       â”‚       â”‚       fb_ptr[y * pitch + x] = color;
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   void fb_fill_rect(struct limine_framebuffer *fb, uint32_t x, uint32_t y, uint32_t w, uint32_t h, uint32_t color) {
    â”‚       â”‚       â”‚       for (uint32_t py = y; py < y + h; py++) {
    â”‚       â”‚       â”‚           for (uint32_t px = x; px < x + w; px++) {
    â”‚       â”‚       â”‚               fb_draw_pixel(fb, px, py, color);
    â”‚       â”‚       â”‚           }
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   void fb_clear(struct limine_framebuffer *fb, uint32_t color) {
    â”‚       â”‚       â”‚       uint32_t *fb_ptr = (uint32_t *)fb->address;
    â”‚       â”‚       â”‚       size_t pixels = fb->width * fb->height;
    â”‚       â”‚       â”‚       for (size_t i = 0; i < pixels; i++) {
    â”‚       â”‚       â”‚           fb_ptr[i] = color;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   int psf_validate(void) {
    â”‚       â”‚       â”‚       const uint8_t *raw = get_font_data();
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ´Ğ»Ñ PSF v2
    â”‚       â”‚       â”‚       if (raw[0] == 0x72 && raw[1] == 0xb5 && 
    â”‚       â”‚       â”‚           raw[2] == 0x4a && raw[3] == 0x86) {
    â”‚       â”‚       â”‚           return 2; // PSF v2
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ´Ğ»Ñ PSF v1
    â”‚       â”‚       â”‚       if (raw[0] == 0x36 && raw[1] == 0x04) {
    â”‚       â”‚       â”‚           return 1; // PSF v1
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       return 0; // ĞĞµĞ²Ğ°Ğ»Ğ¸Ğ´Ğ½Ñ‹Ğ¹ ÑˆÑ€Ğ¸Ñ„Ñ‚
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   void fb_draw_char(struct limine_framebuffer *fb, char c, uint32_t x, uint32_t y, uint32_t color) {
    â”‚       â”‚       â”‚       const uint8_t *raw = get_font_data();
    â”‚       â”‚       â”‚       uint32_t headersize = 32;
    â”‚       â”‚       â”‚       uint32_t charsiz = *(uint32_t*)(raw + 20);
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       uint8_t *glyphs = (uint8_t*)raw + headersize;
    â”‚       â”‚       â”‚       uint32_t glyph_index;
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ñ€Ğ°Ğ·Ğ½Ñ‹Ñ… Ğ´Ğ¸Ğ°Ğ¿Ğ°Ğ·Ğ¾Ğ½Ğ¾Ğ² ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ¾Ğ²
    â”‚       â”‚       â”‚       if ((uint8_t)c < 128) {
    â”‚       â”‚       â”‚           // Basic ASCII - Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°ÑÑ‚ Ğ¾Ñ‚Ğ»Ğ¸Ñ‡Ğ½Ğ¾!
    â”‚       â”‚       â”‚           glyph_index = (uint8_t)c;
    â”‚       â”‚       â”‚       } else if ((uint8_t)c >= 128) {
    â”‚       â”‚       â”‚           glyph_index = '?'; 
    â”‚       â”‚       â”‚       } else {
    â”‚       â”‚       â”‚           glyph_index = '?'; 
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ†
    â”‚       â”‚       â”‚       if (glyph_index >= 512) {
    â”‚       â”‚       â”‚           glyph_index = '?';
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       uint8_t *glyph = &glyphs[glyph_index * charsiz];
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚       // ĞÑ‚Ñ€Ğ¸ÑĞ¾Ğ²ĞºĞ°
    â”‚       â”‚       â”‚       for (uint32_t row = 0; row < 16; row++) {
    â”‚       â”‚       â”‚           uint8_t byte = glyph[row];
    â”‚       â”‚       â”‚           for (uint32_t col = 0; col < 8; col++) {
    â”‚       â”‚       â”‚               if (byte & (0x80 >> col)) {
    â”‚       â”‚       â”‚                   fb_draw_pixel(fb, x + col, y + row, color);
    â”‚       â”‚       â”‚               }
    â”‚       â”‚       â”‚           }
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   void fb_draw_string(struct limine_framebuffer *fb, const char *str, uint32_t x, uint32_t y, uint32_t color) {
    â”‚       â”‚       â”‚       uint32_t orig_x = x;
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚       if (!psf_validate()) return;
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚       while (*str) {
    â”‚       â”‚       â”‚           if (*str == '\n') {
    â”‚       â”‚       â”‚               x = orig_x;
    â”‚       â”‚       â”‚               y += 16;
    â”‚       â”‚       â”‚           } else {
    â”‚       â”‚       â”‚               fb_draw_char(fb, *str, x, y, color);
    â”‚       â”‚       â”‚               x += 8;
    â”‚       â”‚       â”‚           }
    â”‚       â”‚       â”‚           str++;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚
    â”‚       â”œâ”€â”€ include
    â”‚       â”‚   â”œâ”€â”€ drivers
    â”‚       â”‚   â”‚   â”œâ”€â”€ io.h
    â”‚       â”‚   â”‚       â”‚
    â”‚       â”‚   â”‚       â”œâ”€â”€ CONTENT:
    â”‚       â”‚   â”‚       â”‚   #ifndef IO_H
    â”‚       â”‚   â”‚       â”‚   #define IO_H
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   #include <stdint.h>
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   static inline uint8_t inb(uint16_t port) {
    â”‚       â”‚   â”‚       â”‚       uint8_t ret;
    â”‚       â”‚   â”‚       â”‚       asm volatile ("inb %1, %0" : "=a"(ret) : "Nd"(port));
    â”‚       â”‚   â”‚       â”‚       return ret;
    â”‚       â”‚   â”‚       â”‚   }
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   static inline void outb(uint16_t port, uint8_t val) {
    â”‚       â”‚   â”‚       â”‚       asm volatile ("outb %0, %1" : : "a"(val), "Nd"(port));
    â”‚       â”‚   â”‚       â”‚   }
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   #endif // IO_H
    â”‚       â”‚   â”‚       â”‚
    â”‚       â”‚   â”‚   â”œâ”€â”€ pic.h
    â”‚       â”‚   â”‚       â”‚
    â”‚       â”‚   â”‚       â”œâ”€â”€ CONTENT:
    â”‚       â”‚   â”‚       â”‚   #ifndef PIC_H
    â”‚       â”‚   â”‚       â”‚   #define PIC_H
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   #include <stdint.h>
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   // ĞŸĞ¾Ñ€Ñ‚Ñ‹ PIC
    â”‚       â”‚   â”‚       â”‚   #define PIC1_COMMAND    0x20
    â”‚       â”‚   â”‚       â”‚   #define PIC1_DATA       0x21
    â”‚       â”‚   â”‚       â”‚   #define PIC2_COMMAND    0xA0
    â”‚       â”‚   â”‚       â”‚   #define PIC2_DATA       0xA1
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   // ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹ PIC
    â”‚       â”‚   â”‚       â”‚   #define PIC_EOI         0x20        // End Of Interrupt
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   // ICW1
    â”‚       â”‚   â”‚       â”‚   #define PIC_ICW1_INIT   0x10        // Initialization
    â”‚       â”‚   â”‚       â”‚   #define PIC_ICW1_ICW4   0x01        // ICW4 needed
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   // ICW4
    â”‚       â”‚   â”‚       â”‚   #define PIC_ICW4_8086   0x01        // 8086 mode
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   // IRQ Ğ±Ğ°Ğ·Ğ¾Ğ²Ñ‹Ğµ Ğ²ĞµĞºÑ‚Ğ¾Ñ€Ñ‹
    â”‚       â”‚   â”‚       â”‚   #define PIC1_OFFSET     0x20
    â”‚       â”‚   â”‚       â”‚   #define PIC2_OFFSET     0x28
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   // Ğ¤ÑƒĞ½ĞºÑ†Ğ¸Ğ¸
    â”‚       â”‚   â”‚       â”‚   void pic_remap(void);
    â”‚       â”‚   â”‚       â”‚   void pic_send_eoi(uint8_t irq);
    â”‚       â”‚   â”‚       â”‚   void pic_disable(void);
    â”‚       â”‚   â”‚       â”‚   void pic_mask_irq(uint8_t irq);
    â”‚       â”‚   â”‚       â”‚   void pic_unmask_irq(uint8_t irq);
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   #endif // PIC_H
    â”‚       â”‚   â”‚       â”‚
    â”‚       â”‚   â”‚   â”œâ”€â”€ pit.h
    â”‚       â”‚   â”‚       â”‚
    â”‚       â”‚   â”‚       â”œâ”€â”€ CONTENT:
    â”‚       â”‚   â”‚       â”‚   #ifndef PIT_H
    â”‚       â”‚   â”‚       â”‚   #define PIT_H
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   #include <stdint.h>
    â”‚       â”‚   â”‚       â”‚   #include "../interrupts/isr.h"
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   // ĞŸĞ¾Ñ€Ñ‚Ñ‹ PIT (Programmable Interval Timer)
    â”‚       â”‚   â”‚       â”‚   #define PIT_CHANNEL0    0x40
    â”‚       â”‚   â”‚       â”‚   #define PIT_CHANNEL1    0x41
    â”‚       â”‚   â”‚       â”‚   #define PIT_CHANNEL2    0x42
    â”‚       â”‚   â”‚       â”‚   #define PIT_COMMAND     0x43
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   // ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹ PIT
    â”‚       â”‚   â”‚       â”‚   #define PIT_CHANNEL0_SEL    0x00
    â”‚       â”‚   â”‚       â”‚   #define PIT_ACCESS_LOHI     0x30    // Access mode: low then high byte
    â”‚       â”‚   â”‚       â”‚   #define PIT_MODE3           0x06    // Mode 3: square wave generator
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   // Ğ§Ğ°ÑÑ‚Ğ¾Ñ‚Ğ° PIT
    â”‚       â”‚   â”‚       â”‚   #define PIT_BASE_FREQ       1193182
    â”‚       â”‚   â”‚       â”‚   #define PIT_DIVIDER         1000    // 1000 Hz = 1 ms
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   extern volatile uint64_t pit_ticks;
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   // Ğ¤ÑƒĞ½ĞºÑ†Ğ¸Ğ¸
    â”‚       â”‚   â”‚       â”‚   void pit_init(void);
    â”‚       â”‚   â”‚       â”‚   void pit_set_frequency(uint32_t freq);
    â”‚       â”‚   â”‚       â”‚   uint64_t pit_get_ticks(void);
    â”‚       â”‚   â”‚       â”‚   void pit_sleep(uint64_t ms);
    â”‚       â”‚   â”‚       â”‚   void pit_timer_handler(struct registers *regs);
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   #endif // PIT_H
    â”‚       â”‚   â”‚       â”‚
    â”‚       â”‚   â”‚   â””â”€â”€ serial.h
    â”‚       â”‚   â”‚       â”‚
    â”‚       â”‚   â”‚       â”œâ”€â”€ CONTENT:
    â”‚       â”‚   â”‚       â”‚   #ifndef SERIAL_H
    â”‚       â”‚   â”‚       â”‚   #define SERIAL_H
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   #include <stdint.h>
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   void serial_init(void);
    â”‚       â”‚   â”‚       â”‚   void serial_putc(char c);
    â”‚       â”‚   â”‚       â”‚   void serial_puts(const char *str);
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   #endif // SERIAL_H
    â”‚       â”‚   â”‚       â”‚
    â”‚       â”‚   â”œâ”€â”€ graphics
    â”‚       â”‚   â”‚   â”œâ”€â”€ banner.h
    â”‚       â”‚   â”‚       â”‚
    â”‚       â”‚   â”‚       â”œâ”€â”€ CONTENT:
    â”‚       â”‚   â”‚       â”‚   #ifndef BANNER_H
    â”‚       â”‚   â”‚       â”‚   #define BANNER_H
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   #include <stdint.h>
    â”‚       â”‚   â”‚       â”‚   #include <limine.h>
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   void draw_deer_banner(struct limine_framebuffer *fb, uint32_t x, uint32_t y, uint32_t color);
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   #endif // BANNER_H
    â”‚       â”‚   â”‚       â”‚
    â”‚       â”‚   â”‚   â”œâ”€â”€ color.h
    â”‚       â”‚   â”‚       â”‚
    â”‚       â”‚   â”‚       â”œâ”€â”€ CONTENT:
    â”‚       â”‚   â”‚       â”‚   // kernel/include/graphics/color.h
    â”‚       â”‚   â”‚       â”‚   #ifndef COLOR_H
    â”‚       â”‚   â”‚       â”‚   #define COLOR_H
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   #include <stdint.h>
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   #define RGB(r, g, b) (((r) << 16) | ((g) << 8) | (b))
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   #define COLOR_BLACK     RGB(  0,   0,   0)
    â”‚       â”‚   â”‚       â”‚   #define COLOR_WHITE     RGB(255, 255, 255)
    â”‚       â”‚   â”‚       â”‚   #define COLOR_RED       RGB(255,   0,   0)
    â”‚       â”‚   â”‚       â”‚   #define COLOR_GREEN     RGB(  0, 255,   0)
    â”‚       â”‚   â”‚       â”‚   #define COLOR_BLUE      RGB(  0,   0, 255)
    â”‚       â”‚   â”‚       â”‚   #define COLOR_CYAN      RGB(  0, 255, 255)
    â”‚       â”‚   â”‚       â”‚   #define COLOR_MAGENTA   RGB(255,   0, 255)
    â”‚       â”‚   â”‚       â”‚   #define COLOR_YELLOW    RGB(255, 255,   0)
    â”‚       â”‚   â”‚       â”‚   #define COLOR_ORANGE    RGB(255, 165,   0)
    â”‚       â”‚   â”‚       â”‚   #define COLOR_GRAY      RGB(128, 128, 128)
    â”‚       â”‚   â”‚       â”‚   #define COLOR_DARKGRAY  RGB( 64,  64,  64)
    â”‚       â”‚   â”‚       â”‚   #define COLOR_BROWN     RGB(165,  42,  42)
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   #endif // COLOR_H
    â”‚       â”‚   â”‚       â”‚
    â”‚       â”‚   â”‚   â”œâ”€â”€ fb.h
    â”‚       â”‚   â”‚       â”‚
    â”‚       â”‚   â”‚       â”œâ”€â”€ CONTENT:
    â”‚       â”‚   â”‚       â”‚   #ifndef FB_H
    â”‚       â”‚   â”‚       â”‚   #define FB_H
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   #include <stdint.h>
    â”‚       â”‚   â”‚       â”‚   #include <limine.h>
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   void fb_draw_pixel(struct limine_framebuffer *fb, uint32_t x, uint32_t y, uint32_t color);
    â”‚       â”‚   â”‚       â”‚   void fb_fill_rect(struct limine_framebuffer *fb, uint32_t x, uint32_t y, uint32_t w, uint32_t h, uint32_t color);
    â”‚       â”‚   â”‚       â”‚   void fb_clear(struct limine_framebuffer *fb, uint32_t color);
    â”‚       â”‚   â”‚       â”‚   #endif // FB_H
    â”‚       â”‚   â”‚       â”‚
    â”‚       â”‚   â”‚   â””â”€â”€ font.h
    â”‚       â”‚   â”‚       â”‚
    â”‚       â”‚   â”‚       â”œâ”€â”€ CONTENT:
    â”‚       â”‚   â”‚       â”‚   // kernel/include/graphics/font.h
    â”‚       â”‚   â”‚       â”‚   #ifndef FONT_H
    â”‚       â”‚   â”‚       â”‚   #define FONT_H
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   #include <stdint.h>
    â”‚       â”‚   â”‚       â”‚   #include <stddef.h>
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   // Ğ¡Ñ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ° Ğ·Ğ°Ğ³Ğ¾Ğ»Ğ¾Ğ²ĞºĞ° PSFv2
    â”‚       â”‚   â”‚       â”‚   struct psf_header {
    â”‚       â”‚   â”‚       â”‚       uint32_t magic;        // 0x72b54a86
    â”‚       â”‚   â”‚       â”‚       uint32_t version;      // 0
    â”‚       â”‚   â”‚       â”‚       uint32_t headersize;   // 32
    â”‚       â”‚   â”‚       â”‚       uint32_t flags;        // 0 Ğ¸Ğ»Ğ¸ 1 (ĞµÑÑ‚ÑŒ Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ğ° Unicode)
    â”‚       â”‚   â”‚       â”‚       uint32_t numglyph;     // Ñ‡Ğ¸ÑĞ»Ğ¾ Ğ³Ğ»Ğ¸Ñ„Ğ¾Ğ²
    â”‚       â”‚   â”‚       â”‚       uint32_t bytesperglyph;// Ñ€Ğ°Ğ·Ğ¼ĞµÑ€ Ğ¾Ğ´Ğ½Ğ¾Ğ³Ğ¾ Ğ³Ğ»Ğ¸Ñ„Ğ°
    â”‚       â”‚   â”‚       â”‚       uint32_t height;       // Ğ²Ñ‹ÑĞ¾Ñ‚Ğ° ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ°
    â”‚       â”‚   â”‚       â”‚       uint32_t width;        // ÑˆĞ¸Ñ€Ğ¸Ğ½Ğ° ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ° (Ğ¾Ğ±Ñ‹Ñ‡Ğ½Ğ¾ 8)
    â”‚       â”‚   â”‚       â”‚   } __attribute__((packed));
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   // Ğ’Ğ½ĞµÑˆĞ½Ğ¸Ğµ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ñ‹, ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ½Ñ‹Ğµ objcopy â€” Ğ¾Ğ±ÑŠÑĞ²Ğ»ÑĞµĞ¼ ĞºĞ°Ğº uint8_t Ğ´Ğ»Ñ ÑÑĞ½Ğ¾ÑÑ‚Ğ¸
    â”‚       â”‚   â”‚       â”‚   extern uint8_t _binary_font_psf_start[];
    â”‚       â”‚   â”‚       â”‚   extern uint8_t _binary_font_psf_end[];
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   // ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ ÑƒĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»ÑŒ Ğ½Ğ° Ğ½Ğ°Ñ‡Ğ°Ğ»Ğ¾ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ… ÑˆÑ€Ğ¸Ñ„Ñ‚Ğ°
    â”‚       â”‚   â”‚       â”‚   static inline const uint8_t* get_font_data(void) {
    â”‚       â”‚   â”‚       â”‚       return (const uint8_t*)&_binary_font_psf_start;
    â”‚       â”‚   â”‚       â”‚   }
    â”‚       â”‚   â”‚       â”‚   static inline size_t get_font_data_size(void) {
    â”‚       â”‚   â”‚       â”‚       return _binary_font_psf_end - _binary_font_psf_start;
    â”‚       â”‚   â”‚       â”‚   }
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   // ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ğ·Ğ°Ğ³Ğ¾Ğ»Ğ¾Ğ²Ğ¾Ğº ÑˆÑ€Ğ¸Ñ„Ñ‚Ğ°
    â”‚       â”‚   â”‚       â”‚   static inline const struct psf_header* get_psf_header(void) {
    â”‚       â”‚   â”‚       â”‚       return (const struct psf_header*)&_binary_font_psf_start;
    â”‚       â”‚   â”‚       â”‚   }
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   // ĞŸÑ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ, Ñ‡Ñ‚Ğ¾ ÑˆÑ€Ğ¸Ñ„Ñ‚ ĞºĞ¾Ñ€Ñ€ĞµĞºÑ‚ĞµĞ½
    â”‚       â”‚   â”‚       â”‚   int psf_validate(void) ;
    â”‚       â”‚   â”‚       â”‚   // ĞÑ‚Ñ€Ğ¸ÑĞ¾Ğ²ĞºĞ° ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ°
    â”‚       â”‚   â”‚       â”‚   void fb_draw_char(struct limine_framebuffer *fb, char c, uint32_t x, uint32_t y, uint32_t color);
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   // ĞÑ‚Ñ€Ğ¸ÑĞ¾Ğ²ĞºĞ° ÑÑ‚Ñ€Ğ¾ĞºĞ¸
    â”‚       â”‚   â”‚       â”‚   void fb_draw_string(struct limine_framebuffer *fb, const char *str, uint32_t x, uint32_t y, uint32_t color);
    â”‚       â”‚   â”‚       â”‚   #endif // FONT_H
    â”‚       â”‚   â”‚       â”‚
    â”‚       â”‚   â”œâ”€â”€ interrupts
    â”‚       â”‚   â”‚   â”œâ”€â”€ idt.h
    â”‚       â”‚   â”‚       â”‚
    â”‚       â”‚   â”‚       â”œâ”€â”€ CONTENT:
    â”‚       â”‚   â”‚       â”‚   #ifndef IDT_H
    â”‚       â”‚   â”‚       â”‚   #define IDT_H
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   #include <stdint.h>
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   // Ğ¡Ñ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ° Ğ´ĞµÑĞºÑ€Ğ¸Ğ¿Ñ‚Ğ¾Ñ€Ğ° IDT
    â”‚       â”‚   â”‚       â”‚   struct idt_entry {
    â”‚       â”‚   â”‚       â”‚       uint16_t base_low;
    â”‚       â”‚   â”‚       â”‚       uint16_t selector;
    â”‚       â”‚   â”‚       â”‚       uint8_t ist;
    â”‚       â”‚   â”‚       â”‚       uint8_t type_attr;
    â”‚       â”‚   â”‚       â”‚       uint16_t base_middle;
    â”‚       â”‚   â”‚       â”‚       uint32_t base_high;
    â”‚       â”‚   â”‚       â”‚       uint32_t zero;
    â”‚       â”‚   â”‚       â”‚   } __attribute__((packed));
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   // Ğ¡Ñ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ° ÑƒĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»Ñ IDT
    â”‚       â”‚   â”‚       â”‚   struct idt_ptr {
    â”‚       â”‚   â”‚       â”‚       uint16_t limit;
    â”‚       â”‚   â”‚       â”‚       uint64_t base;
    â”‚       â”‚   â”‚       â”‚   } __attribute__((packed));
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   // ĞÑ‚Ñ€Ğ¸Ğ±ÑƒÑ‚Ñ‹ Ğ´ĞµÑĞºÑ€Ğ¸Ğ¿Ñ‚Ğ¾Ñ€Ğ° IDT
    â”‚       â”‚   â”‚       â”‚   #define IDT_PRESENT     (1 << 7)
    â”‚       â”‚   â”‚       â”‚   #define IDT_RING0       (0 << 5)
    â”‚       â”‚   â”‚       â”‚   #define IDT_RING3       (3 << 5)
    â”‚       â”‚   â”‚       â”‚   #define IDT_TYPE_INT    0x0E    // 32-bit interrupt gate
    â”‚       â”‚   â”‚       â”‚   #define IDT_TYPE_TRAP   0x0F    // 32-bit trap gate
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   // Ğ˜ÑĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ñ x86_64
    â”‚       â”‚   â”‚       â”‚   #define EXCEPTION_DIVISION_ERROR        0
    â”‚       â”‚   â”‚       â”‚   #define EXCEPTION_DEBUG                 1
    â”‚       â”‚   â”‚       â”‚   #define EXCEPTION_NMI                   2
    â”‚       â”‚   â”‚       â”‚   #define EXCEPTION_BREAKPOINT            3
    â”‚       â”‚   â”‚       â”‚   #define EXCEPTION_OVERFLOW              4
    â”‚       â”‚   â”‚       â”‚   #define EXCEPTION_BOUND_RANGE           5
    â”‚       â”‚   â”‚       â”‚   #define EXCEPTION_INVALID_OPCODE        6
    â”‚       â”‚   â”‚       â”‚   #define EXCEPTION_DEVICE_NOT_AVAILABLE  7
    â”‚       â”‚   â”‚       â”‚   #define EXCEPTION_DOUBLE_FAULT          8
    â”‚       â”‚   â”‚       â”‚   #define EXCEPTION_COPROCESSOR_SEGMENT   9
    â”‚       â”‚   â”‚       â”‚   #define EXCEPTION_INVALID_TSS           10
    â”‚       â”‚   â”‚       â”‚   #define EXCEPTION_SEGMENT_NOT_PRESENT   11
    â”‚       â”‚   â”‚       â”‚   #define EXCEPTION_STACK_SEGMENT_FAULT   12
    â”‚       â”‚   â”‚       â”‚   #define EXCEPTION_GPF                   13
    â”‚       â”‚   â”‚       â”‚   #define EXCEPTION_PAGE_FAULT            14
    â”‚       â”‚   â”‚       â”‚   #define EXCEPTION_RESERVED              15
    â”‚       â”‚   â”‚       â”‚   #define EXCEPTION_X87_FPU               16
    â”‚       â”‚   â”‚       â”‚   #define EXCEPTION_ALIGNMENT_CHECK       17
    â”‚       â”‚   â”‚       â”‚   #define EXCEPTION_MACHINE_CHECK         18
    â”‚       â”‚   â”‚       â”‚   #define EXCEPTION_SIMD_FPU              19
    â”‚       â”‚   â”‚       â”‚   #define EXCEPTION_VIRTUALIZATION        20
    â”‚       â”‚   â”‚       â”‚   #define EXCEPTION_SECURITY              30
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   // Ğ¤ÑƒĞ½ĞºÑ†Ğ¸Ğ¸
    â”‚       â”‚   â”‚       â”‚   void idt_init(void);
    â”‚       â”‚   â”‚       â”‚   void idt_load(void);
    â”‚       â”‚   â”‚       â”‚   void idt_set_entry(uint8_t index, uint64_t base, uint16_t selector, uint8_t type_attr);
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   #endif // IDT_H
    â”‚       â”‚   â”‚       â”‚
    â”‚       â”‚   â”‚   â”œâ”€â”€ irq.h
    â”‚       â”‚   â”‚       â”‚
    â”‚       â”‚   â”‚       â”œâ”€â”€ CONTENT:
    â”‚       â”‚   â”‚       â”‚   #ifndef IRQ_H
    â”‚       â”‚   â”‚       â”‚   #define IRQ_H
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   #include <stdint.h>
    â”‚       â”‚   â”‚       â”‚   #include "isr.h"
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   // ĞĞ¾Ğ¼ĞµÑ€Ğ° IRQ
    â”‚       â”‚   â”‚       â”‚   #define IRQ0    32      // Timer
    â”‚       â”‚   â”‚       â”‚   #define IRQ1    33      // Keyboard
    â”‚       â”‚   â”‚       â”‚   #define IRQ2    34      // Cascade
    â”‚       â”‚   â”‚       â”‚   #define IRQ3    35      // COM2
    â”‚       â”‚   â”‚       â”‚   #define IRQ4    36      // COM1
    â”‚       â”‚   â”‚       â”‚   #define IRQ5    37      // LPT2
    â”‚       â”‚   â”‚       â”‚   #define IRQ6    38      // Floppy
    â”‚       â”‚   â”‚       â”‚   #define IRQ7    39      // LPT1
    â”‚       â”‚   â”‚       â”‚   #define IRQ8    40      // CMOS RTC
    â”‚       â”‚   â”‚       â”‚   #define IRQ9    41      // Free
    â”‚       â”‚   â”‚       â”‚   #define IRQ10   42      // Free
    â”‚       â”‚   â”‚       â”‚   #define IRQ11   43      // Free
    â”‚       â”‚   â”‚       â”‚   #define IRQ12   44      // PS/2 Mouse
    â”‚       â”‚   â”‚       â”‚   #define IRQ13   45      // FPU
    â”‚       â”‚   â”‚       â”‚   #define IRQ14   46      // Primary ATA
    â”‚       â”‚   â”‚       â”‚   #define IRQ15   47      // Secondary ATA
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   // Ğ¤ÑƒĞ½ĞºÑ†Ğ¸Ğ¸
    â”‚       â”‚   â”‚       â”‚   void irq_init(void);
    â”‚       â”‚   â”‚       â”‚   void irq_install_handler(uint8_t irq, isr_handler_t handler);
    â”‚       â”‚   â”‚       â”‚   void irq_uninstall_handler(uint8_t irq);
    â”‚       â”‚   â”‚       â”‚   void irq_handler(struct registers *regs);
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   #endif // IRQ_H
    â”‚       â”‚   â”‚       â”‚
    â”‚       â”‚   â”‚   â””â”€â”€ isr.h
    â”‚       â”‚   â”‚       â”‚
    â”‚       â”‚   â”‚       â”œâ”€â”€ CONTENT:
    â”‚       â”‚   â”‚       â”‚   #ifndef ISR_H
    â”‚       â”‚   â”‚       â”‚   #define ISR_H
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   #include <stdint.h>
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   // Ğ¡Ñ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ° Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ¾Ğ² Ğ¿Ñ€Ğ¸ Ğ¿Ñ€ĞµÑ€Ñ‹Ğ²Ğ°Ğ½Ğ¸Ğ¸
    â”‚       â”‚   â”‚       â”‚   struct registers {
    â”‚       â”‚   â”‚       â”‚       uint64_t r15, r14, r13, r12, r11, r10, r9, r8;
    â”‚       â”‚   â”‚       â”‚       uint64_t rdi, rsi, rbp, rbx, rdx, rcx, rax;
    â”‚       â”‚   â”‚       â”‚       uint64_t int_no, err_code;
    â”‚       â”‚   â”‚       â”‚       uint64_t rip, cs, rflags, rsp, ss;
    â”‚       â”‚   â”‚       â”‚   } __attribute__((packed));
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   // Ğ¢Ğ¸Ğ¿ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸ĞºĞ° Ğ¿Ñ€ĞµÑ€Ñ‹Ğ²Ğ°Ğ½Ğ¸Ğ¹
    â”‚       â”‚   â”‚       â”‚   typedef void (*isr_handler_t)(struct registers*);
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   // Ğ¤ÑƒĞ½ĞºÑ†Ğ¸Ğ¸
    â”‚       â”‚   â”‚       â”‚   void isr_install_handler(uint8_t num, isr_handler_t handler);
    â”‚       â”‚   â”‚       â”‚   void isr_uninstall_handler(uint8_t num);
    â”‚       â”‚   â”‚       â”‚   void exception_handler(struct registers *regs);
    â”‚       â”‚   â”‚       â”‚   void irq_handler(struct registers *regs);
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   #endif // ISR_H
    â”‚       â”‚   â”‚       â”‚
    â”‚       â”‚   â”œâ”€â”€ memory
    â”‚       â”‚   â”‚   â”œâ”€â”€ heap.h
    â”‚       â”‚   â”‚       â”‚
    â”‚       â”‚   â”‚       â”œâ”€â”€ CONTENT:
    â”‚       â”‚   â”‚       â”‚   #ifndef HEAP_H
    â”‚       â”‚   â”‚       â”‚   #define HEAP_H
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   #include <stdint.h>
    â”‚       â”‚   â”‚       â”‚   #include <stddef.h>
    â”‚       â”‚   â”‚       â”‚   #include <stdbool.h>
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   #define HEAP_START         0xFFFFFFFF90000000
    â”‚       â”‚   â”‚       â”‚   #define HEAP_INITIAL_SIZE  0x100000
    â”‚       â”‚   â”‚       â”‚   #define HEAP_MAX_SIZE      0x10000000
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   // Security constants
    â”‚       â”‚   â”‚       â”‚   #define HEAP_CANARY_VALUE          0xDEADBEEFCAFEBABE
    â”‚       â”‚   â”‚       â”‚   #define HEAP_MAX_ALLOC_SIZE        (HEAP_INITIAL_SIZE / 4)  // Max 25% of heap per allocation
    â”‚       â”‚   â”‚       â”‚   #define HEAP_MIN_ALLOC_SIZE        8
    â”‚       â”‚   â”‚       â”‚   #define HEAP_ALIGNMENT             8
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   // Memory protection flags
    â”‚       â”‚   â”‚       â”‚   #define HEAP_READ_ONLY     0x01
    â”‚       â”‚   â”‚       â”‚   #define HEAP_NO_EXECUTE    0x02
    â”‚       â”‚   â”‚       â”‚   #define HEAP_GUARD_PAGE    0x04
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   // Memory poisoning
    â”‚       â”‚   â”‚       â”‚   #define HEAP_ALLOC_POISON  0xAA
    â”‚       â”‚   â”‚       â”‚   #define HEAP_FREE_POISON   0xDD
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   // Security statistics structure
    â”‚       â”‚   â”‚       â”‚   struct heap_security_stats {
    â”‚       â”‚   â”‚       â”‚       size_t total_allocations;
    â”‚       â”‚   â”‚       â”‚       size_t total_frees;
    â”‚       â”‚   â”‚       â”‚       size_t failed_allocations;
    â”‚       â”‚   â”‚       â”‚       size_t double_free_attempts;
    â”‚       â”‚   â”‚       â”‚       size_t buffer_overflow_detected;
    â”‚       â”‚   â”‚       â”‚       size_t use_after_free_detected;
    â”‚       â”‚   â”‚       â”‚       size_t corruption_count;
    â”‚       â”‚   â”‚       â”‚   };
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   // Structure with security features
    â”‚       â”‚   â”‚       â”‚   struct heap_block {
    â”‚       â”‚   â”‚       â”‚       uint64_t canary_start;     // Stack canary pattern
    â”‚       â”‚   â”‚       â”‚       size_t size;
    â”‚       â”‚   â”‚       â”‚       size_t requested_size;     // Original requested size
    â”‚       â”‚   â”‚       â”‚       bool used;
    â”‚       â”‚   â”‚       â”‚       uint8_t protection_flags;
    â”‚       â”‚   â”‚       â”‚       uint32_t checksum;         // CRC-like checksum
    â”‚       â”‚   â”‚       â”‚       struct heap_block* next;
    â”‚       â”‚   â”‚       â”‚       struct heap_block* prev;
    â”‚       â”‚   â”‚       â”‚       void* allocation_ptr;      // Pointer to actual allocation
    â”‚       â”‚   â”‚       â”‚       uint64_t canary_end;       // End canary
    â”‚       â”‚   â”‚       â”‚   } __attribute__((packed));
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   struct heap {
    â”‚       â”‚   â”‚       â”‚       void* start;
    â”‚       â”‚   â”‚       â”‚       void* end;
    â”‚       â”‚   â”‚       â”‚       size_t total_size;
    â”‚       â”‚   â”‚       â”‚       size_t used_size;
    â”‚       â”‚   â”‚       â”‚       size_t alloc_count;
    â”‚       â”‚   â”‚       â”‚       size_t free_count;
    â”‚       â”‚   â”‚       â”‚       size_t corruption_count;
    â”‚       â”‚   â”‚       â”‚       struct heap_block* first_block;
    â”‚       â”‚   â”‚       â”‚       
    â”‚       â”‚   â”‚       â”‚       // Security statistics
    â”‚       â”‚   â”‚       â”‚       struct heap_security_stats stats;
    â”‚       â”‚   â”‚       â”‚   };
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   // Security functions
    â”‚       â”‚   â”‚       â”‚   void heap_init(void);
    â”‚       â”‚   â”‚       â”‚   void* kmalloc(size_t size);
    â”‚       â”‚   â”‚       â”‚   void* kmalloc_protected(size_t size, uint8_t protection_flags);
    â”‚       â”‚   â”‚       â”‚   void* kcalloc(size_t num, size_t size);
    â”‚       â”‚   â”‚       â”‚   void* krealloc(void* ptr, size_t size);
    â”‚       â”‚   â”‚       â”‚   void kfree(void* ptr);
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   // Security validation functions
    â”‚       â”‚   â”‚       â”‚   bool heap_validate_block(struct heap_block* block);
    â”‚       â”‚   â”‚       â”‚   bool heap_validate_all_blocks(void);
    â”‚       â”‚   â”‚       â”‚   void heap_check_integrity(void);
    â”‚       â”‚   â”‚       â”‚   bool heap_is_valid_pointer(void* ptr);
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   // Memory protection
    â”‚       â”‚   â”‚       â”‚   bool heap_protect_block(void* ptr, uint8_t protection_flags);
    â”‚       â”‚   â”‚       â”‚   bool heap_unprotect_block(void* ptr);
    â”‚       â”‚   â”‚       â”‚   bool heap_mark_as_executable(void* ptr);
    â”‚       â”‚   â”‚       â”‚   bool heap_mark_as_readonly(void* ptr);
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   // Debug and diagnostics
    â”‚       â”‚   â”‚       â”‚   size_t heap_get_total_size(void);
    â”‚       â”‚   â”‚       â”‚   size_t heap_get_used_size(void);
    â”‚       â”‚   â”‚       â”‚   size_t heap_get_free_size(void);
    â”‚       â”‚   â”‚       â”‚   void heap_dump_blocks(void);
    â”‚       â”‚   â”‚       â”‚   void heap_print_stats(void);
    â”‚       â”‚   â”‚       â”‚   void heap_enable_poisoning(bool enable);
    â”‚       â”‚   â”‚       â”‚   void heap_enable_guard_pages(bool enable);
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   // Advanced security
    â”‚       â”‚   â”‚       â”‚   void* kmalloc_aligned(size_t size, size_t alignment);
    â”‚       â”‚   â”‚       â”‚   bool heap_detect_corruption(void);
    â”‚       â”‚   â”‚       â”‚   void heap_emergency_lockdown(void);
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   #endif
    â”‚       â”‚   â”‚       â”‚
    â”‚       â”‚   â”‚   â”œâ”€â”€ paging.h
    â”‚       â”‚   â”‚       â”‚
    â”‚       â”‚   â”‚       â”œâ”€â”€ CONTENT:
    â”‚       â”‚   â”‚       â”‚   #ifndef PAGING_H
    â”‚       â”‚   â”‚       â”‚   #define PAGING_H
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   #include <stdint.h>
    â”‚       â”‚   â”‚       â”‚   #include <stddef.h>
    â”‚       â”‚   â”‚       â”‚   #include <stdbool.h>
    â”‚       â”‚   â”‚       â”‚   #include "../interrupts/isr.h"
    â”‚       â”‚   â”‚       â”‚   #include <limine.h>
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   // Page table entry flags
    â”‚       â”‚   â”‚       â”‚   #define PAGING_PRESENT         (1ULL << 0)
    â”‚       â”‚   â”‚       â”‚   #define PAGING_WRITABLE        (1ULL << 1)
    â”‚       â”‚   â”‚       â”‚   #define PAGING_USER            (1ULL << 2)
    â”‚       â”‚   â”‚       â”‚   #define PAGING_WRITE_THROUGH   (1ULL << 3)
    â”‚       â”‚   â”‚       â”‚   #define PAGING_CACHE_DISABLE   (1ULL << 4)
    â”‚       â”‚   â”‚       â”‚   #define PAGING_ACCESSED        (1ULL << 5)
    â”‚       â”‚   â”‚       â”‚   #define PAGING_DIRTY           (1ULL << 6)
    â”‚       â”‚   â”‚       â”‚   #define PAGING_HUGE_PAGE       (1ULL << 7)
    â”‚       â”‚   â”‚       â”‚   #define PAGING_GLOBAL          (1ULL << 8)
    â”‚       â”‚   â”‚       â”‚   #define PAGING_NO_EXECUTE      (1ULL << 63)
    â”‚       â”‚   â”‚       â”‚   #define PF_PRESENT      (1 << 0)    // Page present
    â”‚       â”‚   â”‚       â”‚   #define PF_WRITE        (1 << 1)    // Write operation
    â”‚       â”‚   â”‚       â”‚   #define PF_USER         (1 << 2)    // User mode access
    â”‚       â”‚   â”‚       â”‚   #define PF_RESERVED     (1 << 3)    // Reserved bit set
    â”‚       â”‚   â”‚       â”‚   #define PF_INSTRUCTION  (1 << 4)    // Instruction fetch
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   // Page sizes
    â”‚       â”‚   â”‚       â”‚   #define PAGE_SIZE_4K 0x1000
    â”‚       â”‚   â”‚       â”‚   #define PAGE_SIZE_2M 0x200000
    â”‚       â”‚   â”‚       â”‚   #define PAGE_SIZE_1G 0x40000000
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   // Virtual memory layout
    â”‚       â”‚   â”‚       â”‚   #define KERNEL_VIRTUAL_BASE 0xFFFFFFFF80000000
    â”‚       â”‚   â”‚       â”‚   #define HHDM_OFFSET         0xFFFF800000000000
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   // Page table structure
    â”‚       â”‚   â”‚       â”‚   typedef uint64_t page_table_entry_t;
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   struct page_table {
    â”‚       â”‚   â”‚       â”‚       page_table_entry_t entries[512];
    â”‚       â”‚   â”‚       â”‚   } __attribute__((aligned(PAGE_SIZE_4K)));
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   // Paging functions
    â”‚       â”‚   â”‚       â”‚   void paging_init(volatile struct limine_hhdm_response *hhdm_response);
    â”‚       â”‚   â”‚       â”‚   void paging_load_cr3(uint64_t cr3_value);
    â”‚       â”‚   â”‚       â”‚   uint64_t paging_get_cr3(void);
    â”‚       â”‚   â”‚       â”‚   void paging_invalidate_tlb(uint64_t virtual_addr);
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   bool paging_map_page(uint64_t virtual_addr, uint64_t physical_addr, uint64_t flags);
    â”‚       â”‚   â”‚       â”‚   bool paging_unmap_page(uint64_t virtual_addr);
    â”‚       â”‚   â”‚       â”‚   bool paging_is_mapped(uint64_t virtual_addr);
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   // Memory conversion functions
    â”‚       â”‚   â”‚       â”‚   void* paging_physical_to_virtual(uint64_t physical_addr);
    â”‚       â”‚   â”‚       â”‚   uint64_t paging_virtual_to_physical(void* virtual_addr);
    â”‚       â”‚   â”‚       â”‚   void* paging_hhdm_to_virtual(uint64_t physical_addr);
    â”‚       â”‚   â”‚       â”‚   uint64_t paging_get_physical_address(uint64_t virtual_addr);
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   void handle_page_fault(struct registers *regs);
    â”‚       â”‚   â”‚       â”‚   void handle_double_fault(struct registers *regs);
    â”‚       â”‚   â”‚       â”‚   void handle_general_protection_fault(struct registers *regs);
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   #endif // PAGING_H
    â”‚       â”‚   â”‚       â”‚
    â”‚       â”‚   â”‚   â”œâ”€â”€ pmm.h
    â”‚       â”‚   â”‚       â”‚
    â”‚       â”‚   â”‚       â”œâ”€â”€ CONTENT:
    â”‚       â”‚   â”‚       â”‚   #ifndef PMM_H
    â”‚       â”‚   â”‚       â”‚   #define PMM_H
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   #include <stdint.h>
    â”‚       â”‚   â”‚       â”‚   #include <stddef.h>
    â”‚       â”‚   â”‚       â”‚   #include <stdbool.h>
    â”‚       â”‚   â”‚       â”‚   #include <limine.h>
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   // Physical memory manager
    â”‚       â”‚   â”‚       â”‚   void pmm_init(volatile struct limine_memmap_response *memmap_response,
    â”‚       â”‚   â”‚       â”‚                 volatile struct limine_hhdm_response *hhdm_response);
    â”‚       â”‚   â”‚       â”‚   uint64_t pmm_alloc_page(void);
    â”‚       â”‚   â”‚       â”‚   void pmm_free_page(uint64_t page);
    â”‚       â”‚   â”‚       â”‚   uint64_t pmm_get_total_memory(void);
    â”‚       â”‚   â”‚       â”‚   uint64_t pmm_get_free_memory(void);
    â”‚       â”‚   â”‚       â”‚   uint64_t pmm_get_used_memory(void);
    â”‚       â”‚   â”‚       â”‚   void pmm_dump_memory_map(void);
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   #endif // PMM_H
    â”‚       â”‚   â”‚       â”‚
    â”‚       â”‚   â”‚   â””â”€â”€ security.h
    â”‚       â”‚   â”‚       â”‚
    â”‚       â”‚   â”‚       â”œâ”€â”€ CONTENT:
    â”‚       â”‚   â”‚       â”‚   #ifndef MEMORY_SECURITY_H
    â”‚       â”‚   â”‚       â”‚   #define MEMORY_SECURITY_H
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   #include <stdint.h>
    â”‚       â”‚   â”‚       â”‚   #include <stddef.h>
    â”‚       â”‚   â”‚       â”‚   #include <stdbool.h>
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   // Memory security subsystem
    â”‚       â”‚   â”‚       â”‚   void memory_security_init(void);
    â”‚       â”‚   â”‚       â”‚   void memory_security_check(void);
    â”‚       â”‚   â”‚       â”‚   bool memory_validate_kernel_stack(void);
    â”‚       â”‚   â”‚       â”‚   bool memory_validate_heap_integrity(void);
    â”‚       â”‚   â”‚       â”‚   void memory_dump_security_status(void);
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   // Stack protection
    â”‚       â”‚   â”‚       â”‚   void stack_protector_init(void);
    â”‚       â”‚   â”‚       â”‚   bool stack_protector_check(void);
    â”‚       â”‚   â”‚       â”‚   uint64_t generate_stack_canary(void);
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   // Address Space Layout Randomization
    â”‚       â”‚   â”‚       â”‚   void aslr_init(void);
    â”‚       â”‚   â”‚       â”‚   uint64_t aslr_randomize_address(uint64_t base, uint64_t size);
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   // Memory sanitization
    â”‚       â”‚   â”‚       â”‚   void secure_memset(void* ptr, int value, size_t size);
    â”‚       â”‚   â”‚       â”‚   void secure_memzero(void* ptr, size_t size);
    â”‚       â”‚   â”‚       â”‚   void memory_poison_range(void* start, void* end, uint8_t pattern);
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   #endif
    â”‚       â”‚   â”‚       â”‚
    â”‚       â”‚   â”œâ”€â”€ simd
    â”‚       â”‚   â”‚   â””â”€â”€ simd.h
    â”‚       â”‚   â”‚       â”‚
    â”‚       â”‚   â”‚       â”œâ”€â”€ CONTENT:
    â”‚       â”‚   â”‚       â”‚   <empty>
    â”‚       â”‚   â”‚       â”‚
    â”‚       â”‚   â””â”€â”€ sys
    â”‚       â”‚       â””â”€â”€ gdt.h
    â”‚       â”‚           â”‚
    â”‚       â”‚           â”œâ”€â”€ CONTENT:
    â”‚       â”‚           â”‚   #ifndef GDT_H
    â”‚       â”‚           â”‚   #define GDT_H
    â”‚       â”‚           â”‚   
    â”‚       â”‚           â”‚   #include <stdint.h>
    â”‚       â”‚           â”‚   
    â”‚       â”‚           â”‚   // Ğ¡Ñ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ° Ğ´ĞµÑĞºÑ€Ğ¸Ğ¿Ñ‚Ğ¾Ñ€Ğ° GDT
    â”‚       â”‚           â”‚   struct gdt_entry {
    â”‚       â”‚           â”‚       uint16_t limit_low;
    â”‚       â”‚           â”‚       uint16_t base_low;
    â”‚       â”‚           â”‚       uint8_t base_middle;
    â”‚       â”‚           â”‚       uint8_t access;
    â”‚       â”‚           â”‚       uint8_t granularity;
    â”‚       â”‚           â”‚       uint8_t base_high;
    â”‚       â”‚           â”‚   } __attribute__((packed));
    â”‚       â”‚           â”‚   
    â”‚       â”‚           â”‚   // Ğ¡Ñ‚Ñ€ÑƒĞºÑ‚ÑƒÑ€Ğ° ÑƒĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»Ñ GDT (Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ - Ğ´Ğ¾Ğ»Ğ¶ĞµĞ½ Ğ±Ñ‹Ñ‚ÑŒ 48-Ğ±Ğ¸Ñ‚Ğ½Ñ‹Ğ¼)
    â”‚       â”‚           â”‚   struct gdt_ptr {
    â”‚       â”‚           â”‚       uint16_t limit;
    â”‚       â”‚           â”‚       uint64_t base;
    â”‚       â”‚           â”‚   } __attribute__((packed));
    â”‚       â”‚           â”‚   
    â”‚       â”‚           â”‚   // Ğ¡ĞµĞ³Ğ¼ĞµĞ½Ñ‚Ğ½Ñ‹Ğµ ÑĞµĞ»ĞµĞºÑ‚Ğ¾Ñ€Ñ‹ (Ğ˜Ğ¡ĞŸĞ ĞĞ’Ğ›Ğ•ĞĞ - ÑƒÑ‡Ğ¸Ñ‚Ñ‹Ğ²Ğ°ĞµĞ¼ ÑĞ¼ĞµÑ‰ĞµĞ½Ğ¸Ğµ)
    â”‚       â”‚           â”‚   #define GDT_KERNEL_CS 0x08  // 1-Ğ¹ Ğ´ĞµÑĞºÑ€Ğ¸Ğ¿Ñ‚Ğ¾Ñ€ (Ğ¿Ğ¾ÑĞ»Ğµ null)
    â”‚       â”‚           â”‚   #define GDT_KERNEL_DS 0x10  // 2-Ğ¹ Ğ´ĞµÑĞºÑ€Ğ¸Ğ¿Ñ‚Ğ¾Ñ€
    â”‚       â”‚           â”‚   
    â”‚       â”‚           â”‚   // Ğ¤Ğ»Ğ°Ğ³Ğ¸ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ°
    â”‚       â”‚           â”‚   #define GDT_ACCESS_PRESENT     (1 << 7)
    â”‚       â”‚           â”‚   #define GDT_ACCESS_RING0       (0 << 5)
    â”‚       â”‚           â”‚   #define GDT_ACCESS_SEGMENT     (1 << 4)
    â”‚       â”‚           â”‚   #define GDT_ACCESS_EXECUTABLE  (1 << 3)
    â”‚       â”‚           â”‚   #define GDT_ACCESS_READ_WRITE  (1 << 1)
    â”‚       â”‚           â”‚   
    â”‚       â”‚           â”‚   // Ğ¤Ğ»Ğ°Ğ³Ğ¸ Ğ³Ñ€Ğ°Ğ½ÑƒĞ»ÑÑ€Ğ½Ğ¾ÑÑ‚Ğ¸
    â”‚       â”‚           â”‚   #define GDT_GRANULARITY_4K     (1 << 7)
    â”‚       â”‚           â”‚   #define GDT_GRANULARITY_LONG   (1 << 5)  // 64-bit mode
    â”‚       â”‚           â”‚   
    â”‚       â”‚           â”‚   // Ğ¤ÑƒĞ½ĞºÑ†Ğ¸Ğ¸
    â”‚       â”‚           â”‚   void gdt_init(void);
    â”‚       â”‚           â”‚   void gdt_load(void);
    â”‚       â”‚           â”‚   
    â”‚       â”‚           â”‚   // Ğ¤ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ´Ğ»Ñ Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ñ Ğ´ĞµÑĞºÑ€Ğ¸Ğ¿Ñ‚Ğ¾Ñ€Ğ° GDT (Ğ´Ğ»Ñ Ğ¾Ñ‚Ğ»Ğ°Ğ´ĞºĞ¸)
    â”‚       â”‚           â”‚   const struct gdt_entry* gdt_get_descriptor(int index);
    â”‚       â”‚           â”‚   
    â”‚       â”‚           â”‚   
    â”‚       â”‚           â”‚   
    â”‚       â”‚           â”‚   #endif // GDT_H
    â”‚       â”‚           â”‚
    â”‚       â”œâ”€â”€ interrupts
    â”‚       â”‚   â”œâ”€â”€ idt.c
    â”‚       â”‚       â”‚
    â”‚       â”‚       â”œâ”€â”€ CONTENT:
    â”‚       â”‚       â”‚   #include "include/interrupts/idt.h"
    â”‚       â”‚       â”‚   #include "include/interrupts/isr.h"
    â”‚       â”‚       â”‚   #include "include/drivers/serial.h"
    â”‚       â”‚       â”‚   #include "libc/string.h" 
    â”‚       â”‚       â”‚   #include "include/memory/paging.h"
    â”‚       â”‚       â”‚   #include <stddef.h>
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   // IDT Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ğ° (256 Ğ·Ğ°Ğ¿Ğ¸ÑĞµĞ¹)
    â”‚       â”‚       â”‚   static struct idt_entry idt[256];
    â”‚       â”‚       â”‚   static struct idt_ptr idtp;
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   // Ğ’Ğ½ĞµÑˆĞ½Ğ¸Ğµ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¸ Ğ¸Ğ· Ğ°ÑÑĞµĞ¼Ğ±Ğ»ĞµÑ€Ğ°
    â”‚       â”‚       â”‚   extern void idt_flush(uint64_t idt_ptr);
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   // ĞĞ±ÑŠÑĞ²Ğ»ĞµĞ½Ğ¸Ñ Ğ°ÑÑĞµĞ¼Ğ±Ğ»ĞµÑ€Ğ½Ñ‹Ñ… Ğ·Ğ°Ğ³Ğ»ÑƒÑˆĞµĞº Ğ´Ğ»Ñ Ğ²ÑĞµÑ… Ğ¸ÑĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğ¹
    â”‚       â”‚       â”‚   extern void isr_stub_0(void);
    â”‚       â”‚       â”‚   extern void isr_stub_1(void);
    â”‚       â”‚       â”‚   extern void isr_stub_2(void);
    â”‚       â”‚       â”‚   extern void isr_stub_3(void);
    â”‚       â”‚       â”‚   extern void isr_stub_4(void);
    â”‚       â”‚       â”‚   extern void isr_stub_5(void);
    â”‚       â”‚       â”‚   extern void isr_stub_6(void);
    â”‚       â”‚       â”‚   extern void isr_stub_7(void);
    â”‚       â”‚       â”‚   extern void isr_stub_8(void);
    â”‚       â”‚       â”‚   extern void isr_stub_9(void);
    â”‚       â”‚       â”‚   extern void isr_stub_10(void);
    â”‚       â”‚       â”‚   extern void isr_stub_11(void);
    â”‚       â”‚       â”‚   extern void isr_stub_12(void);
    â”‚       â”‚       â”‚   extern void isr_stub_13(void);
    â”‚       â”‚       â”‚   extern void isr_stub_14(void);
    â”‚       â”‚       â”‚   extern void isr_stub_15(void);
    â”‚       â”‚       â”‚   extern void isr_stub_16(void);
    â”‚       â”‚       â”‚   extern void isr_stub_17(void);
    â”‚       â”‚       â”‚   extern void isr_stub_18(void);
    â”‚       â”‚       â”‚   extern void isr_stub_19(void);
    â”‚       â”‚       â”‚   extern void isr_stub_20(void);
    â”‚       â”‚       â”‚   extern void isr_stub_21(void);
    â”‚       â”‚       â”‚   extern void isr_stub_22(void);
    â”‚       â”‚       â”‚   extern void isr_stub_23(void);
    â”‚       â”‚       â”‚   extern void isr_stub_24(void);
    â”‚       â”‚       â”‚   extern void isr_stub_25(void);
    â”‚       â”‚       â”‚   extern void isr_stub_26(void);
    â”‚       â”‚       â”‚   extern void isr_stub_27(void);
    â”‚       â”‚       â”‚   extern void isr_stub_28(void);
    â”‚       â”‚       â”‚   extern void isr_stub_29(void);
    â”‚       â”‚       â”‚   extern void isr_stub_30(void);
    â”‚       â”‚       â”‚   extern void isr_stub_31(void);
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   extern void isr_stub_32(void);
    â”‚       â”‚       â”‚   extern void isr_stub_33(void);
    â”‚       â”‚       â”‚   extern void isr_stub_34(void);
    â”‚       â”‚       â”‚   extern void isr_stub_35(void);
    â”‚       â”‚       â”‚   extern void isr_stub_36(void);
    â”‚       â”‚       â”‚   extern void isr_stub_37(void);
    â”‚       â”‚       â”‚   extern void isr_stub_38(void);
    â”‚       â”‚       â”‚   extern void isr_stub_39(void);
    â”‚       â”‚       â”‚   extern void isr_stub_40(void);
    â”‚       â”‚       â”‚   extern void isr_stub_41(void);
    â”‚       â”‚       â”‚   extern void isr_stub_42(void);
    â”‚       â”‚       â”‚   extern void isr_stub_43(void);
    â”‚       â”‚       â”‚   extern void isr_stub_44(void);
    â”‚       â”‚       â”‚   extern void isr_stub_45(void);
    â”‚       â”‚       â”‚   extern void isr_stub_46(void);
    â”‚       â”‚       â”‚   extern void isr_stub_47(void);
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   // Ğ¢Ğ°Ğ±Ğ»Ğ¸Ñ†Ğ° Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸ĞºĞ¾Ğ² Ğ¿Ñ€ĞµÑ€Ñ‹Ğ²Ğ°Ğ½Ğ¸Ğ¹
    â”‚       â”‚       â”‚   static isr_handler_t isr_handlers[256] = {0};
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   // Ğ”ĞµĞºĞ»Ğ°Ñ€Ğ°Ñ†Ğ¸Ñ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸ĞºĞ° Ğ¸Ğ· isr.c
    â”‚       â”‚       â”‚   extern void isr_handler(struct registers *regs);
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   void idt_set_entry(uint8_t index, uint64_t base, uint16_t selector, uint8_t type_attr) {
    â”‚       â”‚       â”‚       idt[index].base_low = base & 0xFFFF;
    â”‚       â”‚       â”‚       idt[index].base_middle = (base >> 16) & 0xFFFF;
    â”‚       â”‚       â”‚       idt[index].base_high = (base >> 32) & 0xFFFFFFFF;
    â”‚       â”‚       â”‚       idt[index].selector = selector;
    â”‚       â”‚       â”‚       idt[index].ist = 0;
    â”‚       â”‚       â”‚       idt[index].type_attr = type_attr;
    â”‚       â”‚       â”‚       idt[index].zero = 0;
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   void idt_init(void) {
    â”‚       â”‚       â”‚       serial_puts("[IDT] Initializing IDT...\n");
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // ĞĞ±Ğ½ÑƒĞ»ÑĞµĞ¼ IDT
    â”‚       â”‚       â”‚       for (int i = 0; i < 256; i++) {
    â”‚       â”‚       â”‚           idt_set_entry(i, 0, 0, 0);
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Ğ£ÑÑ‚Ğ°Ğ½Ğ°Ğ²Ğ»Ğ¸Ğ²Ğ°ĞµĞ¼ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸ĞºĞ¸ Ğ¸ÑĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğ¹ (0-31)
    â”‚       â”‚       â”‚       idt_set_entry(EXCEPTION_DIVISION_ERROR, (uint64_t)isr_stub_0, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    â”‚       â”‚       â”‚       idt_set_entry(EXCEPTION_DEBUG, (uint64_t)isr_stub_1, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    â”‚       â”‚       â”‚       idt_set_entry(EXCEPTION_NMI, (uint64_t)isr_stub_2, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    â”‚       â”‚       â”‚       idt_set_entry(EXCEPTION_BREAKPOINT, (uint64_t)isr_stub_3, 0x08, IDT_PRESENT | IDT_RING3 | IDT_TYPE_INT);
    â”‚       â”‚       â”‚       idt_set_entry(EXCEPTION_OVERFLOW, (uint64_t)isr_stub_4, 0x08, IDT_PRESENT | IDT_RING3 | IDT_TYPE_INT);
    â”‚       â”‚       â”‚       idt_set_entry(EXCEPTION_BOUND_RANGE, (uint64_t)isr_stub_5, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    â”‚       â”‚       â”‚       idt_set_entry(EXCEPTION_INVALID_OPCODE, (uint64_t)isr_stub_6, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    â”‚       â”‚       â”‚       idt_set_entry(EXCEPTION_DEVICE_NOT_AVAILABLE, (uint64_t)isr_stub_7, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    â”‚       â”‚       â”‚       idt_set_entry(EXCEPTION_DOUBLE_FAULT, (uint64_t)isr_stub_8, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    â”‚       â”‚       â”‚       idt_set_entry(EXCEPTION_COPROCESSOR_SEGMENT, (uint64_t)isr_stub_9, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    â”‚       â”‚       â”‚       idt_set_entry(EXCEPTION_INVALID_TSS, (uint64_t)isr_stub_10, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    â”‚       â”‚       â”‚       idt_set_entry(EXCEPTION_SEGMENT_NOT_PRESENT, (uint64_t)isr_stub_11, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    â”‚       â”‚       â”‚       idt_set_entry(EXCEPTION_STACK_SEGMENT_FAULT, (uint64_t)isr_stub_12, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    â”‚       â”‚       â”‚       idt_set_entry(EXCEPTION_GPF, (uint64_t)isr_stub_13, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    â”‚       â”‚       â”‚       idt_set_entry(EXCEPTION_PAGE_FAULT, (uint64_t)isr_stub_14, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    â”‚       â”‚       â”‚       idt_set_entry(EXCEPTION_RESERVED, (uint64_t)isr_stub_15, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    â”‚       â”‚       â”‚       idt_set_entry(EXCEPTION_X87_FPU, (uint64_t)isr_stub_16, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    â”‚       â”‚       â”‚       idt_set_entry(EXCEPTION_ALIGNMENT_CHECK, (uint64_t)isr_stub_17, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    â”‚       â”‚       â”‚       idt_set_entry(EXCEPTION_MACHINE_CHECK, (uint64_t)isr_stub_18, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    â”‚       â”‚       â”‚       idt_set_entry(EXCEPTION_SIMD_FPU, (uint64_t)isr_stub_19, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    â”‚       â”‚       â”‚       idt_set_entry(EXCEPTION_VIRTUALIZATION, (uint64_t)isr_stub_20, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    â”‚       â”‚       â”‚       idt_set_entry(21, (uint64_t)isr_stub_21, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    â”‚       â”‚       â”‚       idt_set_entry(22, (uint64_t)isr_stub_22, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    â”‚       â”‚       â”‚       idt_set_entry(23, (uint64_t)isr_stub_23, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    â”‚       â”‚       â”‚       idt_set_entry(24, (uint64_t)isr_stub_24, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    â”‚       â”‚       â”‚       idt_set_entry(25, (uint64_t)isr_stub_25, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    â”‚       â”‚       â”‚       idt_set_entry(26, (uint64_t)isr_stub_26, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    â”‚       â”‚       â”‚       idt_set_entry(27, (uint64_t)isr_stub_27, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    â”‚       â”‚       â”‚       idt_set_entry(28, (uint64_t)isr_stub_28, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    â”‚       â”‚       â”‚       idt_set_entry(29, (uint64_t)isr_stub_29, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    â”‚       â”‚       â”‚       idt_set_entry(EXCEPTION_SECURITY, (uint64_t)isr_stub_30, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    â”‚       â”‚       â”‚       idt_set_entry(31, (uint64_t)isr_stub_31, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       idt_set_entry(32, (uint64_t)isr_stub_32, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    â”‚       â”‚       â”‚       idt_set_entry(33, (uint64_t)isr_stub_33, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    â”‚       â”‚       â”‚       idt_set_entry(34, (uint64_t)isr_stub_34, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    â”‚       â”‚       â”‚       idt_set_entry(35, (uint64_t)isr_stub_35, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    â”‚       â”‚       â”‚       idt_set_entry(36, (uint64_t)isr_stub_36, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    â”‚       â”‚       â”‚       idt_set_entry(37, (uint64_t)isr_stub_37, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    â”‚       â”‚       â”‚       idt_set_entry(38, (uint64_t)isr_stub_38, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    â”‚       â”‚       â”‚       idt_set_entry(39, (uint64_t)isr_stub_39, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    â”‚       â”‚       â”‚       idt_set_entry(40, (uint64_t)isr_stub_40, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    â”‚       â”‚       â”‚       idt_set_entry(41, (uint64_t)isr_stub_41, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    â”‚       â”‚       â”‚       idt_set_entry(42, (uint64_t)isr_stub_42, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    â”‚       â”‚       â”‚       idt_set_entry(43, (uint64_t)isr_stub_43, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    â”‚       â”‚       â”‚       idt_set_entry(44, (uint64_t)isr_stub_44, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    â”‚       â”‚       â”‚       idt_set_entry(45, (uint64_t)isr_stub_45, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    â”‚       â”‚       â”‚       idt_set_entry(46, (uint64_t)isr_stub_46, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    â”‚       â”‚       â”‚       idt_set_entry(47, (uint64_t)isr_stub_47, 0x08, IDT_PRESENT | IDT_RING0 | IDT_TYPE_INT);
    â”‚       â”‚       â”‚       // ĞĞ°ÑÑ‚Ñ€Ğ°Ğ¸Ğ²Ğ°ĞµĞ¼ ÑƒĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»ÑŒ IDT
    â”‚       â”‚       â”‚       idtp.limit = sizeof(idt) - 1;
    â”‚       â”‚       â”‚       idtp.base = (uint64_t)&idt;
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Ğ£ÑÑ‚Ğ°Ğ½Ğ°Ğ²Ğ»Ğ¸Ğ²Ğ°ĞµĞ¼ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸ĞºĞ¸ Ğ¸ÑĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğ¹
    â”‚       â”‚       â”‚       for (int i = 0; i < 32; i++) {
    â”‚       â”‚       â”‚           isr_install_handler(i, exception_handler);
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚       isr_install_handler(EXCEPTION_DOUBLE_FAULT, handle_double_fault);
    â”‚       â”‚       â”‚       isr_install_handler(EXCEPTION_GPF, handle_general_protection_fault);
    â”‚       â”‚       â”‚       isr_install_handler(EXCEPTION_PAGE_FAULT, handle_page_fault);
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       serial_puts("[IDT] IDT entries set up (0-31: exceptions)\n");
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   void idt_load(void) {
    â”‚       â”‚       â”‚       serial_puts("[IDT] Loading IDT...\n");
    â”‚       â”‚       â”‚       idt_flush((uint64_t)&idtp);
    â”‚       â”‚       â”‚       asm volatile("sti");  // Ğ Ğ°Ğ·Ñ€ĞµÑˆĞ°ĞµĞ¼ Ğ¿Ñ€ĞµÑ€Ñ‹Ğ²Ğ°Ğ½Ğ¸Ñ
    â”‚       â”‚       â”‚       serial_puts("[IDT] Interrupts enabled\n");
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   void isr_install_handler(uint8_t num, isr_handler_t handler) {
    â”‚       â”‚       â”‚       isr_handlers[num] = handler;
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       char buffer[16];
    â”‚       â”‚       â”‚       serial_puts("[IDT] Installed handler for interrupt ");
    â”‚       â”‚       â”‚       serial_puts(itoa(num, buffer, 10));
    â”‚       â”‚       â”‚       serial_puts("\n");
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   void isr_uninstall_handler(uint8_t num) {
    â”‚       â”‚       â”‚       isr_handlers[num] = NULL;
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   // Ğ¤ÑƒĞ½ĞºÑ†Ğ¸Ñ-Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº, Ğ²Ñ‹Ğ·Ñ‹Ğ²Ğ°ĞµĞ¼Ğ°Ñ Ğ¸Ğ· Ğ°ÑÑĞµĞ¼Ğ±Ğ»ĞµÑ€Ğ°
    â”‚       â”‚       â”‚   void isr_handler(struct registers *regs) {
    â”‚       â”‚       â”‚       if (isr_handlers[regs->int_no] != NULL) {
    â”‚       â”‚       â”‚           isr_handlers[regs->int_no](regs);
    â”‚       â”‚       â”‚       } else {
    â”‚       â”‚       â”‚           if (regs->int_no >= 32 && regs->int_no < 48) {
    â”‚       â”‚       â”‚               // Ğ­Ñ‚Ğ¾ IRQ - Ğ¿ĞµÑ€ĞµĞ´Ğ°ĞµĞ¼ Ğ² irq_handler
    â”‚       â”‚       â”‚               irq_handler(regs);
    â”‚       â”‚       â”‚           } else {
    â”‚       â”‚       â”‚               // ĞĞµĞ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°Ğ½Ğ½Ğ¾Ğµ Ğ¸ÑĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ
    â”‚       â”‚       â”‚               char buffer[64];
    â”‚       â”‚       â”‚               serial_puts("[ISR] No handler for interrupt ");
    â”‚       â”‚       â”‚               serial_puts(itoa(regs->int_no, buffer, 10));
    â”‚       â”‚       â”‚               serial_puts("\n");
    â”‚       â”‚       â”‚               
    â”‚       â”‚       â”‚               if (regs->int_no < 32) {
    â”‚       â”‚       â”‚                   serial_puts("[ISR] Unhandled exception! System halted.\n");
    â”‚       â”‚       â”‚                   for(;;) {
    â”‚       â”‚       â”‚                       asm volatile("hlt");
    â”‚       â”‚       â”‚                   }
    â”‚       â”‚       â”‚               }
    â”‚       â”‚       â”‚           }
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚
    â”‚       â”‚   â”œâ”€â”€ irq.c
    â”‚       â”‚       â”‚
    â”‚       â”‚       â”œâ”€â”€ CONTENT:
    â”‚       â”‚       â”‚   #include "include/interrupts/irq.h"
    â”‚       â”‚       â”‚   #include "include/drivers/pic.h"
    â”‚       â”‚       â”‚   #include "include/interrupts/idt.h"
    â”‚       â”‚       â”‚   #include "include/drivers/serial.h"
    â”‚       â”‚       â”‚   #include "libc/string.h"
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   static isr_handler_t irq_handlers[16] = {0};
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   // ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº Ğ¿Ğ¾ ÑƒĞ¼Ğ¾Ğ»Ñ‡Ğ°Ğ½Ğ¸Ñ Ğ´Ğ»Ñ IRQ (Ğ¾Ğ±ÑŠÑĞ²Ğ»ÑĞµĞ¼ ĞŸĞ•Ğ Ğ’Ğ«Ğœ)
    â”‚       â”‚       â”‚   void irq_default_handler(struct registers *regs) {
    â”‚       â”‚       â”‚       char buffer[64];
    â”‚       â”‚       â”‚       serial_puts("[IRQ] Default handler for IRQ");
    â”‚       â”‚       â”‚       serial_puts(itoa(regs->int_no - 32, buffer, 10));
    â”‚       â”‚       â”‚       serial_puts("\n");
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   // Ğ“Ğ»Ğ°Ğ²Ğ½Ñ‹Ğ¹ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº IRQ
    â”‚       â”‚       â”‚   void irq_handler(struct registers *regs) {
    â”‚       â”‚       â”‚       uint8_t irq_num = regs->int_no - 32;
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Ğ’Ñ‹Ğ·Ñ‹Ğ²Ğ°ĞµĞ¼ Ğ·Ğ°Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğ¹ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº
    â”‚       â”‚       â”‚       if (irq_handlers[irq_num] != NULL) {
    â”‚       â”‚       â”‚           irq_handlers[irq_num](regs);
    â”‚       â”‚       â”‚       } else {
    â”‚       â”‚       â”‚           irq_default_handler(regs);
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑĞµĞ¼ EOI Ğ² PIC
    â”‚       â”‚       â”‚       pic_send_eoi(irq_num);
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   void irq_init(void) {
    â”‚       â”‚       â”‚       serial_puts("[IRQ] Initializing IRQ handlers...\n");
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Ğ£ÑÑ‚Ğ°Ğ½Ğ°Ğ²Ğ»Ğ¸Ğ²Ğ°ĞµĞ¼ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸ĞºĞ¸ Ğ¿Ğ¾ ÑƒĞ¼Ğ¾Ğ»Ñ‡Ğ°Ğ½Ğ¸Ñ
    â”‚       â”‚       â”‚       for (int i = 0; i < 16; i++) {
    â”‚       â”‚       â”‚           irq_install_handler(i, irq_default_handler);
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       serial_puts("[IRQ] IRQ handlers initialized\n");
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   void irq_install_handler(uint8_t irq, isr_handler_t handler) {
    â”‚       â”‚       â”‚       if (irq < 16) {
    â”‚       â”‚       â”‚           irq_handlers[irq] = handler;
    â”‚       â”‚       â”‚           
    â”‚       â”‚       â”‚           char buffer[16];
    â”‚       â”‚       â”‚           serial_puts("[IRQ] Installed handler for IRQ");
    â”‚       â”‚       â”‚           serial_puts(itoa(irq, buffer, 10));
    â”‚       â”‚       â”‚           serial_puts("\n");
    â”‚       â”‚       â”‚           
    â”‚       â”‚       â”‚           // Ğ Ğ°Ğ·Ğ¼Ğ°ÑĞºĞ¸Ñ€ÑƒĞµĞ¼ IRQ
    â”‚       â”‚       â”‚           pic_unmask_irq(irq);
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   void irq_uninstall_handler(uint8_t irq) {
    â”‚       â”‚       â”‚       if (irq < 16) {
    â”‚       â”‚       â”‚           irq_handlers[irq] = NULL;
    â”‚       â”‚       â”‚           // ĞœĞ°ÑĞºĞ¸Ñ€ÑƒĞµĞ¼ IRQ
    â”‚       â”‚       â”‚           pic_mask_irq(irq);
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚
    â”‚       â”‚   â”œâ”€â”€ isr.c
    â”‚       â”‚       â”‚
    â”‚       â”‚       â”œâ”€â”€ CONTENT:
    â”‚       â”‚       â”‚   #include "include/interrupts/isr.h"
    â”‚       â”‚       â”‚   #include "include/interrupts/idt.h"  // <-- Ğ”ĞĞ‘ĞĞ’Ğ¬ Ğ­Ğ¢Ğ£ Ğ¡Ğ¢Ğ ĞĞšĞ£
    â”‚       â”‚       â”‚   #include "include/drivers/serial.h"
    â”‚       â”‚       â”‚   #include "libc/string.h"
    â”‚       â”‚       â”‚   #include "libc/stdio.h"
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   // Ğ¡Ğ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ñ Ğ¾Ğ± Ğ¸ÑĞºĞ»ÑÑ‡ĞµĞ½Ğ¸ÑÑ…
    â”‚       â”‚       â”‚   static const char *exception_messages[32] = {
    â”‚       â”‚       â”‚       "Division By Zero",
    â”‚       â”‚       â”‚       "Debug",
    â”‚       â”‚       â”‚       "Non Maskable Interrupt",
    â”‚       â”‚       â”‚       "Breakpoint",
    â”‚       â”‚       â”‚       "Into Detected Overflow",
    â”‚       â”‚       â”‚       "Out of Bounds",
    â”‚       â”‚       â”‚       "Invalid Opcode",
    â”‚       â”‚       â”‚       "No Coprocessor",
    â”‚       â”‚       â”‚       "Double Fault",
    â”‚       â”‚       â”‚       "Coprocessor Segment Overrun",
    â”‚       â”‚       â”‚       "Bad TSS",
    â”‚       â”‚       â”‚       "Segment Not Present",
    â”‚       â”‚       â”‚       "Stack Fault",
    â”‚       â”‚       â”‚       "General Protection Fault",
    â”‚       â”‚       â”‚       "Page Fault",
    â”‚       â”‚       â”‚       "Unknown Interrupt",
    â”‚       â”‚       â”‚       "Coprocessor Fault",
    â”‚       â”‚       â”‚       "Alignment Check",
    â”‚       â”‚       â”‚       "Machine Check",
    â”‚       â”‚       â”‚       "Reserved",
    â”‚       â”‚       â”‚       "Reserved",
    â”‚       â”‚       â”‚       "Reserved",
    â”‚       â”‚       â”‚       "Reserved",
    â”‚       â”‚       â”‚       "Reserved",
    â”‚       â”‚       â”‚       "Reserved",
    â”‚       â”‚       â”‚       "Reserved",
    â”‚       â”‚       â”‚       "Reserved",
    â”‚       â”‚       â”‚       "Reserved",
    â”‚       â”‚       â”‚       "Reserved",
    â”‚       â”‚       â”‚       "Reserved",
    â”‚       â”‚       â”‚       "Reserved",
    â”‚       â”‚       â”‚       "Reserved"
    â”‚       â”‚       â”‚   };
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   void exception_handler(struct registers *regs) {
    â”‚       â”‚       â”‚       // Ğ”Ğ»Ñ ĞºÑ€Ğ¸Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ñ… Ğ¸ÑĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğ¹ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ ÑĞ¿ĞµÑ†Ğ¸Ğ°Ğ»ÑŒĞ½Ñ‹Ğµ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸ĞºĞ¸
    â”‚       â”‚       â”‚       // Ğ”Ğ»Ñ Ğ¾ÑÑ‚Ğ°Ğ»ÑŒĞ½Ñ‹Ñ… - Ğ¾Ğ±Ñ‰Ğ¸Ğ¹ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       if (regs->int_no < 32) {
    â”‚       â”‚       â”‚           printf("\n=== EXCEPTION %d ===\n", regs->int_no);
    â”‚       â”‚       â”‚           printf("%s\n", exception_messages[regs->int_no]);
    â”‚       â”‚       â”‚           printf("Error Code: 0x%x\n", regs->err_code);
    â”‚       â”‚       â”‚           printf("RIP: 0x%x\n", regs->rip);
    â”‚       â”‚       â”‚           
    â”‚       â”‚       â”‚           // Ğ”Ğ»Ñ Page Fault Ğ²Ñ‹Ğ²Ğ¾Ğ´Ğ¸Ğ¼ Ğ´Ğ¾Ğ¿Ğ¾Ğ»Ğ½Ğ¸Ñ‚ĞµĞ»ÑŒĞ½ÑƒÑ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ
    â”‚       â”‚       â”‚           if (regs->int_no == EXCEPTION_PAGE_FAULT) {
    â”‚       â”‚       â”‚               uint64_t cr2;
    â”‚       â”‚       â”‚               asm volatile("mov %%cr2, %0" : "=r"(cr2));
    â”‚       â”‚       â”‚               printf("Fault Address: 0x%x\n", cr2);
    â”‚       â”‚       â”‚           }
    â”‚       â”‚       â”‚           
    â”‚       â”‚       â”‚           // Ğ”Ğ»Ñ Ğ½ĞµĞºÑ€Ğ¸Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ñ… Ğ¸ÑĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğ¹ Ğ¿Ñ€Ğ¾Ğ´Ğ¾Ğ»Ğ¶Ğ°ĞµĞ¼ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñƒ
    â”‚       â”‚       â”‚           if (regs->int_no == EXCEPTION_BREAKPOINT || regs->int_no == EXCEPTION_OVERFLOW) {
    â”‚       â”‚       â”‚               printf("Non-critical exception, continuing...\n");
    â”‚       â”‚       â”‚               return;
    â”‚       â”‚       â”‚           }
    â”‚       â”‚       â”‚           
    â”‚       â”‚       â”‚           printf("System Halted.\n");
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Ğ—Ğ°Ğ²Ğ¸ÑĞ°ĞµĞ¼ Ğ¿Ñ€Ğ¸ ĞºÑ€Ğ¸Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¾Ğ¼ Ğ¸ÑĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğ¸
    â”‚       â”‚       â”‚       for(;;) {
    â”‚       â”‚       â”‚           asm volatile("hlt");
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚
    â”‚       â”‚   â””â”€â”€ isr_asm.S
    â”‚       â”‚       â”‚
    â”‚       â”‚       â”œâ”€â”€ CONTENT:
    â”‚       â”‚       â”‚   .section .text
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   // ĞœĞ°ĞºÑ€Ğ¾Ñ Ğ´Ğ»Ñ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ Ğ·Ğ°Ğ³Ğ»ÑƒÑˆĞºĞ¸ Ğ±ĞµĞ· ĞºĞ¾Ğ´Ğ° Ğ¾ÑˆĞ¸Ğ±ĞºĞ¸
    â”‚       â”‚       â”‚   .macro ISR_NOERRCODE index
    â”‚       â”‚       â”‚       .global isr_stub_\index
    â”‚       â”‚       â”‚       .type isr_stub_\index, @function
    â”‚       â”‚       â”‚   isr_stub_\index:
    â”‚       â”‚       â”‚       push $0                    // ĞŸÑƒÑÑ‚Ğ¾Ğ¹ ĞºĞ¾Ğ´ Ğ¾ÑˆĞ¸Ğ±ĞºĞ¸
    â”‚       â”‚       â”‚       push $\index               // ĞĞ¾Ğ¼ĞµÑ€ Ğ¿Ñ€ĞµÑ€Ñ‹Ğ²Ğ°Ğ½Ğ¸Ñ
    â”‚       â”‚       â”‚       jmp isr_common_stub
    â”‚       â”‚       â”‚   .endm
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   // ĞœĞ°ĞºÑ€Ğ¾Ñ Ğ´Ğ»Ñ ÑĞ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ñ Ğ·Ğ°Ğ³Ğ»ÑƒÑˆĞºĞ¸ Ñ ĞºĞ¾Ğ´Ğ¾Ğ¼ Ğ¾ÑˆĞ¸Ğ±ĞºĞ¸
    â”‚       â”‚       â”‚   .macro ISR_ERRCODE index
    â”‚       â”‚       â”‚       .global isr_stub_\index
    â”‚       â”‚       â”‚       .type isr_stub_\index, @function
    â”‚       â”‚       â”‚   isr_stub_\index:
    â”‚       â”‚       â”‚       push $\index               // ĞĞ¾Ğ¼ĞµÑ€ Ğ¿Ñ€ĞµÑ€Ñ‹Ğ²Ğ°Ğ½Ğ¸Ñ (ĞºĞ¾Ğ´ Ğ¾ÑˆĞ¸Ğ±ĞºĞ¸ ÑƒĞ¶Ğµ Ğ² ÑÑ‚ĞµĞºĞµ)
    â”‚       â”‚       â”‚       jmp isr_common_stub
    â”‚       â”‚       â”‚   .endm
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   // Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ğ·Ğ°Ğ³Ğ»ÑƒÑˆĞºĞ¸ Ğ´Ğ»Ñ Ğ¸ÑĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğ¹
    â”‚       â”‚       â”‚   ISR_NOERRCODE 0
    â”‚       â”‚       â”‚   ISR_NOERRCODE 1
    â”‚       â”‚       â”‚   ISR_NOERRCODE 2
    â”‚       â”‚       â”‚   ISR_NOERRCODE 3
    â”‚       â”‚       â”‚   ISR_NOERRCODE 4
    â”‚       â”‚       â”‚   ISR_NOERRCODE 5
    â”‚       â”‚       â”‚   ISR_NOERRCODE 6
    â”‚       â”‚       â”‚   ISR_NOERRCODE 7
    â”‚       â”‚       â”‚   ISR_ERRCODE   8
    â”‚       â”‚       â”‚   ISR_NOERRCODE 9
    â”‚       â”‚       â”‚   ISR_ERRCODE   10
    â”‚       â”‚       â”‚   ISR_ERRCODE   11
    â”‚       â”‚       â”‚   ISR_ERRCODE   12
    â”‚       â”‚       â”‚   ISR_ERRCODE   13
    â”‚       â”‚       â”‚   ISR_ERRCODE   14
    â”‚       â”‚       â”‚   ISR_NOERRCODE 15
    â”‚       â”‚       â”‚   ISR_NOERRCODE 16
    â”‚       â”‚       â”‚   ISR_NOERRCODE 17
    â”‚       â”‚       â”‚   ISR_NOERRCODE 18
    â”‚       â”‚       â”‚   ISR_NOERRCODE 19
    â”‚       â”‚       â”‚   ISR_NOERRCODE 20
    â”‚       â”‚       â”‚   ISR_NOERRCODE 21
    â”‚       â”‚       â”‚   ISR_NOERRCODE 22
    â”‚       â”‚       â”‚   ISR_NOERRCODE 23
    â”‚       â”‚       â”‚   ISR_NOERRCODE 24
    â”‚       â”‚       â”‚   ISR_NOERRCODE 25
    â”‚       â”‚       â”‚   ISR_NOERRCODE 26
    â”‚       â”‚       â”‚   ISR_NOERRCODE 27
    â”‚       â”‚       â”‚   ISR_NOERRCODE 28
    â”‚       â”‚       â”‚   ISR_NOERRCODE 29
    â”‚       â”‚       â”‚   ISR_NOERRCODE 30
    â”‚       â”‚       â”‚   ISR_NOERRCODE 31
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   // Ğ¡Ğ¾Ğ·Ğ´Ğ°ĞµĞ¼ Ğ·Ğ°Ğ³Ğ»ÑƒÑˆĞºĞ¸ Ğ´Ğ»Ñ IRQ (32-47)
    â”‚       â”‚       â”‚   ISR_NOERRCODE 32
    â”‚       â”‚       â”‚   ISR_NOERRCODE 33
    â”‚       â”‚       â”‚   ISR_NOERRCODE 34
    â”‚       â”‚       â”‚   ISR_NOERRCODE 35
    â”‚       â”‚       â”‚   ISR_NOERRCODE 36
    â”‚       â”‚       â”‚   ISR_NOERRCODE 37
    â”‚       â”‚       â”‚   ISR_NOERRCODE 38
    â”‚       â”‚       â”‚   ISR_NOERRCODE 39
    â”‚       â”‚       â”‚   ISR_NOERRCODE 40
    â”‚       â”‚       â”‚   ISR_NOERRCODE 41
    â”‚       â”‚       â”‚   ISR_NOERRCODE 42
    â”‚       â”‚       â”‚   ISR_NOERRCODE 43
    â”‚       â”‚       â”‚   ISR_NOERRCODE 44
    â”‚       â”‚       â”‚   ISR_NOERRCODE 45
    â”‚       â”‚       â”‚   ISR_NOERRCODE 46
    â”‚       â”‚       â”‚   ISR_NOERRCODE 47
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   // ĞĞ±Ñ‰Ğ¸Ğ¹ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº Ğ´Ğ»Ñ Ğ²ÑĞµÑ… Ğ¿Ñ€ĞµÑ€Ñ‹Ğ²Ğ°Ğ½Ğ¸Ğ¹
    â”‚       â”‚       â”‚   .extern isr_handler
    â”‚       â”‚       â”‚   .type isr_common_stub, @function
    â”‚       â”‚       â”‚   isr_common_stub:
    â”‚       â”‚       â”‚       // Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ Ğ²ÑĞµ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ñ‹
    â”‚       â”‚       â”‚       push %r15
    â”‚       â”‚       â”‚       push %r14
    â”‚       â”‚       â”‚       push %r13
    â”‚       â”‚       â”‚       push %r12
    â”‚       â”‚       â”‚       push %r11
    â”‚       â”‚       â”‚       push %r10
    â”‚       â”‚       â”‚       push %r9
    â”‚       â”‚       â”‚       push %r8
    â”‚       â”‚       â”‚       push %rdi
    â”‚       â”‚       â”‚       push %rsi
    â”‚       â”‚       â”‚       push %rbp
    â”‚       â”‚       â”‚       push %rbx
    â”‚       â”‚       â”‚       push %rdx
    â”‚       â”‚       â”‚       push %rcx
    â”‚       â”‚       â”‚       push %rax
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Ğ’Ñ‹Ğ·Ñ‹Ğ²Ğ°ĞµĞ¼ C-Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº
    â”‚       â”‚       â”‚       mov %rsp, %rdi
    â”‚       â”‚       â”‚       call isr_handler
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Ğ’Ğ¾ÑÑÑ‚Ğ°Ğ½Ğ°Ğ²Ğ»Ğ¸Ğ²Ğ°ĞµĞ¼ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ñ‹
    â”‚       â”‚       â”‚       pop %rax
    â”‚       â”‚       â”‚       pop %rcx
    â”‚       â”‚       â”‚       pop %rdx
    â”‚       â”‚       â”‚       pop %rbx
    â”‚       â”‚       â”‚       pop %rbp
    â”‚       â”‚       â”‚       pop %rsi
    â”‚       â”‚       â”‚       pop %rdi
    â”‚       â”‚       â”‚       pop %r8
    â”‚       â”‚       â”‚       pop %r9
    â”‚       â”‚       â”‚       pop %r10
    â”‚       â”‚       â”‚       pop %r11
    â”‚       â”‚       â”‚       pop %r12
    â”‚       â”‚       â”‚       pop %r13
    â”‚       â”‚       â”‚       pop %r14
    â”‚       â”‚       â”‚       pop %r15
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // ĞÑ‡Ğ¸Ñ‰Ğ°ĞµĞ¼ Ğ½Ğ¾Ğ¼ĞµÑ€ Ğ¿Ñ€ĞµÑ€Ñ‹Ğ²Ğ°Ğ½Ğ¸Ñ Ğ¸ ĞºĞ¾Ğ´ Ğ¾ÑˆĞ¸Ğ±ĞºĞ¸
    â”‚       â”‚       â”‚       add $16, %rsp
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       iretq
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   // Ğ—Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ° IDT
    â”‚       â”‚       â”‚   .global idt_flush
    â”‚       â”‚       â”‚   .type idt_flush, @function
    â”‚       â”‚       â”‚   idt_flush:
    â”‚       â”‚       â”‚       lidt (%rdi)
    â”‚       â”‚       â”‚       ret
    â”‚       â”‚       â”‚
    â”‚       â”œâ”€â”€ kernel.c
    â”‚           â”‚
    â”‚           â”œâ”€â”€ CONTENT:
    â”‚           â”‚   #include <stdint.h>
    â”‚           â”‚   #include <stdbool.h>
    â”‚           â”‚   #include <stddef.h>
    â”‚           â”‚   #include <limine.h>
    â”‚           â”‚   #include "include/graphics/fb.h"
    â”‚           â”‚   #include "include/graphics/color.h"
    â”‚           â”‚   #include "include/graphics/font.h"
    â”‚           â”‚   #include "include/drivers/serial.h"
    â”‚           â”‚   #include "include/graphics/banner.h"
    â”‚           â”‚   #include "include/drivers/io.h"
    â”‚           â”‚   #include "include/sys/gdt.h"
    â”‚           â”‚   #include "libc/string.h"
    â”‚           â”‚   #include "libc/stdio.h"
    â”‚           â”‚   #include "include/interrupts/idt.h"
    â”‚           â”‚   #include "include/interrupts/isr.h"
    â”‚           â”‚   #include "include/drivers/pic.h"
    â”‚           â”‚   #include "include/drivers/pit.h"
    â”‚           â”‚   #include "include/interrupts/irq.h"
    â”‚           â”‚   #include "include/memory/paging.h"
    â”‚           â”‚   #include "include/memory/heap.h"
    â”‚           â”‚   #include "include/memory/pmm.h"
    â”‚           â”‚   #include "include/memory/security.h"
    â”‚           â”‚   
    â”‚           â”‚   __attribute__((used, section(".limine_requests")))
    â”‚           â”‚   static volatile LIMINE_BASE_REVISION(3);
    â”‚           â”‚   
    â”‚           â”‚   __attribute__((used, section(".limine_requests")))
    â”‚           â”‚   static volatile struct limine_framebuffer_request framebuffer_request = {
    â”‚           â”‚       .id = LIMINE_FRAMEBUFFER_REQUEST,
    â”‚           â”‚       .revision = 0
    â”‚           â”‚   };
    â”‚           â”‚   
    â”‚           â”‚   __attribute__((used, section(".limine_requests")))
    â”‚           â”‚   static volatile struct limine_hhdm_request hhdm_request = {
    â”‚           â”‚       .id = LIMINE_HHDM_REQUEST,
    â”‚           â”‚       .revision = 0
    â”‚           â”‚   };
    â”‚           â”‚   
    â”‚           â”‚   __attribute__((used, section(".limine_requests")))
    â”‚           â”‚   static volatile struct limine_memmap_request memmap_request = {
    â”‚           â”‚       .id = LIMINE_MEMMAP_REQUEST,
    â”‚           â”‚       .revision = 0
    â”‚           â”‚   };
    â”‚           â”‚   
    â”‚           â”‚   __attribute__((used, section(".limine_requests_start")))
    â”‚           â”‚   static volatile LIMINE_REQUESTS_START_MARKER;
    â”‚           â”‚   
    â”‚           â”‚   __attribute__((used, section(".limine_requests_end")))
    â”‚           â”‚   static volatile LIMINE_REQUESTS_END_MARKER;
    â”‚           â”‚   
    â”‚           â”‚   static volatile struct limine_hhdm_response *hhdm_response = NULL;
    â”‚           â”‚   static volatile struct limine_memmap_response *memmap_response = NULL;
    â”‚           â”‚   
    â”‚           â”‚   void test_process1(void) {
    â”‚           â”‚       while (1) {
    â”‚           â”‚           printf("Process 1 running\n");
    â”‚           â”‚           for (volatile int i = 0; i < 1000000; i++);
    â”‚           â”‚       }
    â”‚           â”‚   }
    â”‚           â”‚   
    â”‚           â”‚   void test_process2(void) {
    â”‚           â”‚       while (1) {
    â”‚           â”‚           printf("Process 2 running\n");  
    â”‚           â”‚           for (volatile int i = 0; i < 1000000; i++);
    â”‚           â”‚       }
    â”‚           â”‚   }
    â”‚           â”‚   
    â”‚           â”‚   void kernel_main(void) {
    â”‚           â”‚       serial_init();
    â”‚           â”‚       serial_puts("[DEER] Kernel started\n");
    â”‚           â”‚   
    â”‚           â”‚       hhdm_response = hhdm_request.response;
    â”‚           â”‚       memmap_response = memmap_request.response;
    â”‚           â”‚       
    â”‚           â”‚       if (!hhdm_response) {
    â”‚           â”‚           serial_puts("[DEER] ERROR: No HHDM response from bootloader!\n");
    â”‚           â”‚       } else {
    â”‚           â”‚           serial_puts("[DEER] HHDM available\n");
    â”‚           â”‚       }
    â”‚           â”‚       
    â”‚           â”‚       if (!memmap_response) {
    â”‚           â”‚           serial_puts("[DEER] ERROR: No memory map response from bootloader!\n");
    â”‚           â”‚       } else {
    â”‚           â”‚           serial_puts("[DEER] Memory map available\n");
    â”‚           â”‚       }
    â”‚           â”‚       
    â”‚           â”‚       serial_puts("[DEER] Initializing GDT...\n");
    â”‚           â”‚       gdt_init();
    â”‚           â”‚       gdt_load();
    â”‚           â”‚       serial_puts("[DEER] GDT initialized\n");
    â”‚           â”‚   
    â”‚           â”‚       serial_puts("[DEER] Initializing paging...\n");
    â”‚           â”‚       paging_init(hhdm_response);
    â”‚           â”‚       serial_puts("[DEER] Paging initialized\n");
    â”‚           â”‚   
    â”‚           â”‚       serial_puts("[DEER] Initializing memory(PMM/HEAP)...\n");
    â”‚           â”‚       pmm_init(memmap_response, hhdm_response);
    â”‚           â”‚       heap_init();
    â”‚           â”‚       serial_puts("[DEER] Memory initialized\n");
    â”‚           â”‚       serial_puts("[DEER] Initializing memory security...\n");
    â”‚           â”‚       memory_security_init();
    â”‚           â”‚   
    â”‚           â”‚       // Ğ’ Ğ³Ğ»Ğ°Ğ²Ğ½Ğ¾Ğ¼ Ñ†Ğ¸ĞºĞ»Ğµ Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ¿ĞµÑ€Ğ¸Ğ¾Ğ´Ğ¸Ñ‡ĞµÑĞºĞ¸Ğµ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸
    â”‚           â”‚       static uint64_t last_security_check = 0;
    â”‚           â”‚       if (pit_get_ticks() - last_security_check > 1000) { // ĞšĞ°Ğ¶Ğ´ÑƒÑ ÑĞµĞºÑƒĞ½Ğ´Ñƒ
    â”‚           â”‚           memory_security_check();
    â”‚           â”‚           last_security_check = pit_get_ticks();
    â”‚           â”‚       }
    â”‚           â”‚       serial_puts("[DEER] Initializing PIC...\n");
    â”‚           â”‚       pic_remap();
    â”‚           â”‚       serial_puts("[DEER] PIC remapped\n");
    â”‚           â”‚   
    â”‚           â”‚       serial_puts("[DEER] Initializing IDT...\n");
    â”‚           â”‚       idt_init();
    â”‚           â”‚       serial_puts("[DEER] IDT initialized\n");
    â”‚           â”‚   
    â”‚           â”‚       serial_puts("[DEER] Initializing IRQ...\n");
    â”‚           â”‚       irq_init();
    â”‚           â”‚       serial_puts("[DEER] IRQ initialized\n");
    â”‚           â”‚   
    â”‚           â”‚       serial_puts("[DEER] Initializing PIT...\n");
    â”‚           â”‚       pit_init();
    â”‚           â”‚       serial_puts("[DEER] PIT initialized\n");
    â”‚           â”‚   
    â”‚           â”‚       serial_puts("[DEER] Installing timer handler...\n");
    â”‚           â”‚       irq_install_handler(0, pit_timer_handler);
    â”‚           â”‚       serial_puts("[DEER] Timer handler installed\n");
    â”‚           â”‚   
    â”‚           â”‚       serial_puts("[DEER] Enabling interrupts...\n");
    â”‚           â”‚       idt_load();
    â”‚           â”‚       serial_puts("[DEER] Interrupts enabled\n");
    â”‚           â”‚   
    â”‚           â”‚   
    â”‚           â”‚       serial_puts("[DEER] All subsystems initialized successfully\n");
    â”‚           â”‚       serial_puts("[DEER] Timer should tick every second...\n");
    â”‚           â”‚   
    â”‚           â”‚       struct limine_framebuffer *fb = NULL;
    â”‚           â”‚   
    â”‚           â”‚       if (framebuffer_request.response && framebuffer_request.response->framebuffer_count > 0) {
    â”‚           â”‚           fb = framebuffer_request.response->framebuffers[0];
    â”‚           â”‚           printf_init_with_framebuffer(fb);  
    â”‚           â”‚       }
    â”‚           â”‚       printf_set_color(COLOR_GREEN);
    â”‚           â”‚       printf_set_bg_color(COLOR_BLACK);
    â”‚           â”‚           
    â”‚           â”‚       printf_clear();
    â”‚           â”‚       printf_set_color(COLOR_ORANGE);
    â”‚           â”‚       printf("\n\nDEER OS v0.0.1\n");
    â”‚           â”‚       printf("===============\n\n");
    â”‚           â”‚       printf_set_color(COLOR_CYAN);
    â”‚           â”‚       printf("System Status:\n");
    â”‚           â”‚       printf("--------------\n");
    â”‚           â”‚       printf_set_color(COLOR_GREEN);
    â”‚           â”‚       printf("GDT: ACTIVE\n");
    â”‚           â”‚       printf("PAGING: ACTIVE\n");
    â”‚           â”‚       printf("PMM: READY\n");
    â”‚           â”‚       printf("IDT: ACTIVE\n");
    â”‚           â”‚       printf("PIC: REMAPPED\n");
    â”‚           â”‚       printf("PIT: INITIALIZED\n");
    â”‚           â”‚       printf("INTERRUPTS: ENABLED\n");
    â”‚           â”‚       
    â”‚           â”‚       printf("\n");
    â”‚           â”‚           
    â”‚           â”‚       printf_set_color(COLOR_GREEN);
    â”‚           â”‚       printf("All systems ready - Timer active\n");
    â”‚           â”‚           
    â”‚           â”‚       serial_puts("[DEER] Graphics initialized successfully\n");
    â”‚           â”‚   
    â”‚           â”‚       serial_puts("[DEER] Entering main kernel loop...\n");
    â”‚           â”‚       
    â”‚           â”‚       while(1) {   
    â”‚           â”‚           asm volatile("hlt");
    â”‚           â”‚       }
    â”‚           â”‚   }
    â”‚           â”‚
    â”‚       â”œâ”€â”€ libc
    â”‚       â”‚   â”œâ”€â”€ stdio
    â”‚       â”‚   â”‚   â””â”€â”€ printf.c
    â”‚       â”‚   â”‚       â”‚
    â”‚       â”‚   â”‚       â”œâ”€â”€ CONTENT:
    â”‚       â”‚   â”‚       â”‚   #include <stdarg.h>
    â”‚       â”‚   â”‚       â”‚   #include <stdint.h>
    â”‚       â”‚   â”‚       â”‚   #include <stddef.h>
    â”‚       â”‚   â”‚       â”‚   #include "../stdio.h"
    â”‚       â”‚   â”‚       â”‚   #include "../../include/graphics/fb.h"
    â”‚       â”‚   â”‚       â”‚   #include "../../include/graphics/font.h"
    â”‚       â”‚   â”‚       â”‚   #include "../../include/graphics/color.h"
    â”‚       â”‚   â”‚       â”‚   #include "../../include/drivers/serial.h"
    â”‚       â”‚   â”‚       â”‚   #include "../string.h"
    â”‚       â”‚   â”‚       â”‚   #include <limine.h>
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   // Ğ“Ğ»Ğ¾Ğ±Ğ°Ğ»ÑŒĞ½Ñ‹Ğµ Ğ¿ĞµÑ€ĞµĞ¼ĞµĞ½Ğ½Ñ‹Ğµ Ğ´Ğ»Ñ Ñ‚ĞµĞºÑƒÑ‰ĞµĞ³Ğ¾ Ñ„Ñ€ĞµĞ¹Ğ¼Ğ±ÑƒÑ„ĞµÑ€Ğ° Ğ¸ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸ ĞºÑƒÑ€ÑĞ¾Ñ€Ğ°
    â”‚       â”‚   â”‚       â”‚   static struct limine_framebuffer *current_fb = NULL;
    â”‚       â”‚   â”‚       â”‚   static uint32_t cursor_x = 5;
    â”‚       â”‚   â”‚       â”‚   static uint32_t cursor_y = 5;
    â”‚       â”‚   â”‚       â”‚   static uint32_t text_color = COLOR_WHITE;
    â”‚       â”‚   â”‚       â”‚   static uint32_t bg_color = COLOR_BLACK;
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   // Ğ¤Ğ»Ğ°Ğ³ Ğ¸Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ğ¸
    â”‚       â”‚   â”‚       â”‚   static int printf_initialized = 0;
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   // ĞĞ°Ñˆ ÑĞ¾Ğ±ÑÑ‚Ğ²ĞµĞ½Ğ½Ñ‹Ğ¹ Ğ·Ğ°Ğ¿Ñ€Ğ¾Ñ Ñ„Ñ€ĞµĞ¹Ğ¼Ğ±ÑƒÑ„ĞµÑ€Ğ°
    â”‚       â”‚   â”‚       â”‚   static volatile struct limine_framebuffer_request fb_request = {
    â”‚       â”‚   â”‚       â”‚       .id = LIMINE_FRAMEBUFFER_REQUEST,
    â”‚       â”‚   â”‚       â”‚       .revision = 0
    â”‚       â”‚   â”‚       â”‚   };
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   // ĞĞ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ°Ñ Ğ¸Ğ½Ğ¸Ñ†Ğ¸Ğ°Ğ»Ğ¸Ğ·Ğ°Ñ†Ğ¸Ñ printf
    â”‚       â”‚   â”‚       â”‚   static void printf_auto_init(void) {
    â”‚       â”‚   â”‚       â”‚       if (printf_initialized) return;
    â”‚       â”‚   â”‚       â”‚       
    â”‚       â”‚   â”‚       â”‚       // ĞŸÑ‹Ñ‚Ğ°ĞµĞ¼ÑÑ Ğ¿Ğ¾Ğ»ÑƒÑ‡Ğ¸Ñ‚ÑŒ Ñ„Ñ€ĞµĞ¹Ğ¼Ğ±ÑƒÑ„ĞµÑ€ Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸
    â”‚       â”‚   â”‚       â”‚       if (fb_request.response && fb_request.response->framebuffer_count > 0) {
    â”‚       â”‚   â”‚       â”‚           current_fb = fb_request.response->framebuffers[0];
    â”‚       â”‚   â”‚       â”‚           serial_puts("[PRINTF] Auto-initialized with framebuffer\n");
    â”‚       â”‚   â”‚       â”‚       } else {
    â”‚       â”‚   â”‚       â”‚           serial_puts("[PRINTF] WARNING: No framebuffer available, using serial only\n");
    â”‚       â”‚   â”‚       â”‚       }
    â”‚       â”‚   â”‚       â”‚       
    â”‚       â”‚   â”‚       â”‚       printf_initialized = 1;
    â”‚       â”‚   â”‚       â”‚   }
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   // Ğ£ÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞ° Ñ‚ĞµĞºÑƒÑ‰ĞµĞ³Ğ¾ Ñ„Ñ€ĞµĞ¹Ğ¼Ğ±ÑƒÑ„ĞµÑ€Ğ°
    â”‚       â”‚   â”‚       â”‚   void printf_set_framebuffer(struct limine_framebuffer *fb) {
    â”‚       â”‚   â”‚       â”‚       current_fb = fb;
    â”‚       â”‚   â”‚       â”‚       printf_initialized = 1;
    â”‚       â”‚   â”‚       â”‚       
    â”‚       â”‚   â”‚       â”‚       char buffer[32];
    â”‚       â”‚   â”‚       â”‚       serial_puts("[PRINTF] Framebuffer set manually at 0x");
    â”‚       â”‚   â”‚       â”‚       serial_puts(itoa((uint64_t)fb, buffer, 16));
    â”‚       â”‚   â”‚       â”‚       serial_puts("\n");
    â”‚       â”‚   â”‚       â”‚   }
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   // Ğ£ÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞ° Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸ ĞºÑƒÑ€ÑĞ¾Ñ€Ğ°
    â”‚       â”‚   â”‚       â”‚   void printf_set_cursor(uint32_t x, uint32_t y) {
    â”‚       â”‚   â”‚       â”‚       cursor_x = x;
    â”‚       â”‚   â”‚       â”‚       cursor_y = y;
    â”‚       â”‚   â”‚       â”‚   }
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   // Ğ£ÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞ° Ñ†Ğ²ĞµÑ‚Ğ° Ñ‚ĞµĞºÑÑ‚Ğ°
    â”‚       â”‚   â”‚       â”‚   void printf_set_color(uint32_t color) {
    â”‚       â”‚   â”‚       â”‚       text_color = color;
    â”‚       â”‚   â”‚       â”‚   }
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   // Ğ£ÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºĞ° Ñ†Ğ²ĞµÑ‚Ğ° Ñ„Ğ¾Ğ½Ğ°
    â”‚       â”‚   â”‚       â”‚   void printf_set_bg_color(uint32_t color) {
    â”‚       â”‚   â”‚       â”‚       bg_color = color;
    â”‚       â”‚   â”‚       â”‚   }
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   // ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ñ‚ĞµĞºÑƒÑ‰ĞµĞ¹ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸ ĞºÑƒÑ€ÑĞ¾Ñ€Ğ°
    â”‚       â”‚   â”‚       â”‚   void printf_get_cursor(uint32_t *x, uint32_t *y) {
    â”‚       â”‚   â”‚       â”‚       *x = cursor_x;
    â”‚       â”‚   â”‚       â”‚       *y = cursor_y;
    â”‚       â”‚   â”‚       â”‚   }
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   // ĞŸÑ€Ğ¾ĞºÑ€ÑƒÑ‚ĞºĞ° ÑĞºÑ€Ğ°Ğ½Ğ°
    â”‚       â”‚   â”‚       â”‚   static void scroll_screen(void) {
    â”‚       â”‚   â”‚       â”‚       if (!current_fb) return;
    â”‚       â”‚   â”‚       â”‚       
    â”‚       â”‚   â”‚       â”‚       uint32_t scroll_height = 16; // Ğ’Ñ‹ÑĞ¾Ñ‚Ğ° Ğ¾Ğ´Ğ½Ğ¾Ğ¹ ÑÑ‚Ñ€Ğ¾ĞºĞ¸
    â”‚       â”‚   â”‚       â”‚       uint32_t screen_height = current_fb->height;
    â”‚       â”‚   â”‚       â”‚       uint32_t screen_width = current_fb->width;
    â”‚       â”‚   â”‚       â”‚       
    â”‚       â”‚   â”‚       â”‚       // ĞšĞ¾Ğ¿Ğ¸Ñ€ÑƒĞµĞ¼ ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ¸Ğ¼Ğ¾Ğµ ÑĞºÑ€Ğ°Ğ½Ğ° Ğ²Ğ²ĞµÑ€Ñ…
    â”‚       â”‚   â”‚       â”‚       for (uint32_t y = scroll_height; y < screen_height; y++) {
    â”‚       â”‚   â”‚       â”‚           for (uint32_t x = 0; x < screen_width; x++) {
    â”‚       â”‚   â”‚       â”‚               uint32_t *fb_ptr = (uint32_t *)current_fb->address;
    â”‚       â”‚   â”‚       â”‚               uint32_t pitch = current_fb->pitch / 4;
    â”‚       â”‚   â”‚       â”‚               fb_ptr[(y - scroll_height) * pitch + x] = fb_ptr[y * pitch + x];
    â”‚       â”‚   â”‚       â”‚           }
    â”‚       â”‚   â”‚       â”‚       }
    â”‚       â”‚   â”‚       â”‚       
    â”‚       â”‚   â”‚       â”‚       // ĞÑ‡Ğ¸Ñ‰Ğ°ĞµĞ¼ Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½ÑÑ ÑÑ‚Ñ€Ğ¾ĞºÑƒ
    â”‚       â”‚   â”‚       â”‚       for (uint32_t y = screen_height - scroll_height; y < screen_height; y++) {
    â”‚       â”‚   â”‚       â”‚           for (uint32_t x = 0; x < screen_width; x++) {
    â”‚       â”‚   â”‚       â”‚               fb_draw_pixel(current_fb, x, y, bg_color);
    â”‚       â”‚   â”‚       â”‚           }
    â”‚       â”‚   â”‚       â”‚       }
    â”‚       â”‚   â”‚       â”‚       
    â”‚       â”‚   â”‚       â”‚       // ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ñ ĞºÑƒÑ€ÑĞ¾Ñ€Ğ°
    â”‚       â”‚   â”‚       â”‚       cursor_y -= scroll_height;
    â”‚       â”‚   â”‚       â”‚   }
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   // ĞÑ‡Ğ¸ÑÑ‚ĞºĞ° ÑĞºÑ€Ğ°Ğ½Ğ°
    â”‚       â”‚   â”‚       â”‚   void printf_clear(void) {
    â”‚       â”‚   â”‚       â”‚       printf_auto_init();
    â”‚       â”‚   â”‚       â”‚       
    â”‚       â”‚   â”‚       â”‚       if (!current_fb) return;
    â”‚       â”‚   â”‚       â”‚       
    â”‚       â”‚   â”‚       â”‚       fb_clear(current_fb, bg_color);
    â”‚       â”‚   â”‚       â”‚       cursor_x = 5;
    â”‚       â”‚   â”‚       â”‚       cursor_y = 5;
    â”‚       â”‚   â”‚       â”‚   }
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   // Ğ’Ñ‹Ğ²Ğ¾Ğ´ Ğ¾Ğ´Ğ½Ğ¾Ğ³Ğ¾ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ° Ñ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ¾Ğ¹ ÑĞ¿ĞµÑ†Ğ¸Ğ°Ğ»ÑŒĞ½Ñ‹Ñ… ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ¾Ğ²
    â”‚       â”‚   â”‚       â”‚   static void putchar(char c) {
    â”‚       â”‚   â”‚       â”‚       printf_auto_init();
    â”‚       â”‚   â”‚       â”‚       
    â”‚       â”‚   â”‚       â”‚       // Ğ’ÑĞµĞ³Ğ´Ğ° Ğ²Ñ‹Ğ²Ğ¾Ğ´Ğ¸Ğ¼ Ğ² serial Ğ´Ğ»Ñ Ğ¾Ñ‚Ğ»Ğ°Ğ´ĞºĞ¸
    â”‚       â”‚   â”‚       â”‚       if (c == '\n') {
    â”‚       â”‚   â”‚       â”‚           serial_putc('\r');
    â”‚       â”‚   â”‚       â”‚       }
    â”‚       â”‚   â”‚       â”‚       serial_putc(c);
    â”‚       â”‚   â”‚       â”‚       
    â”‚       â”‚   â”‚       â”‚       if (!current_fb) return;
    â”‚       â”‚   â”‚       â”‚       
    â”‚       â”‚   â”‚       â”‚       switch (c) {
    â”‚       â”‚   â”‚       â”‚           case '\n': // ĞĞ¾Ğ²Ğ°Ñ ÑÑ‚Ñ€Ğ¾ĞºĞ°
    â”‚       â”‚   â”‚       â”‚               cursor_x = 5;
    â”‚       â”‚   â”‚       â”‚               cursor_y += 16;
    â”‚       â”‚   â”‚       â”‚               break;
    â”‚       â”‚   â”‚       â”‚               
    â”‚       â”‚   â”‚       â”‚           case '\r': // Ğ’Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‚ ĞºĞ°Ñ€ĞµÑ‚ĞºĞ¸
    â”‚       â”‚   â”‚       â”‚               cursor_x = 5;
    â”‚       â”‚   â”‚       â”‚               break;
    â”‚       â”‚   â”‚       â”‚               
    â”‚       â”‚   â”‚       â”‚           case '\t': // Ğ¢Ğ°Ğ±ÑƒĞ»ÑÑ†Ğ¸Ñ
    â”‚       â”‚   â”‚       â”‚               cursor_x = (cursor_x + 32) & ~31; // Ğ’Ñ‹Ñ€Ğ°Ğ²Ğ½Ğ¸Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ´Ğ¾ 32 Ğ¿Ğ¸ĞºÑĞµĞ»ĞµĞ¹
    â”‚       â”‚   â”‚       â”‚               break;
    â”‚       â”‚   â”‚       â”‚               
    â”‚       â”‚   â”‚       â”‚           case '\b': // Backspace
    â”‚       â”‚   â”‚       â”‚               if (cursor_x > 5) {
    â”‚       â”‚   â”‚       â”‚                   cursor_x -= 8;
    â”‚       â”‚   â”‚       â”‚                   // Ğ¡Ñ‚Ğ¸Ñ€Ğ°ĞµĞ¼ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»
    â”‚       â”‚   â”‚       â”‚                   fb_fill_rect(current_fb, cursor_x, cursor_y, 8, 16, bg_color);
    â”‚       â”‚   â”‚       â”‚               }
    â”‚       â”‚   â”‚       â”‚               break;
    â”‚       â”‚   â”‚       â”‚               
    â”‚       â”‚   â”‚       â”‚           default:
    â”‚       â”‚   â”‚       â”‚               // ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼, Ğ½Ğµ Ğ²Ñ‹ÑˆĞ»Ğ¸ Ğ»Ğ¸ Ğ¼Ñ‹ Ğ·Ğ° Ğ³Ñ€Ğ°Ğ½Ğ¸Ñ†Ñ‹ ÑĞºÑ€Ğ°Ğ½Ğ°
    â”‚       â”‚   â”‚       â”‚               if (cursor_x + 8 >= current_fb->width) {
    â”‚       â”‚   â”‚       â”‚                   cursor_x = 5;
    â”‚       â”‚   â”‚       â”‚                   cursor_y += 16;
    â”‚       â”‚   â”‚       â”‚               }
    â”‚       â”‚   â”‚       â”‚               
    â”‚       â”‚   â”‚       â”‚               if (cursor_y + 16 >= current_fb->height) {
    â”‚       â”‚   â”‚       â”‚                   scroll_screen();
    â”‚       â”‚   â”‚       â”‚               }
    â”‚       â”‚   â”‚       â”‚               
    â”‚       â”‚   â”‚       â”‚               // Ğ’Ñ‹Ğ²Ğ¾Ğ´Ğ¸Ğ¼ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»
    â”‚       â”‚   â”‚       â”‚               fb_draw_char(current_fb, c, cursor_x, cursor_y, text_color);
    â”‚       â”‚   â”‚       â”‚               cursor_x += 8;
    â”‚       â”‚   â”‚       â”‚               break;
    â”‚       â”‚   â”‚       â”‚       }
    â”‚       â”‚   â”‚       â”‚   }
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   // Ğ’ÑĞ¿Ğ¾Ğ¼Ğ¾Ğ³Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ğ°Ñ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ´Ğ»Ñ Ğ²Ñ‹Ğ²Ğ¾Ğ´Ğ° ÑÑ‚Ñ€Ğ¾ĞºĞ¸
    â”‚       â”‚   â”‚       â”‚   static void putstring(const char *str) {
    â”‚       â”‚   â”‚       â”‚       while (*str) {
    â”‚       â”‚   â”‚       â”‚           putchar(*str++);
    â”‚       â”‚   â”‚       â”‚       }
    â”‚       â”‚   â”‚       â”‚   }
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   // Ğ’ÑĞ¿Ğ¾Ğ¼Ğ¾Ğ³Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ğ°Ñ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ´Ğ»Ñ Ğ²Ñ‹Ğ²Ğ¾Ğ´Ğ° Ñ‡Ğ¸ÑĞ»Ğ° Ğ² ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ½Ğ¾Ğ¹ ÑĞ¸ÑÑ‚ĞµĞ¼Ğµ ÑÑ‡Ğ¸ÑĞ»ĞµĞ½Ğ¸Ñ
    â”‚       â”‚   â”‚       â”‚   static void putnumber(uint64_t num, int base, int is_signed, int is_long) {
    â”‚       â”‚   â”‚       â”‚       (void)is_long; // ĞŸĞ¾Ğ¼ĞµÑ‡Ğ°ĞµĞ¼ Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€ ĞºĞ°Ğº Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ½Ñ‹Ğ¹
    â”‚       â”‚   â”‚       â”‚       
    â”‚       â”‚   â”‚       â”‚       char buffer[65];
    â”‚       â”‚   â”‚       â”‚       
    â”‚       â”‚   â”‚       â”‚       if (is_signed && (int64_t)num < 0) {
    â”‚       â”‚   â”‚       â”‚           putchar('-');
    â”‚       â”‚   â”‚       â”‚           num = (uint64_t)(-(int64_t)num);
    â”‚       â”‚   â”‚       â”‚       }
    â”‚       â”‚   â”‚       â”‚       
    â”‚       â”‚   â”‚       â”‚       // ĞŸÑ€ĞµĞ¾Ğ±Ñ€Ğ°Ğ·ÑƒĞµĞ¼ Ñ‡Ğ¸ÑĞ»Ğ¾ Ğ² ÑÑ‚Ñ€Ğ¾ĞºÑƒ
    â”‚       â”‚   â”‚       â”‚       itoa(num, buffer, base);
    â”‚       â”‚   â”‚       â”‚       
    â”‚       â”‚   â”‚       â”‚       // Ğ’Ñ‹Ğ²Ğ¾Ğ´Ğ¸Ğ¼ ÑÑ‚Ñ€Ğ¾ĞºÑƒ
    â”‚       â”‚   â”‚       â”‚       putstring(buffer);
    â”‚       â”‚   â”‚       â”‚   }
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   // ĞÑĞ½Ğ¾Ğ²Ğ½Ğ°Ñ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ printf
    â”‚       â”‚   â”‚       â”‚   int printf(const char *format, ...) {
    â”‚       â”‚   â”‚       â”‚       printf_auto_init();
    â”‚       â”‚   â”‚       â”‚       
    â”‚       â”‚   â”‚       â”‚       va_list args;
    â”‚       â”‚   â”‚       â”‚       va_start(args, format);
    â”‚       â”‚   â”‚       â”‚       
    â”‚       â”‚   â”‚       â”‚       int chars_written = 0;
    â”‚       â”‚   â”‚       â”‚       
    â”‚       â”‚   â”‚       â”‚       while (*format) {
    â”‚       â”‚   â”‚       â”‚           if (*format == '%') {
    â”‚       â”‚   â”‚       â”‚               format++;
    â”‚       â”‚   â”‚       â”‚               
    â”‚       â”‚   â”‚       â”‚               // ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ñ„Ğ»Ğ°Ğ³Ğ¾Ğ²
    â”‚       â”‚   â”‚       â”‚               int is_long = 0;
    â”‚       â”‚   â”‚       â”‚               int is_alt = 0;
    â”‚       â”‚   â”‚       â”‚               
    â”‚       â”‚   â”‚       â”‚               while (1) {
    â”‚       â”‚   â”‚       â”‚                   switch (*format) {
    â”‚       â”‚   â”‚       â”‚                       case 'l':
    â”‚       â”‚   â”‚       â”‚                           is_long = 1;
    â”‚       â”‚   â”‚       â”‚                           format++;
    â”‚       â”‚   â”‚       â”‚                           continue;
    â”‚       â”‚   â”‚       â”‚                       case '#':
    â”‚       â”‚   â”‚       â”‚                           is_alt = 1;
    â”‚       â”‚   â”‚       â”‚                           format++;
    â”‚       â”‚   â”‚       â”‚                           continue;
    â”‚       â”‚   â”‚       â”‚                       default:
    â”‚       â”‚   â”‚       â”‚                           break;
    â”‚       â”‚   â”‚       â”‚                   }
    â”‚       â”‚   â”‚       â”‚                   break;
    â”‚       â”‚   â”‚       â”‚               }
    â”‚       â”‚   â”‚       â”‚               
    â”‚       â”‚   â”‚       â”‚               // ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° ÑĞ¿ĞµÑ†Ğ¸Ñ„Ğ¸ĞºĞ°Ñ‚Ğ¾Ñ€Ğ¾Ğ²
    â”‚       â”‚   â”‚       â”‚               switch (*format) {
    â”‚       â”‚   â”‚       â”‚                   case 'd':
    â”‚       â”‚   â”‚       â”‚                   case 'i': { // Ğ¦ĞµĞ»Ğ¾Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾ ÑĞ¾ Ğ·Ğ½Ğ°ĞºĞ¾Ğ¼
    â”‚       â”‚   â”‚       â”‚                       if (is_long) {
    â”‚       â”‚   â”‚       â”‚                           int64_t num = va_arg(args, int64_t);
    â”‚       â”‚   â”‚       â”‚                           putnumber((uint64_t)num, 10, 1, is_long);
    â”‚       â”‚   â”‚       â”‚                       } else {
    â”‚       â”‚   â”‚       â”‚                           int num = va_arg(args, int);
    â”‚       â”‚   â”‚       â”‚                           putnumber((uint64_t)num, 10, 1, is_long);
    â”‚       â”‚   â”‚       â”‚                       }
    â”‚       â”‚   â”‚       â”‚                       chars_written++;
    â”‚       â”‚   â”‚       â”‚                       break;
    â”‚       â”‚   â”‚       â”‚                   }
    â”‚       â”‚   â”‚       â”‚                   
    â”‚       â”‚   â”‚       â”‚                   case 'u': { // Ğ¦ĞµĞ»Ğ¾Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾ Ğ±ĞµĞ· Ğ·Ğ½Ğ°ĞºĞ°
    â”‚       â”‚   â”‚       â”‚                       if (is_long) {
    â”‚       â”‚   â”‚       â”‚                           uint64_t num = va_arg(args, uint64_t);
    â”‚       â”‚   â”‚       â”‚                           putnumber(num, 10, 0, is_long);
    â”‚       â”‚   â”‚       â”‚                       } else {
    â”‚       â”‚   â”‚       â”‚                           unsigned int num = va_arg(args, unsigned int);
    â”‚       â”‚   â”‚       â”‚                           putnumber(num, 10, 0, is_long);
    â”‚       â”‚   â”‚       â”‚                       }
    â”‚       â”‚   â”‚       â”‚                       chars_written++;
    â”‚       â”‚   â”‚       â”‚                       break;
    â”‚       â”‚   â”‚       â”‚                   }
    â”‚       â”‚   â”‚       â”‚                   
    â”‚       â”‚   â”‚       â”‚                   case 'x': { // Ğ¨ĞµÑÑ‚Ğ½Ğ°Ğ´Ñ†Ğ°Ñ‚ĞµÑ€Ğ¸Ñ‡Ğ½Ğ¾Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾
    â”‚       â”‚   â”‚       â”‚                       if (is_long) {
    â”‚       â”‚   â”‚       â”‚                           uint64_t num = va_arg(args, uint64_t);
    â”‚       â”‚   â”‚       â”‚                           if (is_alt) putstring("0x");
    â”‚       â”‚   â”‚       â”‚                           putnumber(num, 16, 0, is_long);
    â”‚       â”‚   â”‚       â”‚                       } else {
    â”‚       â”‚   â”‚       â”‚                           unsigned int num = va_arg(args, unsigned int);
    â”‚       â”‚   â”‚       â”‚                           if (is_alt) putstring("0x");
    â”‚       â”‚   â”‚       â”‚                           putnumber(num, 16, 0, is_long);
    â”‚       â”‚   â”‚       â”‚                       }
    â”‚       â”‚   â”‚       â”‚                       chars_written++;
    â”‚       â”‚   â”‚       â”‚                       break;
    â”‚       â”‚   â”‚       â”‚                   }
    â”‚       â”‚   â”‚       â”‚                   
    â”‚       â”‚   â”‚       â”‚                   case 'o': { // Ğ’Ğ¾ÑÑŒĞ¼ĞµÑ€Ğ¸Ñ‡Ğ½Ğ¾Ğµ Ñ‡Ğ¸ÑĞ»Ğ¾
    â”‚       â”‚   â”‚       â”‚                       if (is_long) {
    â”‚       â”‚   â”‚       â”‚                           uint64_t num = va_arg(args, uint64_t);
    â”‚       â”‚   â”‚       â”‚                           if (is_alt) putstring("0");
    â”‚       â”‚   â”‚       â”‚                           putnumber(num, 8, 0, is_long);
    â”‚       â”‚   â”‚       â”‚                       } else {
    â”‚       â”‚   â”‚       â”‚                           unsigned int num = va_arg(args, unsigned int);
    â”‚       â”‚   â”‚       â”‚                           if (is_alt) putstring("0");
    â”‚       â”‚   â”‚       â”‚                           putnumber(num, 8, 0, is_long);
    â”‚       â”‚   â”‚       â”‚                       }
    â”‚       â”‚   â”‚       â”‚                       chars_written++;
    â”‚       â”‚   â”‚       â”‚                       break;
    â”‚       â”‚   â”‚       â”‚                   }
    â”‚       â”‚   â”‚       â”‚                   
    â”‚       â”‚   â”‚       â”‚                   case 'p': { // Ğ£ĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»ÑŒ
    â”‚       â”‚   â”‚       â”‚                       void *ptr = va_arg(args, void*);
    â”‚       â”‚   â”‚       â”‚                       putstring("0x");
    â”‚       â”‚   â”‚       â”‚                       putnumber((uint64_t)ptr, 16, 0, 1);
    â”‚       â”‚   â”‚       â”‚                       chars_written++;
    â”‚       â”‚   â”‚       â”‚                       break;
    â”‚       â”‚   â”‚       â”‚                   }
    â”‚       â”‚   â”‚       â”‚                   
    â”‚       â”‚   â”‚       â”‚                   case 'c': { // Ğ¡Ğ¸Ğ¼Ğ²Ğ¾Ğ»
    â”‚       â”‚   â”‚       â”‚                       char c = (char)va_arg(args, int);
    â”‚       â”‚   â”‚       â”‚                       putchar(c);
    â”‚       â”‚   â”‚       â”‚                       chars_written++;
    â”‚       â”‚   â”‚       â”‚                       break;
    â”‚       â”‚   â”‚       â”‚                   }
    â”‚       â”‚   â”‚       â”‚                   
    â”‚       â”‚   â”‚       â”‚                   case 's': { // Ğ¡Ñ‚Ñ€Ğ¾ĞºĞ°
    â”‚       â”‚   â”‚       â”‚                       char *str = va_arg(args, char*);
    â”‚       â”‚   â”‚       â”‚                       if (!str) {
    â”‚       â”‚   â”‚       â”‚                           putstring("(null)");
    â”‚       â”‚   â”‚       â”‚                       } else {
    â”‚       â”‚   â”‚       â”‚                           putstring(str);
    â”‚       â”‚   â”‚       â”‚                       }
    â”‚       â”‚   â”‚       â”‚                       chars_written++;
    â”‚       â”‚   â”‚       â”‚                       break;
    â”‚       â”‚   â”‚       â”‚                   }
    â”‚       â”‚   â”‚       â”‚                   
    â”‚       â”‚   â”‚       â”‚                   case '%': { // Ğ¡Ğ¸Ğ¼Ğ²Ğ¾Ğ» Ğ¿Ñ€Ğ¾Ñ†ĞµĞ½Ñ‚Ğ°
    â”‚       â”‚   â”‚       â”‚                       putchar('%');
    â”‚       â”‚   â”‚       â”‚                       chars_written++;
    â”‚       â”‚   â”‚       â”‚                       break;
    â”‚       â”‚   â”‚       â”‚                   }
    â”‚       â”‚   â”‚       â”‚                   
    â”‚       â”‚   â”‚       â”‚                   default: // ĞĞµĞ¸Ğ·Ğ²ĞµÑÑ‚Ğ½Ñ‹Ğ¹ ÑĞ¿ĞµÑ†Ğ¸Ñ„Ğ¸ĞºĞ°Ñ‚Ğ¾Ñ€
    â”‚       â”‚   â”‚       â”‚                       putchar('%');
    â”‚       â”‚   â”‚       â”‚                       putchar(*format);
    â”‚       â”‚   â”‚       â”‚                       chars_written += 2;
    â”‚       â”‚   â”‚       â”‚                       break;
    â”‚       â”‚   â”‚       â”‚               }
    â”‚       â”‚   â”‚       â”‚           } else {
    â”‚       â”‚   â”‚       â”‚               // ĞĞ±Ñ‹Ñ‡Ğ½Ñ‹Ğ¹ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»
    â”‚       â”‚   â”‚       â”‚               putchar(*format);
    â”‚       â”‚   â”‚       â”‚               chars_written++;
    â”‚       â”‚   â”‚       â”‚           }
    â”‚       â”‚   â”‚       â”‚           
    â”‚       â”‚   â”‚       â”‚           format++;
    â”‚       â”‚   â”‚       â”‚       }
    â”‚       â”‚   â”‚       â”‚       
    â”‚       â”‚   â”‚       â”‚       va_end(args);
    â”‚       â”‚   â”‚       â”‚       return chars_written;
    â”‚       â”‚   â”‚       â”‚   }
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   // Ğ£Ğ¿Ñ€Ğ¾Ñ‰ĞµĞ½Ğ½Ğ°Ñ Ğ²ĞµÑ€ÑĞ¸Ñ printf Ğ´Ğ»Ñ ÑÑ‚Ñ€Ğ¾ĞºĞ¸
    â”‚       â”‚   â”‚       â”‚   int puts(const char *str) {
    â”‚       â”‚   â”‚       â”‚       int result = printf("%s\n", str);
    â”‚       â”‚   â”‚       â”‚       return result;
    â”‚       â”‚   â”‚       â”‚   }
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   void printf_init_with_framebuffer(struct limine_framebuffer *fb) {
    â”‚       â”‚   â”‚       â”‚       current_fb = fb;
    â”‚       â”‚   â”‚       â”‚       printf_initialized = 1;
    â”‚       â”‚   â”‚       â”‚       serial_puts("[PRINTF] Initialized with framebuffer\n");
    â”‚       â”‚   â”‚       â”‚   }
    â”‚       â”‚   â”‚       â”‚
    â”‚       â”‚   â”œâ”€â”€ stdio.h
    â”‚       â”‚       â”‚
    â”‚       â”‚       â”œâ”€â”€ CONTENT:
    â”‚       â”‚       â”‚   #ifndef STDIO_H
    â”‚       â”‚       â”‚   #define STDIO_H
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   #include <stdint.h>
    â”‚       â”‚       â”‚   #include <stddef.h>
    â”‚       â”‚       â”‚   #include <limine.h>
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   // Ğ¤ÑƒĞ½ĞºÑ†Ğ¸Ğ¸ ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ Ğ²Ñ‹Ğ²Ğ¾Ğ´Ğ¾Ğ¼
    â”‚       â”‚       â”‚   void printf_set_framebuffer(struct limine_framebuffer *fb);
    â”‚       â”‚       â”‚   void printf_set_cursor(uint32_t x, uint32_t y);
    â”‚       â”‚       â”‚   void printf_set_color(uint32_t color);
    â”‚       â”‚       â”‚   void printf_set_bg_color(uint32_t color);
    â”‚       â”‚       â”‚   void printf_get_cursor(uint32_t *x, uint32_t *y);
    â”‚       â”‚       â”‚   void printf_clear(void);
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   // ĞÑĞ½Ğ¾Ğ²Ğ½Ñ‹Ğµ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¸ Ğ²Ñ‹Ğ²Ğ¾Ğ´Ğ°
    â”‚       â”‚       â”‚   int printf(const char *format, ...);
    â”‚       â”‚       â”‚   int puts(const char *str);
    â”‚       â”‚       â”‚   void printf_init_with_framebuffer(struct limine_framebuffer *fb);
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   #endif // STDIO_H
    â”‚       â”‚       â”‚
    â”‚       â”‚   â”œâ”€â”€ string
    â”‚       â”‚   â”‚   â”œâ”€â”€ itoa.c
    â”‚       â”‚   â”‚       â”‚
    â”‚       â”‚   â”‚       â”œâ”€â”€ CONTENT:
    â”‚       â”‚   â”‚       â”‚   #include <stdint.h>
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   char* itoa(uint64_t value, char* str, int base) {
    â”‚       â”‚   â”‚       â”‚       if (base < 2 || base > 16) {
    â”‚       â”‚   â”‚       â”‚           str[0] = '\0';
    â”‚       â”‚   â”‚       â”‚           return str;
    â”‚       â”‚   â”‚       â”‚       }
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚       char* ptr = str;
    â”‚       â”‚   â”‚       â”‚       char* end = str;
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚       if (value == 0) {
    â”‚       â”‚   â”‚       â”‚           *end++ = '0';
    â”‚       â”‚   â”‚       â”‚       } else {
    â”‚       â”‚   â”‚       â”‚           while (value > 0) {
    â”‚       â”‚   â”‚       â”‚               int digit = value % base;
    â”‚       â”‚   â”‚       â”‚               *end++ = (digit < 10 ? '0' + digit : 'a' + digit - 10);
    â”‚       â”‚   â”‚       â”‚               value /= base;
    â”‚       â”‚   â”‚       â”‚           }
    â”‚       â”‚   â”‚       â”‚       }
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚       // Ğ Ğ°Ğ·Ğ²Ğ¾Ñ€Ğ°Ñ‡Ğ¸Ğ²Ğ°ĞµĞ¼ ÑÑ‚Ñ€Ğ¾ĞºÑƒ
    â”‚       â”‚   â”‚       â”‚       *end = '\0';
    â”‚       â”‚   â”‚       â”‚       end--;
    â”‚       â”‚   â”‚       â”‚       while (ptr < end) {
    â”‚       â”‚   â”‚       â”‚           char tmp = *ptr;
    â”‚       â”‚   â”‚       â”‚           *ptr = *end;
    â”‚       â”‚   â”‚       â”‚           *end = tmp;
    â”‚       â”‚   â”‚       â”‚           ptr++;
    â”‚       â”‚   â”‚       â”‚           end--;
    â”‚       â”‚   â”‚       â”‚       }
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚       return str;
    â”‚       â”‚   â”‚       â”‚   }
    â”‚       â”‚   â”‚       â”‚
    â”‚       â”‚   â”‚   â”œâ”€â”€ memcmp.c
    â”‚       â”‚   â”‚       â”‚
    â”‚       â”‚   â”‚       â”œâ”€â”€ CONTENT:
    â”‚       â”‚   â”‚       â”‚   #include <stddef.h>
    â”‚       â”‚   â”‚       â”‚   #include <stdint.h>
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   int memcmp(const void *s1, const void *s2, size_t n) {
    â”‚       â”‚   â”‚       â”‚       const uint8_t *p1 = (const uint8_t *)s1;
    â”‚       â”‚   â”‚       â”‚       const uint8_t *p2 = (const uint8_t *)s2;
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚       for (size_t i = 0; i < n; i++) {
    â”‚       â”‚   â”‚       â”‚           if (p1[i] != p2[i]) {
    â”‚       â”‚   â”‚       â”‚               return p1[i] < p2[i] ? -1 : 1;
    â”‚       â”‚   â”‚       â”‚           }
    â”‚       â”‚   â”‚       â”‚       }
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚       return 0;
    â”‚       â”‚   â”‚       â”‚   }
    â”‚       â”‚   â”‚       â”‚
    â”‚       â”‚   â”‚   â”œâ”€â”€ memcpy.c
    â”‚       â”‚   â”‚       â”‚
    â”‚       â”‚   â”‚       â”œâ”€â”€ CONTENT:
    â”‚       â”‚   â”‚       â”‚   #include <stddef.h>
    â”‚       â”‚   â”‚       â”‚   #include <stdint.h>
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   void *memcpy(void *restrict dest, const void *restrict src, size_t n) {
    â”‚       â”‚   â”‚       â”‚       uint8_t *restrict pdest = (uint8_t *restrict)dest;
    â”‚       â”‚   â”‚       â”‚       const uint8_t *restrict psrc = (const uint8_t *restrict)src;
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚       for (size_t i = 0; i < n; i++) {
    â”‚       â”‚   â”‚       â”‚           pdest[i] = psrc[i];
    â”‚       â”‚   â”‚       â”‚       }
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚       return dest;
    â”‚       â”‚   â”‚       â”‚   }
    â”‚       â”‚   â”‚       â”‚
    â”‚       â”‚   â”‚   â”œâ”€â”€ memmove.c
    â”‚       â”‚   â”‚       â”‚
    â”‚       â”‚   â”‚       â”œâ”€â”€ CONTENT:
    â”‚       â”‚   â”‚       â”‚   #include <stddef.h>
    â”‚       â”‚   â”‚       â”‚   #include <stdint.h>
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   void *memmove(void *dest, const void *src, size_t n) {
    â”‚       â”‚   â”‚       â”‚       uint8_t *pdest = (uint8_t *)dest;
    â”‚       â”‚   â”‚       â”‚       const uint8_t *psrc = (const uint8_t *)src;
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚       if (src > dest) {
    â”‚       â”‚   â”‚       â”‚           for (size_t i = 0; i < n; i++) {
    â”‚       â”‚   â”‚       â”‚               pdest[i] = psrc[i];
    â”‚       â”‚   â”‚       â”‚           }
    â”‚       â”‚   â”‚       â”‚       } else if (src < dest) {
    â”‚       â”‚   â”‚       â”‚           for (size_t i = n; i > 0; i--) {
    â”‚       â”‚   â”‚       â”‚               pdest[i-1] = psrc[i-1];
    â”‚       â”‚   â”‚       â”‚           }
    â”‚       â”‚   â”‚       â”‚       }
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚       return dest;
    â”‚       â”‚   â”‚       â”‚   }
    â”‚       â”‚   â”‚       â”‚
    â”‚       â”‚   â”‚   â”œâ”€â”€ memset.c
    â”‚       â”‚   â”‚       â”‚
    â”‚       â”‚   â”‚       â”œâ”€â”€ CONTENT:
    â”‚       â”‚   â”‚       â”‚   #include <stddef.h>
    â”‚       â”‚   â”‚       â”‚   #include <stdint.h>
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   void *memset(void *s, int c, size_t n) {
    â”‚       â”‚   â”‚       â”‚       uint8_t *p = (uint8_t *)s;
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚       for (size_t i = 0; i < n; i++) {
    â”‚       â”‚   â”‚       â”‚           p[i] = (uint8_t)c;
    â”‚       â”‚   â”‚       â”‚       }
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚       return s;
    â”‚       â”‚   â”‚       â”‚   }
    â”‚       â”‚   â”‚       â”‚
    â”‚       â”‚   â”‚   â”œâ”€â”€ strcat.c
    â”‚       â”‚   â”‚       â”‚
    â”‚       â”‚   â”‚       â”œâ”€â”€ CONTENT:
    â”‚       â”‚   â”‚       â”‚   #include <stddef.h>
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   char* strcat(char* dest, const char* src) {
    â”‚       â”‚   â”‚       â”‚       char* ptr = dest;
    â”‚       â”‚   â”‚       â”‚       
    â”‚       â”‚   â”‚       â”‚       // ĞĞ°Ñ…Ğ¾Ğ´Ğ¸Ğ¼ ĞºĞ¾Ğ½ĞµÑ† dest
    â”‚       â”‚   â”‚       â”‚       while (*ptr != '\0') {
    â”‚       â”‚   â”‚       â”‚           ptr++;
    â”‚       â”‚   â”‚       â”‚       }
    â”‚       â”‚   â”‚       â”‚       
    â”‚       â”‚   â”‚       â”‚       // ĞšĞ¾Ğ¿Ğ¸Ñ€ÑƒĞµĞ¼ src Ğ² ĞºĞ¾Ğ½ĞµÑ† dest
    â”‚       â”‚   â”‚       â”‚       while (*src != '\0') {
    â”‚       â”‚   â”‚       â”‚           *ptr++ = *src++;
    â”‚       â”‚   â”‚       â”‚       }
    â”‚       â”‚   â”‚       â”‚       
    â”‚       â”‚   â”‚       â”‚       *ptr = '\0';
    â”‚       â”‚   â”‚       â”‚       return dest;
    â”‚       â”‚   â”‚       â”‚   }
    â”‚       â”‚   â”‚       â”‚
    â”‚       â”‚   â”‚   â”œâ”€â”€ strcpy.c
    â”‚       â”‚   â”‚       â”‚
    â”‚       â”‚   â”‚       â”œâ”€â”€ CONTENT:
    â”‚       â”‚   â”‚       â”‚   #include <stddef.h>
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   char* strcpy(char* dest, const char* src) {
    â”‚       â”‚   â”‚       â”‚       if (dest == NULL || src == NULL) {
    â”‚       â”‚   â”‚       â”‚           return NULL;
    â”‚       â”‚   â”‚       â”‚       }
    â”‚       â”‚   â”‚       â”‚       
    â”‚       â”‚   â”‚       â”‚       char* ptr = dest;
    â”‚       â”‚   â”‚       â”‚       while (*src != '\0') {
    â”‚       â”‚   â”‚       â”‚           *ptr++ = *src++;
    â”‚       â”‚   â”‚       â”‚       }
    â”‚       â”‚   â”‚       â”‚       *ptr = '\0';
    â”‚       â”‚   â”‚       â”‚       
    â”‚       â”‚   â”‚       â”‚       return dest;
    â”‚       â”‚   â”‚       â”‚   }
    â”‚       â”‚   â”‚       â”‚
    â”‚       â”‚   â”‚   â”œâ”€â”€ strlen.c
    â”‚       â”‚   â”‚       â”‚
    â”‚       â”‚   â”‚       â”œâ”€â”€ CONTENT:
    â”‚       â”‚   â”‚       â”‚   #include <stddef.h>
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   size_t strlen(const char *str) {
    â”‚       â”‚   â”‚       â”‚       size_t len = 0;
    â”‚       â”‚   â”‚       â”‚       while (str[len] != '\0') {
    â”‚       â”‚   â”‚       â”‚           len++;
    â”‚       â”‚   â”‚       â”‚       }
    â”‚       â”‚   â”‚       â”‚       return len;
    â”‚       â”‚   â”‚       â”‚   }
    â”‚       â”‚   â”‚       â”‚
    â”‚       â”‚   â”‚   â””â”€â”€ strncpy.c
    â”‚       â”‚   â”‚       â”‚
    â”‚       â”‚   â”‚       â”œâ”€â”€ CONTENT:
    â”‚       â”‚   â”‚       â”‚   #include <stddef.h>
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚   char* strncpy(char* dest, const char* src, size_t n) {
    â”‚       â”‚   â”‚       â”‚       if (dest == NULL || src == NULL) {
    â”‚       â”‚   â”‚       â”‚           return dest; // ĞĞµĞ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»ĞµĞ½Ğ½Ğ¾Ğµ Ğ¿Ğ¾Ğ²ĞµĞ´ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾ ÑÑ‚Ğ°Ğ½Ğ´Ğ°Ñ€Ñ‚Ñƒ, Ğ½Ğ¾ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰Ğ°ĞµĞ¼ dest
    â”‚       â”‚   â”‚       â”‚       }
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚       char* ptr = dest;
    â”‚       â”‚   â”‚       â”‚       size_t i = 0;
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚       // ĞšĞ¾Ğ¿Ğ¸Ñ€ÑƒĞµĞ¼ ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ñ‹ Ğ¸Ğ· src Ğ² dest, Ğ¿Ğ¾ĞºĞ° Ğ½Ğµ Ğ´Ğ¾ÑÑ‚Ğ¸Ğ³Ğ½ĞµĞ¼ ĞºĞ¾Ğ½Ñ†Ğ° src Ğ¸Ğ»Ğ¸ n ÑĞ¸Ğ¼Ğ²Ğ¾Ğ»Ğ¾Ğ²
    â”‚       â”‚   â”‚       â”‚       while (i < n && src[i] != '\0') {
    â”‚       â”‚   â”‚       â”‚           ptr[i] = src[i];
    â”‚       â”‚   â”‚       â”‚           i++;
    â”‚       â”‚   â”‚       â”‚       }
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚       // Ğ—Ğ°Ğ¿Ğ¾Ğ»Ğ½ÑĞµĞ¼ Ğ¾ÑÑ‚Ğ°Ğ²ÑˆĞ¸ĞµÑÑ Ğ¿Ğ¾Ğ·Ğ¸Ñ†Ğ¸Ğ¸ Ğ² dest Ğ½ÑƒĞ»ĞµĞ²Ñ‹Ğ¼Ğ¸ Ğ±Ğ°Ğ¹Ñ‚Ğ°Ğ¼Ğ¸
    â”‚       â”‚   â”‚       â”‚       while (i < n) {
    â”‚       â”‚   â”‚       â”‚           ptr[i] = '\0';
    â”‚       â”‚   â”‚       â”‚           i++;
    â”‚       â”‚   â”‚       â”‚       }
    â”‚       â”‚   â”‚       â”‚   
    â”‚       â”‚   â”‚       â”‚       return dest;
    â”‚       â”‚   â”‚       â”‚   }
    â”‚       â”‚   â”‚       â”‚
    â”‚       â”‚   â””â”€â”€ string.h
    â”‚       â”‚       â”‚
    â”‚       â”‚       â”œâ”€â”€ CONTENT:
    â”‚       â”‚       â”‚   #ifndef STRING_H
    â”‚       â”‚       â”‚   #define STRING_H
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   #include <stddef.h>
    â”‚       â”‚       â”‚   #include <stdint.h>
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   void *memcpy(void *restrict dest, const void *restrict src, size_t n);
    â”‚       â”‚       â”‚   void *memset(void *s, int c, size_t n);
    â”‚       â”‚       â”‚   void *memmove(void *dest, const void *src, size_t n);
    â”‚       â”‚       â”‚   int memcmp(const void *s1, const void *s2, size_t n);
    â”‚       â”‚       â”‚   char* itoa(uint64_t value, char* str, int base);
    â”‚       â”‚       â”‚   size_t strlen(const char *str);
    â”‚       â”‚       â”‚   char* strcat(char* dest, const char* src);
    â”‚       â”‚       â”‚   char* strcpy(char* dest, const char* src);
    â”‚       â”‚       â”‚   char* strncpy(char* dest, const char* src, size_t n);
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   #endif // STRING_H
    â”‚       â”‚       â”‚
    â”‚       â”œâ”€â”€ memory
    â”‚       â”‚   â”œâ”€â”€ heap.c
    â”‚       â”‚       â”‚
    â”‚       â”‚       â”œâ”€â”€ CONTENT:
    â”‚       â”‚       â”‚   #include "include/memory/heap.h"
    â”‚       â”‚       â”‚   #include "include/memory/paging.h"
    â”‚       â”‚       â”‚   #include "include/memory/pmm.h"
    â”‚       â”‚       â”‚   #include "include/drivers/serial.h"
    â”‚       â”‚       â”‚   #include "libc/string.h"
    â”‚       â”‚       â”‚   #include "libc/stdio.h"
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   static struct heap kernel_heap = {0};
    â”‚       â”‚       â”‚   static bool poisoning_enabled = true;
    â”‚       â”‚       â”‚   static bool guard_pages_enabled = false;
    â”‚       â”‚       â”‚   static bool lockdown_mode = false;
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   // Simple checksum function for integrity checking
    â”‚       â”‚       â”‚   static uint32_t calculate_checksum(struct heap_block* block) {
    â”‚       â”‚       â”‚       uint32_t sum = 0;
    â”‚       â”‚       â”‚       uint8_t* data = (uint8_t*)block;
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Skip checksum field itself in calculation
    â”‚       â”‚       â”‚       for (size_t i = 0; i < offsetof(struct heap_block, checksum); i++) {
    â”‚       â”‚       â”‚           sum = (sum << 3) ^ data[i];
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       for (size_t i = offsetof(struct heap_block, checksum) + sizeof(uint32_t); 
    â”‚       â”‚       â”‚            i < sizeof(struct heap_block); i++) {
    â”‚       â”‚       â”‚           sum = (sum << 3) ^ data[i];
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       return sum;
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   // Validate a single heap block
    â”‚       â”‚       â”‚   bool heap_validate_block(struct heap_block* block) {
    â”‚       â”‚       â”‚       if (!block) return false;
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Check canaries
    â”‚       â”‚       â”‚       if (block->canary_start != HEAP_CANARY_VALUE || 
    â”‚       â”‚       â”‚           block->canary_end != HEAP_CANARY_VALUE) {
    â”‚       â”‚       â”‚           kernel_heap.stats.buffer_overflow_detected++;
    â”‚       â”‚       â”‚           serial_puts("[HEAP SECURITY] Buffer overflow detected! Canary corrupted.\n");
    â”‚       â”‚       â”‚           return false;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Check checksum
    â”‚       â”‚       â”‚       uint32_t saved_checksum = block->checksum;
    â”‚       â”‚       â”‚       block->checksum = 0;
    â”‚       â”‚       â”‚       uint32_t calculated_checksum = calculate_checksum(block);
    â”‚       â”‚       â”‚       block->checksum = saved_checksum;
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       if (saved_checksum != calculated_checksum) {
    â”‚       â”‚       â”‚           kernel_heap.stats.corruption_count++;
    â”‚       â”‚       â”‚           serial_puts("[HEAP SECURITY] Heap block checksum mismatch! Memory corrupted.\n");
    â”‚       â”‚       â”‚           return false;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Check size validity
    â”‚       â”‚       â”‚       if (block->size > HEAP_MAX_ALLOC_SIZE || block->size < HEAP_MIN_ALLOC_SIZE) {
    â”‚       â”‚       â”‚           serial_puts("[HEAP SECURITY] Invalid block size detected!\n");
    â”‚       â”‚       â”‚           return false;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Check if block is within heap bounds
    â”‚       â”‚       â”‚       uint64_t block_addr = (uint64_t)block;
    â”‚       â”‚       â”‚       if (block_addr < (uint64_t)kernel_heap.start || 
    â”‚       â”‚       â”‚           block_addr >= (uint64_t)kernel_heap.end) {
    â”‚       â”‚       â”‚           serial_puts("[HEAP SECURITY] Block outside heap boundaries!\n");
    â”‚       â”‚       â”‚           return false;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       return true;
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   // Initialize a new heap block with security features
    â”‚       â”‚       â”‚   static void initialize_block(struct heap_block* block, size_t size, size_t requested_size, 
    â”‚       â”‚       â”‚                              bool used, uint8_t protection_flags) {
    â”‚       â”‚       â”‚       block->canary_start = HEAP_CANARY_VALUE;
    â”‚       â”‚       â”‚       block->size = size;
    â”‚       â”‚       â”‚       block->requested_size = requested_size;
    â”‚       â”‚       â”‚       block->used = used;
    â”‚       â”‚       â”‚       block->protection_flags = protection_flags;
    â”‚       â”‚       â”‚       block->next = NULL;
    â”‚       â”‚       â”‚       block->prev = NULL;
    â”‚       â”‚       â”‚       block->allocation_ptr = (void*)((uint8_t*)block + sizeof(struct heap_block));
    â”‚       â”‚       â”‚       block->canary_end = HEAP_CANARY_VALUE;
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Calculate and set checksum
    â”‚       â”‚       â”‚       block->checksum = 0;
    â”‚       â”‚       â”‚       block->checksum = calculate_checksum(block);
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Apply memory poisoning
    â”‚       â”‚       â”‚       if (poisoning_enabled) {
    â”‚       â”‚       â”‚           uint8_t poison = used ? HEAP_ALLOC_POISON : HEAP_FREE_POISON;
    â”‚       â”‚       â”‚           memset(block->allocation_ptr, poison, size);
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   // Find the best fit block with security validation
    â”‚       â”‚       â”‚   static struct heap_block* find_best_fit_block(size_t size) {
    â”‚       â”‚       â”‚       struct heap_block* current = kernel_heap.first_block;
    â”‚       â”‚       â”‚       struct heap_block* best_fit = NULL;
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       while (current != NULL) {
    â”‚       â”‚       â”‚           // Validate block before using it
    â”‚       â”‚       â”‚           if (!heap_validate_block(current)) {
    â”‚       â”‚       â”‚               serial_puts("[HEAP SECURITY] Corrupted block detected during allocation!\n");
    â”‚       â”‚       â”‚               return NULL;
    â”‚       â”‚       â”‚           }
    â”‚       â”‚       â”‚           
    â”‚       â”‚       â”‚           if (!current->used && current->size >= size) {
    â”‚       â”‚       â”‚               if (best_fit == NULL || current->size < best_fit->size) {
    â”‚       â”‚       â”‚                   best_fit = current;
    â”‚       â”‚       â”‚               }
    â”‚       â”‚       â”‚           }
    â”‚       â”‚       â”‚           current = current->next;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       return best_fit;
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   // Emergency lockdown when corruption is detected
    â”‚       â”‚       â”‚   void heap_emergency_lockdown(void) {
    â”‚       â”‚       â”‚       lockdown_mode = true;
    â”‚       â”‚       â”‚       serial_puts("[HEAP SECURITY] EMERGENCY LOCKDOWN ACTIVATED!\n");
    â”‚       â”‚       â”‚       serial_puts("[HEAP SECURITY] All further allocations are blocked.\n");
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Try to dump current state for debugging
    â”‚       â”‚       â”‚       heap_dump_blocks();
    â”‚       â”‚       â”‚       heap_print_stats();
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   // Enhanced heap initialization with security
    â”‚       â”‚       â”‚   void heap_init(void) {
    â”‚       â”‚       â”‚       if (lockdown_mode) {
    â”‚       â”‚       â”‚           serial_puts("[HEAP SECURITY] Cannot initialize - system in lockdown mode!\n");
    â”‚       â”‚       â”‚           return;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       serial_puts("[HEAP] Initializing secure kernel heap...\n");
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Initialize security statistics
    â”‚       â”‚       â”‚       memset(&kernel_heap.stats, 0, sizeof(kernel_heap.stats));
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Allocate initial pages with guard page protection
    â”‚       â”‚       â”‚       size_t initial_pages = HEAP_INITIAL_SIZE / PAGE_SIZE_4K;
    â”‚       â”‚       â”‚       if (guard_pages_enabled) {
    â”‚       â”‚       â”‚           initial_pages++; // Extra page for guard
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       for (size_t i = 0; i < initial_pages; i++) {
    â”‚       â”‚       â”‚           uint64_t physical_page = pmm_alloc_page();
    â”‚       â”‚       â”‚           if (!physical_page) {
    â”‚       â”‚       â”‚               serial_puts("[HEAP] ERROR: Failed to allocate initial heap pages!\n");
    â”‚       â”‚       â”‚               heap_emergency_lockdown();
    â”‚       â”‚       â”‚               return;
    â”‚       â”‚       â”‚           }
    â”‚       â”‚       â”‚           
    â”‚       â”‚       â”‚           uint64_t virtual_addr = HEAP_START + (i * PAGE_SIZE_4K);
    â”‚       â”‚       â”‚           uint64_t flags = PAGING_PRESENT | PAGING_WRITABLE;
    â”‚       â”‚       â”‚           
    â”‚       â”‚       â”‚           // Mark guard page as non-present
    â”‚       â”‚       â”‚           if (guard_pages_enabled && i == initial_pages - 1) {
    â”‚       â”‚       â”‚               flags = PAGING_NO_EXECUTE; // Guard page - no access
    â”‚       â”‚       â”‚           }
    â”‚       â”‚       â”‚           
    â”‚       â”‚       â”‚           if (!paging_map_page(virtual_addr, physical_page, flags)) {
    â”‚       â”‚       â”‚               serial_puts("[HEAP] ERROR: Failed to map heap page!\n");
    â”‚       â”‚       â”‚               pmm_free_page(physical_page);
    â”‚       â”‚       â”‚               heap_emergency_lockdown();
    â”‚       â”‚       â”‚               return;
    â”‚       â”‚       â”‚           }
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Initialize heap structure
    â”‚       â”‚       â”‚       kernel_heap.start = (void*)HEAP_START;
    â”‚       â”‚       â”‚       kernel_heap.end = (void*)(HEAP_START + HEAP_INITIAL_SIZE);
    â”‚       â”‚       â”‚       kernel_heap.total_size = HEAP_INITIAL_SIZE;
    â”‚       â”‚       â”‚       kernel_heap.used_size = sizeof(struct heap_block);
    â”‚       â”‚       â”‚       kernel_heap.alloc_count = 0;
    â”‚       â”‚       â”‚       kernel_heap.free_count = 0;
    â”‚       â”‚       â”‚       kernel_heap.corruption_count = 0;
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Create first free block with security features
    â”‚       â”‚       â”‚       struct heap_block* first_block = (struct heap_block*)HEAP_START;
    â”‚       â”‚       â”‚       size_t first_block_size = HEAP_INITIAL_SIZE - sizeof(struct heap_block);
    â”‚       â”‚       â”‚       initialize_block(first_block, first_block_size, 0, false, 0);
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       kernel_heap.first_block = first_block;
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       serial_puts("[HEAP] Secure kernel heap initialized with canaries and checksums\n");
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   // Secure memory allocation with comprehensive checking
    â”‚       â”‚       â”‚   void* kmalloc(size_t size) {
    â”‚       â”‚       â”‚       return kmalloc_protected(size, 0);
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   void* kmalloc_protected(size_t size, uint8_t protection_flags) {
    â”‚       â”‚       â”‚       if (lockdown_mode) {
    â”‚       â”‚       â”‚           serial_puts("[HEAP SECURITY] Allocation blocked - system in lockdown!\n");
    â”‚       â”‚       â”‚           kernel_heap.stats.failed_allocations++;
    â”‚       â”‚       â”‚           return NULL;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Input validation
    â”‚       â”‚       â”‚       if (size == 0 || size > HEAP_MAX_ALLOC_SIZE) {
    â”‚       â”‚       â”‚           serial_puts("[HEAP SECURITY] Invalid allocation size requested!\n");
    â”‚       â”‚       â”‚           kernel_heap.stats.failed_allocations++;
    â”‚       â”‚       â”‚           return NULL;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Align size
    â”‚       â”‚       â”‚       size = (size + HEAP_ALIGNMENT - 1) & ~(HEAP_ALIGNMENT - 1);
    â”‚       â”‚       â”‚       if (size < HEAP_MIN_ALLOC_SIZE) {
    â”‚       â”‚       â”‚           size = HEAP_MIN_ALLOC_SIZE;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Check heap integrity before allocation
    â”‚       â”‚       â”‚       if (!heap_validate_all_blocks()) {
    â”‚       â”‚       â”‚           serial_puts("[HEAP SECURITY] Heap corruption detected before allocation!\n");
    â”‚       â”‚       â”‚           heap_emergency_lockdown();
    â”‚       â”‚       â”‚           return NULL;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       struct heap_block* best_fit = find_best_fit_block(size);
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       if (best_fit == NULL) {
    â”‚       â”‚       â”‚           kernel_heap.stats.failed_allocations++;
    â”‚       â”‚       â”‚           serial_puts("[HEAP] No suitable block found, allocation failed\n");
    â”‚       â”‚       â”‚           return NULL;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Split block if it's significantly larger
    â”‚       â”‚       â”‚       if (best_fit->size >= size + sizeof(struct heap_block) + HEAP_MIN_ALLOC_SIZE) {
    â”‚       â”‚       â”‚           struct heap_block* new_block = (struct heap_block*)(
    â”‚       â”‚       â”‚               (uint8_t*)best_fit + sizeof(struct heap_block) + size);
    â”‚       â”‚       â”‚           
    â”‚       â”‚       â”‚           size_t new_block_size = best_fit->size - size - sizeof(struct heap_block);
    â”‚       â”‚       â”‚           initialize_block(new_block, new_block_size, 0, false, 0);
    â”‚       â”‚       â”‚           
    â”‚       â”‚       â”‚           new_block->next = best_fit->next;
    â”‚       â”‚       â”‚           new_block->prev = best_fit;
    â”‚       â”‚       â”‚           
    â”‚       â”‚       â”‚           if (best_fit->next != NULL) {
    â”‚       â”‚       â”‚               best_fit->next->prev = new_block;
    â”‚       â”‚       â”‚           }
    â”‚       â”‚       â”‚           
    â”‚       â”‚       â”‚           best_fit->size = size;
    â”‚       â”‚       â”‚           best_fit->next = new_block;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Mark block as used with protection flags
    â”‚       â”‚       â”‚       best_fit->used = true;
    â”‚       â”‚       â”‚       best_fit->protection_flags = protection_flags;
    â”‚       â”‚       â”‚       best_fit->requested_size = size;
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Update checksum for the modified block
    â”‚       â”‚       â”‚       best_fit->checksum = 0;
    â”‚       â”‚       â”‚       best_fit->checksum = calculate_checksum(best_fit);
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       kernel_heap.used_size += best_fit->size + sizeof(struct heap_block);
    â”‚       â”‚       â”‚       kernel_heap.alloc_count++;
    â”‚       â”‚       â”‚       kernel_heap.stats.total_allocations++;
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Apply memory poisoning
    â”‚       â”‚       â”‚       if (poisoning_enabled) {
    â”‚       â”‚       â”‚           memset(best_fit->allocation_ptr, HEAP_ALLOC_POISON, best_fit->size);
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Verify the allocation
    â”‚       â”‚       â”‚       if (!heap_validate_block(best_fit)) {
    â”‚       â”‚       â”‚           serial_puts("[HEAP SECURITY] Allocation created corrupted block!\n");
    â”‚       â”‚       â”‚           kfree(best_fit->allocation_ptr); // Clean up
    â”‚       â”‚       â”‚           return NULL;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       return best_fit->allocation_ptr;
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   // Secure memory deallocation
    â”‚       â”‚       â”‚   void kfree(void* ptr) {
    â”‚       â”‚       â”‚       if (lockdown_mode) {
    â”‚       â”‚       â”‚           serial_puts("[HEAP SECURITY] Free operation blocked - system in lockdown!\n");
    â”‚       â”‚       â”‚           return;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       if (ptr == NULL) {
    â”‚       â”‚       â”‚           return;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Get the block structure
    â”‚       â”‚       â”‚       struct heap_block* block = (struct heap_block*)((uint8_t*)ptr - sizeof(struct heap_block));
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Validate pointer before proceeding
    â”‚       â”‚       â”‚       if (!heap_is_valid_pointer(ptr)) {
    â”‚       â”‚       â”‚           serial_puts("[HEAP SECURITY] Invalid pointer passed to kfree!\n");
    â”‚       â”‚       â”‚           kernel_heap.stats.failed_allocations++;
    â”‚       â”‚       â”‚           return;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Validate block integrity
    â”‚       â”‚       â”‚       if (!heap_validate_block(block)) {
    â”‚       â”‚       â”‚           serial_puts("[HEAP SECURITY] Cannot free corrupted block!\n");
    â”‚       â”‚       â”‚           heap_emergency_lockdown();
    â”‚       â”‚       â”‚           return;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       if (!block->used) {
    â”‚       â”‚       â”‚           serial_puts("[HEAP SECURITY] Double free detected!\n");
    â”‚       â”‚       â”‚           kernel_heap.stats.double_free_attempts++;
    â”‚       â”‚       â”‚           heap_emergency_lockdown();
    â”‚       â”‚       â”‚           return;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Mark as free and update metadata
    â”‚       â”‚       â”‚       block->used = false;
    â”‚       â”‚       â”‚       block->protection_flags = 0;
    â”‚       â”‚       â”‚       kernel_heap.used_size -= block->size + sizeof(struct heap_block);
    â”‚       â”‚       â”‚       kernel_heap.free_count++;
    â”‚       â”‚       â”‚       kernel_heap.stats.total_frees++;
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Apply free poisoning
    â”‚       â”‚       â”‚       if (poisoning_enabled) {
    â”‚       â”‚       â”‚           memset(block->allocation_ptr, HEAP_FREE_POISON, block->size);
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Update checksum
    â”‚       â”‚       â”‚       block->checksum = 0;
    â”‚       â”‚       â”‚       block->checksum = calculate_checksum(block);
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Coalesce with adjacent free blocks
    â”‚       â”‚       â”‚       if (block->prev != NULL && !block->prev->used && heap_validate_block(block->prev)) {
    â”‚       â”‚       â”‚           block->prev->size += block->size + sizeof(struct heap_block);
    â”‚       â”‚       â”‚           block->prev->next = block->next;
    â”‚       â”‚       â”‚           
    â”‚       â”‚       â”‚           if (block->next != NULL) {
    â”‚       â”‚       â”‚               block->next->prev = block->prev;
    â”‚       â”‚       â”‚           }
    â”‚       â”‚       â”‚           
    â”‚       â”‚       â”‚           // Update checksum of merged block
    â”‚       â”‚       â”‚           block->prev->checksum = 0;
    â”‚       â”‚       â”‚           block->prev->checksum = calculate_checksum(block->prev);
    â”‚       â”‚       â”‚           
    â”‚       â”‚       â”‚           block = block->prev;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       if (block->next != NULL && !block->next->used && heap_validate_block(block->next)) {
    â”‚       â”‚       â”‚           block->size += block->next->size + sizeof(struct heap_block);
    â”‚       â”‚       â”‚           block->next = block->next->next;
    â”‚       â”‚       â”‚           
    â”‚       â”‚       â”‚           if (block->next != NULL) {
    â”‚       â”‚       â”‚               block->next->prev = block;
    â”‚       â”‚       â”‚           }
    â”‚       â”‚       â”‚           
    â”‚       â”‚       â”‚           // Update checksum
    â”‚       â”‚       â”‚           block->checksum = 0;
    â”‚       â”‚       â”‚           block->checksum = calculate_checksum(block);
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   // Validate all blocks in the heap
    â”‚       â”‚       â”‚   bool heap_validate_all_blocks(void) {
    â”‚       â”‚       â”‚       struct heap_block* current = kernel_heap.first_block;
    â”‚       â”‚       â”‚       bool all_valid = true;
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       while (current != NULL) {
    â”‚       â”‚       â”‚           if (!heap_validate_block(current)) {
    â”‚       â”‚       â”‚               all_valid = false;
    â”‚       â”‚       â”‚               kernel_heap.corruption_count++;
    â”‚       â”‚       â”‚           }
    â”‚       â”‚       â”‚           current = current->next;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       if (!all_valid) {
    â”‚       â”‚       â”‚           serial_puts("[HEAP SECURITY] Heap validation failed!\n");
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       return all_valid;
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   // Check if pointer is valid for this heap
    â”‚       â”‚       â”‚   bool heap_is_valid_pointer(void* ptr) {
    â”‚       â”‚       â”‚       if (ptr == NULL) return false;
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       uint64_t addr = (uint64_t)ptr;
    â”‚       â”‚       â”‚       if (addr < (uint64_t)kernel_heap.start || addr >= (uint64_t)kernel_heap.end) {
    â”‚       â”‚       â”‚           return false;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Check if pointer points to a valid allocation area
    â”‚       â”‚       â”‚       struct heap_block* block = (struct heap_block*)((uint8_t*)ptr - sizeof(struct heap_block));
    â”‚       â”‚       â”‚       if ((uint64_t)block < (uint64_t)kernel_heap.start || 
    â”‚       â”‚       â”‚           (uint64_t)block >= (uint64_t)kernel_heap.end) {
    â”‚       â”‚       â”‚           return false;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       return heap_validate_block(block);
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   // Additional security functions...
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   void* kcalloc(size_t num, size_t size) {
    â”‚       â”‚       â”‚       size_t total_size = num * size;
    â”‚       â”‚       â”‚       void* ptr = kmalloc(total_size);
    â”‚       â”‚       â”‚       if (ptr != NULL) {
    â”‚       â”‚       â”‚           memset(ptr, 0, total_size); // Always zero initialized
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       return ptr;
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   void* krealloc(void* ptr, size_t size) {
    â”‚       â”‚       â”‚       if (ptr == NULL) return kmalloc(size);
    â”‚       â”‚       â”‚       if (size == 0) {
    â”‚       â”‚       â”‚           kfree(ptr);
    â”‚       â”‚       â”‚           return NULL;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       if (!heap_is_valid_pointer(ptr)) {
    â”‚       â”‚       â”‚           serial_puts("[HEAP SECURITY] Invalid pointer in krealloc!\n");
    â”‚       â”‚       â”‚           return NULL;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       struct heap_block* block = (struct heap_block*)((uint8_t*)ptr - sizeof(struct heap_block));
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       if (size <= block->size) {
    â”‚       â”‚       â”‚           return ptr; // Existing block is large enough
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       void* new_ptr = kmalloc(size);
    â”‚       â”‚       â”‚       if (new_ptr != NULL) {
    â”‚       â”‚       â”‚           memcpy(new_ptr, ptr, block->requested_size);
    â”‚       â”‚       â”‚           kfree(ptr);
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       return new_ptr;
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   // Debug functions
    â”‚       â”‚       â”‚   void heap_dump_blocks(void) {
    â”‚       â”‚       â”‚       serial_puts("[HEAP] Heap block dump:\n");
    â”‚       â”‚       â”‚       struct heap_block* current = kernel_heap.first_block;
    â”‚       â”‚       â”‚       size_t block_num = 0;
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       while (current != NULL) {
    â”‚       â”‚       â”‚           printf("  Block %d: addr=0x%x, size=%d, used=%s, checksum=0x%x\n",
    â”‚       â”‚       â”‚                  block_num++, (uint64_t)current, current->size, 
    â”‚       â”‚       â”‚                  current->used ? "yes" : "no", current->checksum);
    â”‚       â”‚       â”‚           current = current->next;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   void heap_print_stats(void) {
    â”‚       â”‚       â”‚       serial_puts("[HEAP] Security Statistics:\n");
    â”‚       â”‚       â”‚       printf("  Total allocations: %d\n", kernel_heap.stats.total_allocations);
    â”‚       â”‚       â”‚       printf("  Total frees: %d\n", kernel_heap.stats.total_frees);
    â”‚       â”‚       â”‚       printf("  Failed allocations: %d\n", kernel_heap.stats.failed_allocations);
    â”‚       â”‚       â”‚       printf("  Double free attempts: %d\n", kernel_heap.stats.double_free_attempts);
    â”‚       â”‚       â”‚       printf("  Buffer overflows detected: %d\n", kernel_heap.stats.buffer_overflow_detected);
    â”‚       â”‚       â”‚       printf("  Use-after-free detected: %d\n", kernel_heap.stats.use_after_free_detected);
    â”‚       â”‚       â”‚       printf("  Total corruptions: %d\n", kernel_heap.corruption_count);
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   void heap_enable_poisoning(bool enable) {
    â”‚       â”‚       â”‚       poisoning_enabled = enable;
    â”‚       â”‚       â”‚       serial_puts(enable ? 
    â”‚       â”‚       â”‚           "[HEAP] Memory poisoning enabled\n" : 
    â”‚       â”‚       â”‚           "[HEAP] Memory poisoning disabled\n");
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   void heap_enable_guard_pages(bool enable) {
    â”‚       â”‚       â”‚       guard_pages_enabled = enable;
    â”‚       â”‚       â”‚       serial_puts(enable ?
    â”‚       â”‚       â”‚           "[HEAP] Guard pages enabled\n" :
    â”‚       â”‚       â”‚           "[HEAP] Guard pages disabled\n");
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   // Utility functions
    â”‚       â”‚       â”‚   size_t heap_get_total_size(void) { return kernel_heap.total_size; }
    â”‚       â”‚       â”‚   size_t heap_get_used_size(void) { return kernel_heap.used_size; }
    â”‚       â”‚       â”‚   size_t heap_get_free_size(void) { return kernel_heap.total_size - kernel_heap.used_size; }
    â”‚       â”‚       â”‚
    â”‚       â”‚   â”œâ”€â”€ paging.c
    â”‚       â”‚       â”‚
    â”‚       â”‚       â”œâ”€â”€ CONTENT:
    â”‚       â”‚       â”‚   #include "include/memory/paging.h"
    â”‚       â”‚       â”‚   #include "include/memory/pmm.h"
    â”‚       â”‚       â”‚   #include "include/drivers/serial.h"
    â”‚       â”‚       â”‚   #include "libc/string.h"
    â”‚       â”‚       â”‚   #include "libc/stdio.h"
    â”‚       â”‚       â”‚   #include "include/interrupts/isr.h"
    â”‚       â”‚       â”‚   #include "include/interrupts/idt.h"
    â”‚       â”‚       â”‚   #include <limine.h>
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   static volatile struct limine_hhdm_response *current_hhdm_response = NULL;
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   void paging_init(volatile struct limine_hhdm_response *hhdm_response) {
    â”‚       â”‚       â”‚       serial_puts("[PAGING] Initializing paging...\n");
    â”‚       â”‚       â”‚       current_hhdm_response = hhdm_response;
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // ĞŸÑ€Ğ¾Ğ²ĞµÑ€Ğ¸Ğ¼, Ğ²ĞºĞ»ÑÑ‡ĞµĞ½ Ğ»Ğ¸ ÑƒĞ¶Ğµ Ğ¿ĞµĞ¹Ğ´Ğ¶Ğ¸Ğ½Ğ³
    â”‚       â”‚       â”‚       uint64_t cr0;
    â”‚       â”‚       â”‚       asm volatile("mov %%cr0, %0" : "=r"(cr0));
    â”‚       â”‚       â”‚       uint64_t cr4;
    â”‚       â”‚       â”‚       asm volatile("mov %%cr4, %0" : "=r"(cr4));
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       serial_puts("[PAGING] CR0: 0x");
    â”‚       â”‚       â”‚       char buffer[32];
    â”‚       â”‚       â”‚       serial_puts(itoa(cr0, buffer, 16));
    â”‚       â”‚       â”‚       serial_puts("\n");
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       serial_puts("[PAGING] CR4: 0x");
    â”‚       â”‚       â”‚       serial_puts(itoa(cr4, buffer, 16));
    â”‚       â”‚       â”‚       serial_puts("\n");
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // ĞŸÑ€Ğ¾Ğ²ĞµÑ€Ğ¸Ğ¼ Ğ±Ğ¸Ñ‚ PG (Page Enable) Ğ² CR0
    â”‚       â”‚       â”‚       if (cr0 & (1UL << 31)) {
    â”‚       â”‚       â”‚           serial_puts("[PAGING] Paging is already enabled by bootloader\n");
    â”‚       â”‚       â”‚           
    â”‚       â”‚       â”‚           // ĞŸĞ¾Ğ»ÑƒÑ‡Ğ¸Ğ¼ Ñ‚ĞµĞºÑƒÑ‰Ğ¸Ğ¹ CR3
    â”‚       â”‚       â”‚           uint64_t current_cr3 = paging_get_cr3();
    â”‚       â”‚       â”‚           serial_puts("[PAGING] Current CR3: 0x");
    â”‚       â”‚       â”‚           serial_puts(itoa(current_cr3, buffer, 16));
    â”‚       â”‚       â”‚           serial_puts("\n");
    â”‚       â”‚       â”‚           
    â”‚       â”‚       â”‚           if (current_hhdm_response) {
    â”‚       â”‚       â”‚               serial_puts("[PAGING] HHDM offset: 0x");
    â”‚       â”‚       â”‚               serial_puts(itoa(current_hhdm_response->offset, buffer, 16));
    â”‚       â”‚       â”‚               serial_puts("\n");
    â”‚       â”‚       â”‚               
    â”‚       â”‚       â”‚               // ĞŸÑ€ĞµĞ¾Ğ±Ñ€Ğ°Ğ·ÑƒĞµĞ¼ CR3 Ğ² Ğ²Ğ¸Ñ€Ñ‚ÑƒĞ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ°Ğ´Ñ€ĞµÑ Ñ‡ĞµÑ€ĞµĞ· HHDM
    â”‚       â”‚       â”‚               uint64_t cr3_virtual = current_cr3 + current_hhdm_response->offset;
    â”‚       â”‚       â”‚               serial_puts("[PAGING] CR3 virtual address: 0x");
    â”‚       â”‚       â”‚               serial_puts(itoa(cr3_virtual, buffer, 16));
    â”‚       â”‚       â”‚               serial_puts("\n");
    â”‚       â”‚       â”‚           }
    â”‚       â”‚       â”‚           
    â”‚       â”‚       â”‚           serial_puts("[PAGING] Using existing page tables from bootloader\n");
    â”‚       â”‚       â”‚           return;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       if (!current_hhdm_response) {
    â”‚       â”‚       â”‚           serial_puts("[PAGING] ERROR: No HHDM response!\n");
    â”‚       â”‚       â”‚           return;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       serial_puts("[PAGING] HHDM offset: 0x");
    â”‚       â”‚       â”‚       serial_puts(itoa(current_hhdm_response->offset, buffer, 16));
    â”‚       â”‚       â”‚       serial_puts("\n");
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       serial_puts("[PAGING] Paging setup complete\n");
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   void paging_load_cr3(uint64_t cr3_value) {
    â”‚       â”‚       â”‚       asm volatile("mov %0, %%cr3" :: "r"(cr3_value));
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   uint64_t paging_get_cr3(void) {
    â”‚       â”‚       â”‚       uint64_t cr3;
    â”‚       â”‚       â”‚       asm volatile("mov %%cr3, %0" : "=r"(cr3));
    â”‚       â”‚       â”‚       return cr3;
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   void paging_invalidate_tlb(uint64_t virtual_addr) {
    â”‚       â”‚       â”‚       asm volatile("invlpg (%0)" :: "r"(virtual_addr) : "memory");
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   bool paging_map_page(uint64_t virtual_addr, uint64_t physical_addr, uint64_t flags) {
    â”‚       â”‚       â”‚       if (!current_hhdm_response) {
    â”‚       â”‚       â”‚           serial_puts("[PAGING] ERROR: No HHDM response for mapping!\n");
    â”‚       â”‚       â”‚           return false;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ñ‚ĞµĞºÑƒÑ‰ÑƒÑ Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñƒ ÑÑ‚Ñ€Ğ°Ğ½Ğ¸Ñ†
    â”‚       â”‚       â”‚       uint64_t cr3 = paging_get_cr3();
    â”‚       â”‚       â”‚       uint64_t* pml4 = (uint64_t*)(cr3 + current_hhdm_response->offset);
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Ğ’Ñ‹Ñ‡Ğ¸ÑĞ»ÑĞµĞ¼ Ğ¸Ğ½Ğ´ĞµĞºÑÑ‹ Ğ² Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ğ°Ñ… ÑÑ‚Ñ€Ğ°Ğ½Ğ¸Ñ†
    â”‚       â”‚       â”‚       uint64_t pml4_index = (virtual_addr >> 39) & 0x1FF;
    â”‚       â”‚       â”‚       uint64_t pdp_index = (virtual_addr >> 30) & 0x1FF;
    â”‚       â”‚       â”‚       uint64_t pd_index = (virtual_addr >> 21) & 0x1FF;
    â”‚       â”‚       â”‚       uint64_t pt_index = (virtual_addr >> 12) & 0x1FF;
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ PML4 entry
    â”‚       â”‚       â”‚       if (!(pml4[pml4_index] & PAGING_PRESENT)) {
    â”‚       â”‚       â”‚           // Ğ’Ñ‹Ğ´ĞµĞ»ÑĞµĞ¼ Ğ½Ğ¾Ğ²ÑƒÑ PDP Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñƒ
    â”‚       â”‚       â”‚           uint64_t pdp_physical = pmm_alloc_page();
    â”‚       â”‚       â”‚           if (!pdp_physical) {
    â”‚       â”‚       â”‚               serial_puts("[PAGING] ERROR: Failed to allocate PDP table!\n");
    â”‚       â”‚       â”‚               return false;
    â”‚       â”‚       â”‚           }
    â”‚       â”‚       â”‚           
    â”‚       â”‚       â”‚           uint64_t* pdp = (uint64_t*)(pdp_physical + current_hhdm_response->offset);
    â”‚       â”‚       â”‚           memset(pdp, 0, PAGE_SIZE_4K);
    â”‚       â”‚       â”‚           
    â”‚       â”‚       â”‚           // Ğ£ÑÑ‚Ğ°Ğ½Ğ°Ğ²Ğ»Ğ¸Ğ²Ğ°ĞµĞ¼ Ğ·Ğ°Ğ¿Ğ¸ÑÑŒ Ğ² PML4
    â”‚       â”‚       â”‚           pml4[pml4_index] = pdp_physical | PAGING_PRESENT | PAGING_WRITABLE | PAGING_USER;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       uint64_t* pdp = (uint64_t*)((pml4[pml4_index] & ~0xFFF) + current_hhdm_response->offset);
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ PDP entry
    â”‚       â”‚       â”‚       if (!(pdp[pdp_index] & PAGING_PRESENT)) {
    â”‚       â”‚       â”‚           // Ğ’Ñ‹Ğ´ĞµĞ»ÑĞµĞ¼ Ğ½Ğ¾Ğ²ÑƒÑ PD Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñƒ
    â”‚       â”‚       â”‚           uint64_t pd_physical = pmm_alloc_page();
    â”‚       â”‚       â”‚           if (!pd_physical) {
    â”‚       â”‚       â”‚               serial_puts("[PAGING] ERROR: Failed to allocate PD table!\n");
    â”‚       â”‚       â”‚               return false;
    â”‚       â”‚       â”‚           }
    â”‚       â”‚       â”‚           
    â”‚       â”‚       â”‚           uint64_t* pd = (uint64_t*)(pd_physical + current_hhdm_response->offset);
    â”‚       â”‚       â”‚           memset(pd, 0, PAGE_SIZE_4K);
    â”‚       â”‚       â”‚           
    â”‚       â”‚       â”‚           // Ğ£ÑÑ‚Ğ°Ğ½Ğ°Ğ²Ğ»Ğ¸Ğ²Ğ°ĞµĞ¼ Ğ·Ğ°Ğ¿Ğ¸ÑÑŒ Ğ² PDP
    â”‚       â”‚       â”‚           pdp[pdp_index] = pd_physical | PAGING_PRESENT | PAGING_WRITABLE | PAGING_USER;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       uint64_t* pd = (uint64_t*)((pdp[pdp_index] & ~0xFFF) + current_hhdm_response->offset);
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ PD entry
    â”‚       â”‚       â”‚       if (!(pd[pd_index] & PAGING_PRESENT)) {
    â”‚       â”‚       â”‚           // Ğ’Ñ‹Ğ´ĞµĞ»ÑĞµĞ¼ Ğ½Ğ¾Ğ²ÑƒÑ PT Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñƒ
    â”‚       â”‚       â”‚           uint64_t pt_physical = pmm_alloc_page();
    â”‚       â”‚       â”‚           if (!pt_physical) {
    â”‚       â”‚       â”‚               serial_puts("[PAGING] ERROR: Failed to allocate PT table!\n");
    â”‚       â”‚       â”‚               return false;
    â”‚       â”‚       â”‚           }
    â”‚       â”‚       â”‚           
    â”‚       â”‚       â”‚           uint64_t* pt = (uint64_t*)(pt_physical + current_hhdm_response->offset);
    â”‚       â”‚       â”‚           memset(pt, 0, PAGE_SIZE_4K);
    â”‚       â”‚       â”‚           
    â”‚       â”‚       â”‚           // Ğ£ÑÑ‚Ğ°Ğ½Ğ°Ğ²Ğ»Ğ¸Ğ²Ğ°ĞµĞ¼ Ğ·Ğ°Ğ¿Ğ¸ÑÑŒ Ğ² PD
    â”‚       â”‚       â”‚           pd[pd_index] = pt_physical | PAGING_PRESENT | PAGING_WRITABLE | PAGING_USER;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       uint64_t* pt = (uint64_t*)((pd[pd_index] & ~0xFFF) + current_hhdm_response->offset);
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Ğ£ÑÑ‚Ğ°Ğ½Ğ°Ğ²Ğ»Ğ¸Ğ²Ğ°ĞµĞ¼ Ğ·Ğ°Ğ¿Ğ¸ÑÑŒ Ğ² Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ğµ ÑÑ‚Ñ€Ğ°Ğ½Ğ¸Ñ†
    â”‚       â”‚       â”‚       pt[pt_index] = physical_addr | flags | PAGING_PRESENT;
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Ğ˜Ğ½Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ¸Ñ€ÑƒĞµĞ¼ TLB
    â”‚       â”‚       â”‚       paging_invalidate_tlb(virtual_addr);
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       char buffer[64];
    â”‚       â”‚       â”‚       serial_puts("[PAGING] Mapped virtual 0x");
    â”‚       â”‚       â”‚       serial_puts(itoa(virtual_addr, buffer, 16));
    â”‚       â”‚       â”‚       serial_puts(" to physical 0x");
    â”‚       â”‚       â”‚       serial_puts(itoa(physical_addr, buffer, 16));
    â”‚       â”‚       â”‚       serial_puts("\n");
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       return true;
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   bool paging_unmap_page(uint64_t virtual_addr) {
    â”‚       â”‚       â”‚       if (!current_hhdm_response) {
    â”‚       â”‚       â”‚           serial_puts("[PAGING] ERROR: No HHDM response for unmapping!\n");
    â”‚       â”‚       â”‚           return false;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ñ‚ĞµĞºÑƒÑ‰ÑƒÑ Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñƒ ÑÑ‚Ñ€Ğ°Ğ½Ğ¸Ñ†
    â”‚       â”‚       â”‚       uint64_t cr3 = paging_get_cr3();
    â”‚       â”‚       â”‚       uint64_t* pml4 = (uint64_t*)(cr3 + current_hhdm_response->offset);
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Ğ’Ñ‹Ñ‡Ğ¸ÑĞ»ÑĞµĞ¼ Ğ¸Ğ½Ğ´ĞµĞºÑÑ‹ Ğ² Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ğ°Ñ… ÑÑ‚Ñ€Ğ°Ğ½Ğ¸Ñ†
    â”‚       â”‚       â”‚       uint64_t pml4_index = (virtual_addr >> 39) & 0x1FF;
    â”‚       â”‚       â”‚       uint64_t pdp_index = (virtual_addr >> 30) & 0x1FF;
    â”‚       â”‚       â”‚       uint64_t pd_index = (virtual_addr >> 21) & 0x1FF;
    â”‚       â”‚       â”‚       uint64_t pt_index = (virtual_addr >> 12) & 0x1FF;
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ ÑÑƒÑ‰ĞµÑÑ‚Ğ²Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ²ÑĞµÑ… ÑƒÑ€Ğ¾Ğ²Ğ½ĞµĞ¹ Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†
    â”‚       â”‚       â”‚       if (!(pml4[pml4_index] & PAGING_PRESENT)) {
    â”‚       â”‚       â”‚           serial_puts("[PAGING] ERROR: PML4 entry not present!\n");
    â”‚       â”‚       â”‚           return false;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       uint64_t* pdp = (uint64_t*)((pml4[pml4_index] & ~0xFFF) + current_hhdm_response->offset);
    â”‚       â”‚       â”‚       if (!(pdp[pdp_index] & PAGING_PRESENT)) {
    â”‚       â”‚       â”‚           serial_puts("[PAGING] ERROR: PDP entry not present!\n");
    â”‚       â”‚       â”‚           return false;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       uint64_t* pd = (uint64_t*)((pdp[pdp_index] & ~0xFFF) + current_hhdm_response->offset);
    â”‚       â”‚       â”‚       if (!(pd[pd_index] & PAGING_PRESENT)) {
    â”‚       â”‚       â”‚           serial_puts("[PAGING] ERROR: PD entry not present!\n");
    â”‚       â”‚       â”‚           return false;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       uint64_t* pt = (uint64_t*)((pd[pd_index] & ~0xFFF) + current_hhdm_response->offset);
    â”‚       â”‚       â”‚       if (!(pt[pt_index] & PAGING_PRESENT)) {
    â”‚       â”‚       â”‚           serial_puts("[PAGING] ERROR: Page table entry not present!\n");
    â”‚       â”‚       â”‚           return false;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // ĞÑĞ²Ğ¾Ğ±Ğ¾Ğ¶Ğ´Ğ°ĞµĞ¼ Ñ„Ğ¸Ğ·Ğ¸Ñ‡ĞµÑĞºÑƒÑ ÑÑ‚Ñ€Ğ°Ğ½Ğ¸Ñ†Ñƒ
    â”‚       â”‚       â”‚       uint64_t physical_addr = pt[pt_index] & ~0xFFF;
    â”‚       â”‚       â”‚       pmm_free_page(physical_addr);
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // ĞÑ‡Ğ¸Ñ‰Ğ°ĞµĞ¼ Ğ·Ğ°Ğ¿Ğ¸ÑÑŒ Ğ² Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ğµ ÑÑ‚Ñ€Ğ°Ğ½Ğ¸Ñ†
    â”‚       â”‚       â”‚       pt[pt_index] = 0;
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Ğ˜Ğ½Ğ²Ğ°Ğ»Ğ¸Ğ´Ğ¸Ñ€ÑƒĞµĞ¼ TLB
    â”‚       â”‚       â”‚       paging_invalidate_tlb(virtual_addr);
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       char buffer[64];
    â”‚       â”‚       â”‚       serial_puts("[PAGING] Unmapped virtual 0x");
    â”‚       â”‚       â”‚       serial_puts(itoa(virtual_addr, buffer, 16));
    â”‚       â”‚       â”‚       serial_puts("\n");
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       return true;
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   // Ğ¤ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸ Ğ¾Ñ‚Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ñ Ğ²Ğ¸Ñ€Ñ‚ÑƒĞ°Ğ»ÑŒĞ½Ğ¾Ğ³Ğ¾ Ğ°Ğ´Ñ€ĞµÑĞ°
    â”‚       â”‚       â”‚   bool paging_is_mapped(uint64_t virtual_addr) {
    â”‚       â”‚       â”‚       if (!current_hhdm_response) return false;
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       uint64_t cr3 = paging_get_cr3();
    â”‚       â”‚       â”‚       uint64_t* pml4 = (uint64_t*)(cr3 + current_hhdm_response->offset);
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       uint64_t pml4_index = (virtual_addr >> 39) & 0x1FF;
    â”‚       â”‚       â”‚       if (!(pml4[pml4_index] & PAGING_PRESENT)) return false;
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       uint64_t* pdp = (uint64_t*)((pml4[pml4_index] & ~0xFFF) + current_hhdm_response->offset);
    â”‚       â”‚       â”‚       uint64_t pdp_index = (virtual_addr >> 30) & 0x1FF;
    â”‚       â”‚       â”‚       if (!(pdp[pdp_index] & PAGING_PRESENT)) return false;
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       uint64_t* pd = (uint64_t*)((pdp[pdp_index] & ~0xFFF) + current_hhdm_response->offset);
    â”‚       â”‚       â”‚       uint64_t pd_index = (virtual_addr >> 21) & 0x1FF;
    â”‚       â”‚       â”‚       if (!(pd[pd_index] & PAGING_PRESENT)) return false;
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       uint64_t* pt = (uint64_t*)((pd[pd_index] & ~0xFFF) + current_hhdm_response->offset);
    â”‚       â”‚       â”‚       uint64_t pt_index = (virtual_addr >> 12) & 0x1FF;
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       return (pt[pt_index] & PAGING_PRESENT) != 0;
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   uint64_t paging_get_physical_address(uint64_t virtual_addr) {
    â”‚       â”‚       â”‚       if (!current_hhdm_response) {
    â”‚       â”‚       â”‚           serial_puts("[PAGING_DEBUG] ERROR: No HHDM response!\n");
    â”‚       â”‚       â”‚           return 0;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       char buffer[64];
    â”‚       â”‚       â”‚       serial_puts("[PAGING_DEBUG] Looking up virtual: 0x");
    â”‚       â”‚       â”‚       serial_puts(itoa(virtual_addr, buffer, 16));
    â”‚       â”‚       â”‚       serial_puts("\n");
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Ğ¢ĞĞ›Ğ¬ĞšĞ Ğ´Ğ»Ñ Ğ½Ğ°ÑÑ‚Ğ¾ÑÑ‰Ğ¸Ñ… HHDM Ğ°Ğ´Ñ€ĞµÑĞ¾Ğ² (Ğ¿Ñ€ÑĞ¼Ğ¾Ğµ Ğ¾Ñ‚Ğ¾Ğ±Ñ€Ğ°Ğ¶ĞµĞ½Ğ¸Ğµ)
    â”‚       â”‚       â”‚       // HHDM Ğ´Ğ¸Ğ°Ğ¿Ğ°Ğ·Ğ¾Ğ½: 0xffff800000000000 - 0xffff87ffffffffff
    â”‚       â”‚       â”‚       if (virtual_addr >= current_hhdm_response->offset && 
    â”‚       â”‚       â”‚           virtual_addr < (current_hhdm_response->offset + 0x8000000000)) {
    â”‚       â”‚       â”‚           uint64_t physical = virtual_addr - current_hhdm_response->offset;
    â”‚       â”‚       â”‚           
    â”‚       â”‚       â”‚           serial_puts("[PAGING_DEBUG] HHDM conversion: Virtual 0x");
    â”‚       â”‚       â”‚           serial_puts(itoa(virtual_addr, buffer, 16));
    â”‚       â”‚       â”‚           serial_puts(" -> Physical 0x");
    â”‚       â”‚       â”‚           serial_puts(itoa(physical, buffer, 16));
    â”‚       â”‚       â”‚           serial_puts("\n");
    â”‚       â”‚       â”‚           
    â”‚       â”‚       â”‚           return physical;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Ğ”Ğ»Ñ Ğ²ÑĞµÑ… Ğ¾ÑÑ‚Ğ°Ğ»ÑŒĞ½Ñ‹Ñ… Ğ°Ğ´Ñ€ĞµÑĞ¾Ğ² (Ğ²ĞºĞ»ÑÑ‡Ğ°Ñ Ğ°Ğ´Ñ€ĞµÑĞ° ÑĞ´Ñ€Ğ°) Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñ‹ ÑÑ‚Ñ€Ğ°Ğ½Ğ¸Ñ†
    â”‚       â”‚       â”‚       serial_puts("[PAGING_DEBUG] Using page table lookup for: 0x");
    â”‚       â”‚       â”‚       serial_puts(itoa(virtual_addr, buffer, 16));
    â”‚       â”‚       â”‚       serial_puts("\n");
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       uint64_t cr3 = paging_get_cr3();
    â”‚       â”‚       â”‚       uint64_t* pml4 = (uint64_t*)(cr3 + current_hhdm_response->offset);
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       uint64_t pml4_index = (virtual_addr >> 39) & 0x1FF;
    â”‚       â”‚       â”‚       if (!(pml4[pml4_index] & PAGING_PRESENT)) {
    â”‚       â”‚       â”‚           serial_puts("[PAGING_DEBUG] PML4 entry not present\n");
    â”‚       â”‚       â”‚           return 0;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       uint64_t* pdp = (uint64_t*)((pml4[pml4_index] & ~0xFFF) + current_hhdm_response->offset);
    â”‚       â”‚       â”‚       uint64_t pdp_index = (virtual_addr >> 30) & 0x1FF;
    â”‚       â”‚       â”‚       if (!(pdp[pdp_index] & PAGING_PRESENT)) {
    â”‚       â”‚       â”‚           serial_puts("[PAGING_DEBUG] PDP entry not present\n");
    â”‚       â”‚       â”‚           return 0;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       uint64_t* pd = (uint64_t*)((pdp[pdp_index] & ~0xFFF) + current_hhdm_response->offset);
    â”‚       â”‚       â”‚       uint64_t pd_index = (virtual_addr >> 21) & 0x1FF;
    â”‚       â”‚       â”‚       if (!(pd[pd_index] & PAGING_PRESENT)) {
    â”‚       â”‚       â”‚           serial_puts("[PAGING_DEBUG] PD entry not present\n");
    â”‚       â”‚       â”‚           return 0;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       uint64_t* pt = (uint64_t*)((pd[pd_index] & ~0xFFF) + current_hhdm_response->offset);
    â”‚       â”‚       â”‚       uint64_t pt_index = (virtual_addr >> 12) & 0x1FF;
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       if (!(pt[pt_index] & PAGING_PRESENT)) {
    â”‚       â”‚       â”‚           serial_puts("[PAGING_DEBUG] Page table entry not present\n");
    â”‚       â”‚       â”‚           return 0;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ñ„Ğ¸Ğ·Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¹ Ğ°Ğ´Ñ€ĞµÑ Ğ¸Ğ· PTE
    â”‚       â”‚       â”‚       uint64_t physical = pt[pt_index] & ~0xFFF;
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       serial_puts("[PAGING_DEBUG] Page table lookup: Virtual 0x");
    â”‚       â”‚       â”‚       serial_puts(itoa(virtual_addr, buffer, 16));
    â”‚       â”‚       â”‚       serial_puts(" -> PTE: 0x");
    â”‚       â”‚       â”‚       serial_puts(itoa(pt[pt_index], buffer, 16));
    â”‚       â”‚       â”‚       serial_puts(" -> Physical: 0x");
    â”‚       â”‚       â”‚       serial_puts(itoa(physical, buffer, 16));
    â”‚       â”‚       â”‚       serial_puts("\n");
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       return physical;
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   void* paging_physical_to_virtual(uint64_t physical_addr) {
    â”‚       â”‚       â”‚       if (!current_hhdm_response) {
    â”‚       â”‚       â”‚           return (void*)physical_addr;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       void* virtual_addr = (void*)(physical_addr + current_hhdm_response->offset);
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // ĞÑ‚Ğ»Ğ°Ğ´Ğ¾Ñ‡Ğ½Ñ‹Ğ¹ Ğ²Ñ‹Ğ²Ğ¾Ğ´
    â”‚       â”‚       â”‚       char buffer[64];
    â”‚       â”‚       â”‚       serial_puts("[PAGING_DEBUG] Physical to virtual: Physical 0x");
    â”‚       â”‚       â”‚       serial_puts(itoa(physical_addr, buffer, 16));
    â”‚       â”‚       â”‚       serial_puts(" -> Virtual 0x");
    â”‚       â”‚       â”‚       serial_puts(itoa((uint64_t)virtual_addr, buffer, 16));
    â”‚       â”‚       â”‚       serial_puts("\n");
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       return virtual_addr;
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   uint64_t paging_virtual_to_physical(void* virtual_addr) {
    â”‚       â”‚       â”‚       uint64_t vaddr = (uint64_t)virtual_addr;
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // ĞÑ‚Ğ»Ğ°Ğ´Ğ¾Ñ‡Ğ½Ñ‹Ğ¹ Ğ²Ñ‹Ğ²Ğ¾Ğ´
    â”‚       â”‚       â”‚       char buffer[64];
    â”‚       â”‚       â”‚       serial_puts("[PAGING_DEBUG] Virtual to physical: Virtual 0x");
    â”‚       â”‚       â”‚       serial_puts(itoa(vaddr, buffer, 16));
    â”‚       â”‚       â”‚       serial_puts("\n");
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Ğ•ÑĞ»Ğ¸ Ğ°Ğ´Ñ€ĞµÑ ÑƒĞ¶Ğµ Ğ² HHDM Ñ€ĞµĞ³Ğ¸Ğ¾Ğ½Ğµ, Ğ¿Ñ€Ğ¾ÑÑ‚Ğ¾ Ğ²Ñ‹Ñ‡Ğ¸Ñ‚Ğ°ĞµĞ¼ offset
    â”‚       â”‚       â”‚       if (current_hhdm_response && vaddr >= current_hhdm_response->offset) {
    â”‚       â”‚       â”‚           uint64_t physical = vaddr - current_hhdm_response->offset;
    â”‚       â”‚       â”‚           serial_puts("[PAGING_DEBUG] Using HHDM conversion -> Physical 0x");
    â”‚       â”‚       â”‚           serial_puts(itoa(physical, buffer, 16));
    â”‚       â”‚       â”‚           serial_puts("\n");
    â”‚       â”‚       â”‚           return physical;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Ğ”Ğ»Ñ Ğ¾Ğ±Ñ‹Ñ‡Ğ½Ñ‹Ñ… Ğ²Ğ¸Ñ€Ñ‚ÑƒĞ°Ğ»ÑŒĞ½Ñ‹Ñ… Ğ°Ğ´Ñ€ĞµÑĞ¾Ğ² Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ñ‹ ÑÑ‚Ñ€Ğ°Ğ½Ğ¸Ñ†
    â”‚       â”‚       â”‚       uint64_t physical = paging_get_physical_address(vaddr);
    â”‚       â”‚       â”‚       serial_puts("[PAGING_DEBUG] Using page table conversion -> Physical 0x");
    â”‚       â”‚       â”‚       serial_puts(itoa(physical, buffer, 16));
    â”‚       â”‚       â”‚       serial_puts("\n");
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       return physical;
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   void* paging_hhdm_to_virtual(uint64_t physical_addr) {
    â”‚       â”‚       â”‚       return paging_physical_to_virtual(physical_addr);
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   void handle_page_fault(struct registers *regs) {
    â”‚       â”‚       â”‚       uint64_t fault_address;
    â”‚       â”‚       â”‚       uint64_t error_code = regs->err_code;
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // ĞŸĞ¾Ğ»ÑƒÑ‡Ğ°ĞµĞ¼ Ğ°Ğ´Ñ€ĞµÑ ÑĞ±Ğ¾Ñ Ğ¸Ğ· CR2
    â”‚       â”‚       â”‚       asm volatile("mov %%cr2, %0" : "=r"(fault_address));
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Ğ’Ñ‹Ğ²Ğ¾Ğ´Ğ¸Ğ¼ ĞºÑ€Ğ°ÑĞ¸Ğ²ÑƒÑ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ Ğ½Ğ° ÑĞºÑ€Ğ°Ğ½
    â”‚       â”‚       â”‚       printf("\n=== PAGE FAULT DETECTED ===\n");
    â”‚       â”‚       â”‚       printf("Fault Address: 0x%x\n", fault_address);
    â”‚       â”‚       â”‚       printf("Error Code: 0x%x\n", error_code);
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Ğ”ĞµÑ‚Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ Ğ°Ğ½Ğ°Ğ»Ğ¸Ğ· ĞºĞ¾Ğ´Ğ° Ğ¾ÑˆĞ¸Ğ±ĞºĞ¸
    â”‚       â”‚       â”‚       if (error_code & PF_PRESENT) {
    â”‚       â”‚       â”‚           printf("Type: Protection Violation\n");
    â”‚       â”‚       â”‚           if (error_code & PF_WRITE) {
    â”‚       â”‚       â”‚               printf("Operation: Write to read-only page\n");
    â”‚       â”‚       â”‚           } else {
    â”‚       â”‚       â”‚               printf("Operation: Read from protected page\n");
    â”‚       â”‚       â”‚           }
    â”‚       â”‚       â”‚       } else {
    â”‚       â”‚       â”‚           printf("Type: Page Not Present\n");
    â”‚       â”‚       â”‚           printf("Operation: %s\n", (error_code & PF_WRITE) ? "Write" : "Read");
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       printf("Access Mode: %s\n", (error_code & PF_USER) ? "User" : "Kernel");
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // ĞŸÑ‹Ñ‚Ğ°ĞµĞ¼ÑÑ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°Ñ‚ÑŒ ÑĞ±Ğ¾Ğ¹
    â”‚       â”‚       â”‚       if (!(error_code & PF_PRESENT)) {
    â”‚       â”‚       â”‚           // Ğ¡Ñ‚Ñ€Ğ°Ğ½Ğ¸Ñ†Ğ° Ğ¾Ñ‚ÑÑƒÑ‚ÑÑ‚Ğ²ÑƒĞµÑ‚ - Ğ¿Ñ€Ğ¾Ğ±ÑƒĞµĞ¼ Ğ²Ñ‹Ğ´ĞµĞ»Ğ¸Ñ‚ÑŒ
    â”‚       â”‚       â”‚           uint64_t page_base = fault_address & ~0xFFF;
    â”‚       â”‚       â”‚           
    â”‚       â”‚       â”‚           // ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼, Ğ½Ğ°Ñ…Ğ¾Ğ´Ğ¸Ñ‚ÑÑ Ğ»Ğ¸ Ğ°Ğ´Ñ€ĞµÑ Ğ² Ğ´Ğ¾Ğ¿ÑƒÑÑ‚Ğ¸Ğ¼Ğ¾Ğ¼ Ğ´Ğ¸Ğ°Ğ¿Ğ°Ğ·Ğ¾Ğ½Ğµ ÑĞ´Ñ€Ğ°
    â”‚       â”‚       â”‚           if (fault_address >= KERNEL_VIRTUAL_BASE && fault_address < KERNEL_VIRTUAL_BASE + 0x10000000) {
    â”‚       â”‚       â”‚               printf("Attempting to map kernel page at 0x%x...\n", page_base);
    â”‚       â”‚       â”‚               
    â”‚       â”‚       â”‚               uint64_t physical_page = pmm_alloc_page();
    â”‚       â”‚       â”‚               if (physical_page) {
    â”‚       â”‚       â”‚                   if (paging_map_page(page_base, physical_page, PAGING_PRESENT | PAGING_WRITABLE)) {
    â”‚       â”‚       â”‚                       printf("Successfully mapped page\n");
    â”‚       â”‚       â”‚                       memset((void*)page_base, 0, PAGE_SIZE_4K); // ĞÑ‡Ğ¸Ñ‰Ğ°ĞµĞ¼ ÑÑ‚Ñ€Ğ°Ğ½Ğ¸Ñ†Ñƒ
    â”‚       â”‚       â”‚                       printf("Page zero-initialized\n");
    â”‚       â”‚       â”‚                       printf("=== PAGE FAULT RESOLVED ===\n\n");
    â”‚       â”‚       â”‚                       return; // Ğ£ÑĞ¿ĞµÑˆĞ½Ğ¾ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°Ğ½Ğ¾!
    â”‚       â”‚       â”‚                   }
    â”‚       â”‚       â”‚                   pmm_free_page(physical_page);
    â”‚       â”‚       â”‚               }
    â”‚       â”‚       â”‚               printf("Failed to map page\n");
    â”‚       â”‚       â”‚           } else {
    â”‚       â”‚       â”‚               printf("Address outside kernel range\n");
    â”‚       â”‚       â”‚           }
    â”‚       â”‚       â”‚       } else {
    â”‚       â”‚       â”‚           printf("Protection violation - cannot handle automatically\n");
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Ğ•ÑĞ»Ğ¸ Ğ½Ğµ ÑĞ¼Ğ¾Ğ³Ğ»Ğ¸ Ğ¾Ğ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ğ°Ñ‚ÑŒ - ĞºÑ€Ğ¸Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ°Ñ Ğ¾ÑˆĞ¸Ğ±ĞºĞ°
    â”‚       â”‚       â”‚       printf("\n!!! UNRECOVERABLE PAGE FAULT !!!\n");
    â”‚       â”‚       â”‚       printf("System Halted.\n");
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Ğ‘ĞµÑĞºĞ¾Ğ½ĞµÑ‡Ğ½Ñ‹Ğ¹ Ñ†Ğ¸ĞºĞ»
    â”‚       â”‚       â”‚       for(;;) {
    â”‚       â”‚       â”‚           asm volatile("hlt");
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   void handle_double_fault(struct registers *regs) {
    â”‚       â”‚       â”‚       printf("\n!!! DOUBLE FAULT DETECTED !!!\n");
    â”‚       â”‚       â”‚       printf("Error Code: 0x%x\n", regs->err_code);
    â”‚       â”‚       â”‚       printf("This is a critical system error.\n");
    â”‚       â”‚       â”‚       printf("Possible causes:\n");
    â”‚       â”‚       â”‚       printf(" - Stack overflow/corruption\n");
    â”‚       â”‚       â”‚       printf(" - Interrupt handler failure\n"); 
    â”‚       â”‚       â”‚       printf(" - Kernel memory corruption\n");
    â”‚       â”‚       â”‚       printf("System Halted.\n");
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       for(;;) {
    â”‚       â”‚       â”‚           asm volatile("hlt");
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   void handle_general_protection_fault(struct registers *regs) {
    â”‚       â”‚       â”‚       printf("\n!!! GENERAL PROTECTION FAULT !!!\n");
    â”‚       â”‚       â”‚       printf("Error Code: 0x%x\n", regs->err_code);
    â”‚       â”‚       â”‚       printf("Instruction Pointer: 0x%x\n", regs->rip);
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // ĞĞ½Ğ°Ğ»Ğ¸Ğ·Ğ¸Ñ€ÑƒĞµĞ¼ ĞºĞ¾Ğ´ Ğ¾ÑˆĞ¸Ğ±ĞºĞ¸
    â”‚       â”‚       â”‚       if (regs->err_code == 0) {
    â”‚       â”‚       â”‚           printf("Type: Null selector reference\n");
    â”‚       â”‚       â”‚       } else {
    â”‚       â”‚       â”‚           printf("Type: Privilege violation or invalid segment access\n");
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼, Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ»Ğ¸ Ğ¿Ñ€Ğ¾Ğ´Ğ¾Ğ»Ğ¶Ğ¸Ñ‚ÑŒ (Ğ´Ğ»Ñ Ğ½ĞµĞºÑ€Ğ¸Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ñ… GPF)
    â”‚       â”‚       â”‚       if (regs->err_code == 0) {
    â”‚       â”‚       â”‚           printf("Non-critical GPF, attempting to continue...\n");
    â”‚       â”‚       â”‚           return;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       printf("Critical GPF - System Halted.\n");
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       for(;;) {
    â”‚       â”‚       â”‚           asm volatile("hlt");
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   // Secure page mapping with additional checks
    â”‚       â”‚       â”‚   bool paging_map_page_secure(uint64_t virtual_addr, uint64_t physical_addr, 
    â”‚       â”‚       â”‚                              uint64_t flags, bool require_guard_pages) {
    â”‚       â”‚       â”‚       // Validate addresses
    â”‚       â”‚       â”‚       if (virtual_addr == 0 || physical_addr == 0) {
    â”‚       â”‚       â”‚           serial_puts("[PAGING SECURITY] Attempt to map NULL address!\n");
    â”‚       â”‚       â”‚           return false;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Check for kernel space violations
    â”‚       â”‚       â”‚       if ((virtual_addr >= 0xFFFF800000000000 && virtual_addr < 0xFFFF800000000000 + 0x80000000) &&
    â”‚       â”‚       â”‚           !(flags & PAGING_USER)) {
    â”‚       â”‚       â”‚           serial_puts("[PAGING SECURITY] User mapping in kernel space!\n");
    â”‚       â”‚       â”‚           return false;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Add guard pages if requested
    â”‚       â”‚       â”‚       if (require_guard_pages) {
    â”‚       â”‚       â”‚           // Map previous page as guard
    â”‚       â”‚       â”‚           uint64_t guard_addr = virtual_addr - PAGE_SIZE_4K;
    â”‚       â”‚       â”‚           if (!paging_map_page(guard_addr, pmm_alloc_page(), PAGING_NO_EXECUTE)) {
    â”‚       â”‚       â”‚               serial_puts("[PAGING SECURITY] Failed to create guard page!\n");
    â”‚       â”‚       â”‚               return false;
    â”‚       â”‚       â”‚           }
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       return paging_map_page(virtual_addr, physical_addr, flags);
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   // Validate page table integrity
    â”‚       â”‚       â”‚   bool paging_validate_integrity(void) {
    â”‚       â”‚       â”‚       if (!current_hhdm_response) return false;
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       uint64_t cr3 = paging_get_cr3();
    â”‚       â”‚       â”‚       uint64_t* pml4 = (uint64_t*)(cr3 + current_hhdm_response->offset);
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Check PML4 self-reference
    â”‚       â”‚       â”‚       if ((pml4[511] & PAGING_PRESENT) == 0) {
    â”‚       â”‚       â”‚           serial_puts("[PAGING SECURITY] PML4 self-reference missing!\n");
    â”‚       â”‚       â”‚           return false;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Basic sanity checks on kernel mappings
    â”‚       â”‚       â”‚       uint64_t kernel_base = 0xFFFFFFFF80000000;
    â”‚       â”‚       â”‚       uint64_t pml4_index = (kernel_base >> 39) & 0x1FF;
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       if ((pml4[pml4_index] & PAGING_PRESENT) == 0) {
    â”‚       â”‚       â”‚           serial_puts("[PAGING SECURITY] Kernel space not mapped!\n");
    â”‚       â”‚       â”‚           return false;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       return true;
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚
    â”‚       â”‚   â”œâ”€â”€ pmm.c
    â”‚       â”‚       â”‚
    â”‚       â”‚       â”œâ”€â”€ CONTENT:
    â”‚       â”‚       â”‚   #include "include/memory/pmm.h"
    â”‚       â”‚       â”‚   #include "include/memory/paging.h"
    â”‚       â”‚       â”‚   #include "include/drivers/serial.h"
    â”‚       â”‚       â”‚   #include "libc/string.h"
    â”‚       â”‚       â”‚   #include "libc/stdio.h"
    â”‚       â”‚       â”‚   #include <limine.h>
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   // Ğ¡Ğ¾Ğ²Ğ¼ĞµÑÑ‚Ğ¸Ğ¼Ğ¾ÑÑ‚ÑŒ Ñ Ñ€Ğ°Ğ·Ğ½Ñ‹Ğ¼Ğ¸ Ğ²ĞµÑ€ÑĞ¸ÑĞ¼Ğ¸ Limine
    â”‚       â”‚       â”‚   #ifndef LIMINE_MEMMAP_EXECUTABLE_AND_MODULES
    â”‚       â”‚       â”‚       #ifdef LIMINE_MEMMAP_KERNEL_AND_MODULES
    â”‚       â”‚       â”‚           #define LIMINE_MEMMAP_EXECUTABLE_AND_MODULES LIMINE_MEMMAP_KERNEL_AND_MODULES
    â”‚       â”‚       â”‚       #else
    â”‚       â”‚       â”‚           #define LIMINE_MEMMAP_EXECUTABLE_AND_MODULES 10  // Ğ¡Ñ‚Ğ°Ğ½Ğ´Ğ°Ñ€Ñ‚Ğ½Ğ¾Ğµ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ
    â”‚       â”‚       â”‚       #endif
    â”‚       â”‚       â”‚   #endif
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   static volatile struct limine_memmap_response *current_memmap_response = NULL;
    â”‚       â”‚       â”‚   static volatile struct limine_hhdm_response *current_hhdm_response = NULL;
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   // Bitmap for tracking physical pages
    â”‚       â”‚       â”‚   static uint8_t* bitmap = NULL;
    â”‚       â”‚       â”‚   static uint64_t bitmap_size = 0;
    â”‚       â”‚       â”‚   static uint64_t total_pages = 0;
    â”‚       â”‚       â”‚   static uint64_t used_pages = 0;
    â”‚       â”‚       â”‚   static uint64_t total_memory = 0;
    â”‚       â”‚       â”‚   static uint64_t bitmap_pages = 0;
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   // Helper functions
    â”‚       â”‚       â”‚   static void bitmap_set(uint64_t bit) {
    â”‚       â”‚       â”‚       uint64_t byte = bit / 8;
    â”‚       â”‚       â”‚       uint64_t offset = bit % 8;
    â”‚       â”‚       â”‚       bitmap[byte] |= (1 << offset);
    â”‚       â”‚       â”‚       used_pages++;
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   static void bitmap_clear(uint64_t bit) {
    â”‚       â”‚       â”‚       uint64_t byte = bit / 8;
    â”‚       â”‚       â”‚       uint64_t offset = bit % 8;
    â”‚       â”‚       â”‚       bitmap[byte] &= ~(1 << offset);
    â”‚       â”‚       â”‚       used_pages--;
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   static bool bitmap_test(uint64_t bit) {
    â”‚       â”‚       â”‚       uint64_t byte = bit / 8;
    â”‚       â”‚       â”‚       uint64_t offset = bit % 8;
    â”‚       â”‚       â”‚       return (bitmap[byte] & (1 << offset)) != 0;
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   static uint64_t find_free_page(void) {
    â”‚       â”‚       â”‚       if (!current_memmap_response) {
    â”‚       â”‚       â”‚           return (uint64_t)-1;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚       // ĞĞ°Ñ‡Ğ¸Ğ½Ğ°ĞµĞ¼ Ğ¿Ğ¾Ğ¸ÑĞº Ñ Ğ¿ĞµÑ€Ğ²Ğ¾Ğ¹ ÑÑ‚Ñ€Ğ°Ğ½Ğ¸Ñ†Ñ‹, Ğ¿Ñ€Ğ¾Ğ¿ÑƒÑĞºĞ°Ñ Ğ½ÑƒĞ»ĞµĞ²ÑƒÑ
    â”‚       â”‚       â”‚       for (uint64_t i = 1; i < total_pages; i++) {
    â”‚       â”‚       â”‚           if (!bitmap_test(i)) {
    â”‚       â”‚       â”‚               // ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼, Ñ‡Ñ‚Ğ¾ ÑÑ‚Ñ€Ğ°Ğ½Ğ¸Ñ†Ğ° Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ğ°
    â”‚       â”‚       â”‚               bool in_usable_region = false;
    â”‚       â”‚       â”‚               for (uint64_t j = 0; j < current_memmap_response->entry_count; j++) {
    â”‚       â”‚       â”‚                   struct limine_memmap_entry* entry = current_memmap_response->entries[j];
    â”‚       â”‚       â”‚                   if (entry->type == LIMINE_MEMMAP_USABLE) {
    â”‚       â”‚       â”‚                       uint64_t page_addr = i * PAGE_SIZE_4K;
    â”‚       â”‚       â”‚                       if (page_addr >= entry->base && page_addr < entry->base + entry->length) {
    â”‚       â”‚       â”‚                           in_usable_region = true;
    â”‚       â”‚       â”‚                           break;
    â”‚       â”‚       â”‚                       }
    â”‚       â”‚       â”‚                   }
    â”‚       â”‚       â”‚               }
    â”‚       â”‚       â”‚               
    â”‚       â”‚       â”‚               if (in_usable_region) {
    â”‚       â”‚       â”‚                   return i;
    â”‚       â”‚       â”‚               }
    â”‚       â”‚       â”‚           }
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       return (uint64_t)-1;
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   void pmm_init(volatile struct limine_memmap_response *memmap_response,
    â”‚       â”‚       â”‚                 volatile struct limine_hhdm_response *hhdm_response) {
    â”‚       â”‚       â”‚       serial_puts("[PMM] Initializing Physical Memory Manager...\n");
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½ÑĞµĞ¼ ÑƒĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»Ğ¸ Ğ´Ğ»Ñ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ğ² Ğ´Ñ€ÑƒĞ³Ğ¸Ñ… Ñ„ÑƒĞ½ĞºÑ†Ğ¸ÑÑ…
    â”‚       â”‚       â”‚       current_memmap_response = memmap_response;
    â”‚       â”‚       â”‚       current_hhdm_response = hhdm_response;
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       if (!current_memmap_response) {
    â”‚       â”‚       â”‚           serial_puts("[PMM] ERROR: No memory map response!\n");
    â”‚       â”‚       â”‚           return;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       if (!current_hhdm_response) {
    â”‚       â”‚       â”‚           serial_puts("[PMM] ERROR: No HHDM response!\n");
    â”‚       â”‚       â”‚           return;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Calculate total memory and find largest usable region for bitmap
    â”‚       â”‚       â”‚       uint64_t highest_address = 0;
    â”‚       â”‚       â”‚       uint64_t largest_region_size = 0;
    â”‚       â”‚       â”‚       uint64_t largest_region_base = 0;
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       serial_puts("[PMM] Memory map entries:\n");
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       for (uint64_t i = 0; i < current_memmap_response->entry_count; i++) {
    â”‚       â”‚       â”‚           struct limine_memmap_entry* entry = current_memmap_response->entries[i];
    â”‚       â”‚       â”‚           
    â”‚       â”‚       â”‚           char type_str[32];
    â”‚       â”‚       â”‚           switch (entry->type) {
    â”‚       â”‚       â”‚               case LIMINE_MEMMAP_USABLE:
    â”‚       â”‚       â”‚                   strcpy(type_str, "USABLE");
    â”‚       â”‚       â”‚                   break;
    â”‚       â”‚       â”‚               case LIMINE_MEMMAP_RESERVED:
    â”‚       â”‚       â”‚                   strcpy(type_str, "RESERVED");
    â”‚       â”‚       â”‚                   break;
    â”‚       â”‚       â”‚               case LIMINE_MEMMAP_ACPI_RECLAIMABLE:
    â”‚       â”‚       â”‚                   strcpy(type_str, "ACPI_RECLAIMABLE");
    â”‚       â”‚       â”‚                   break;
    â”‚       â”‚       â”‚               case LIMINE_MEMMAP_ACPI_NVS:
    â”‚       â”‚       â”‚                   strcpy(type_str, "ACPI_NVS");
    â”‚       â”‚       â”‚                   break;
    â”‚       â”‚       â”‚               case LIMINE_MEMMAP_BAD_MEMORY:
    â”‚       â”‚       â”‚                   strcpy(type_str, "BAD_MEMORY");
    â”‚       â”‚       â”‚                   break;
    â”‚       â”‚       â”‚               case LIMINE_MEMMAP_BOOTLOADER_RECLAIMABLE:
    â”‚       â”‚       â”‚                   strcpy(type_str, "BOOTLOADER_RECLAIM");
    â”‚       â”‚       â”‚                   break;
    â”‚       â”‚       â”‚               case LIMINE_MEMMAP_EXECUTABLE_AND_MODULES:
    â”‚       â”‚       â”‚                   strcpy(type_str, "KERNEL");
    â”‚       â”‚       â”‚                   break;
    â”‚       â”‚       â”‚               case LIMINE_MEMMAP_FRAMEBUFFER:
    â”‚       â”‚       â”‚                   strcpy(type_str, "FRAMEBUFFER");
    â”‚       â”‚       â”‚                   break;
    â”‚       â”‚       â”‚               default:
    â”‚       â”‚       â”‚                   strcpy(type_str, "UNKNOWN");
    â”‚       â”‚       â”‚                   break;
    â”‚       â”‚       â”‚           }
    â”‚       â”‚       â”‚           
    â”‚       â”‚       â”‚           char buffer[64];
    â”‚       â”‚       â”‚           serial_puts("  [");
    â”‚       â”‚       â”‚           serial_puts(itoa(i, buffer, 10));
    â”‚       â”‚       â”‚           serial_puts("] Base: 0x");
    â”‚       â”‚       â”‚           serial_puts(itoa(entry->base, buffer, 16));
    â”‚       â”‚       â”‚           serial_puts(", Length: 0x");
    â”‚       â”‚       â”‚           serial_puts(itoa(entry->length, buffer, 16));
    â”‚       â”‚       â”‚           serial_puts(", Type: ");
    â”‚       â”‚       â”‚           serial_puts(type_str);
    â”‚       â”‚       â”‚           serial_puts("\n");
    â”‚       â”‚       â”‚           
    â”‚       â”‚       â”‚           total_memory += entry->length;
    â”‚       â”‚       â”‚           
    â”‚       â”‚       â”‚           if (entry->type == LIMINE_MEMMAP_USABLE) {
    â”‚       â”‚       â”‚               uint64_t end = entry->base + entry->length;
    â”‚       â”‚       â”‚               if (end > highest_address) {
    â”‚       â”‚       â”‚                   highest_address = end;
    â”‚       â”‚       â”‚               }
    â”‚       â”‚       â”‚               
    â”‚       â”‚       â”‚               // Find largest usable region for bitmap
    â”‚       â”‚       â”‚               if (entry->length > largest_region_size) {
    â”‚       â”‚       â”‚                   largest_region_size = entry->length;
    â”‚       â”‚       â”‚                   largest_region_base = entry->base;
    â”‚       â”‚       â”‚               }
    â”‚       â”‚       â”‚           }
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Calculate total pages (4KB each)
    â”‚       â”‚       â”‚       total_pages = highest_address / PAGE_SIZE_4K;
    â”‚       â”‚       â”‚       bitmap_size = (total_pages + 7) / 8; // Round up to nearest byte
    â”‚       â”‚       â”‚       bitmap_pages = (bitmap_size + PAGE_SIZE_4K - 1) / PAGE_SIZE_4K;
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       serial_puts("[PMM] Total memory: ");
    â”‚       â”‚       â”‚       char buffer[32];
    â”‚       â”‚       â”‚       serial_puts(itoa(total_memory / 1024 / 1024, buffer, 10));
    â”‚       â”‚       â”‚       serial_puts(" MB\n");
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       serial_puts("[PMM] Total pages: ");
    â”‚       â”‚       â”‚       serial_puts(itoa(total_pages, buffer, 10));
    â”‚       â”‚       â”‚       serial_puts(" (");
    â”‚       â”‚       â”‚       serial_puts(itoa(total_pages * PAGE_SIZE_4K / 1024 / 1024, buffer, 10));
    â”‚       â”‚       â”‚       serial_puts(" MB)\n");
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       serial_puts("[PMM] Bitmap size: ");
    â”‚       â”‚       â”‚       serial_puts(itoa(bitmap_size, buffer, 10));
    â”‚       â”‚       â”‚       serial_puts(" bytes (");
    â”‚       â”‚       â”‚       serial_puts(itoa(bitmap_pages, buffer, 10));
    â”‚       â”‚       â”‚       serial_puts(" pages)\n");
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Find a location for the bitmap in the largest usable region
    â”‚       â”‚       â”‚       if (largest_region_base == 0 || largest_region_size < bitmap_size) {
    â”‚       â”‚       â”‚           serial_puts("[PMM] ERROR: No suitable region for bitmap!\n");
    â”‚       â”‚       â”‚           return;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Place bitmap at the beginning of the largest region
    â”‚       â”‚       â”‚       uint64_t bitmap_physical = largest_region_base;
    â”‚       â”‚       â”‚       bitmap = (uint8_t*)(bitmap_physical + current_hhdm_response->offset);
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Initialize bitmap (all pages are free initially)
    â”‚       â”‚       â”‚       memset(bitmap, 0, bitmap_size);
    â”‚       â”‚       â”‚       used_pages = 0;
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       serial_puts("[PMM] Bitmap placed at physical: 0x");
    â”‚       â”‚       â”‚       serial_puts(itoa(bitmap_physical, buffer, 16));
    â”‚       â”‚       â”‚       serial_puts(", virtual: 0x");
    â”‚       â”‚       â”‚       serial_puts(itoa((uint64_t)bitmap, buffer, 16));
    â”‚       â”‚       â”‚       serial_puts("\n");
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Mark all non-usable memory as used
    â”‚       â”‚       â”‚       for (uint64_t i = 0; i < current_memmap_response->entry_count; i++) {
    â”‚       â”‚       â”‚           struct limine_memmap_entry* entry = current_memmap_response->entries[i];
    â”‚       â”‚       â”‚           
    â”‚       â”‚       â”‚           if (entry->type != LIMINE_MEMMAP_USABLE) {
    â”‚       â”‚       â”‚               // Mark this region as used in bitmap
    â”‚       â”‚       â”‚               uint64_t start_page = entry->base / PAGE_SIZE_4K;
    â”‚       â”‚       â”‚               uint64_t end_page = (entry->base + entry->length + PAGE_SIZE_4K - 1) / PAGE_SIZE_4K;
    â”‚       â”‚       â”‚               
    â”‚       â”‚       â”‚               for (uint64_t page = start_page; page < end_page; page++) {
    â”‚       â”‚       â”‚                   if (page < total_pages) {
    â”‚       â”‚       â”‚                       bitmap_set(page);
    â”‚       â”‚       â”‚                   }
    â”‚       â”‚       â”‚               }
    â”‚       â”‚       â”‚           }
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Mark the bitmap region itself as used
    â”‚       â”‚       â”‚       uint64_t bitmap_start_page = bitmap_physical / PAGE_SIZE_4K;
    â”‚       â”‚       â”‚       uint64_t bitmap_end_page = (bitmap_physical + bitmap_size + PAGE_SIZE_4K - 1) / PAGE_SIZE_4K;
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       for (uint64_t page = bitmap_start_page; page < bitmap_end_page; page++) {
    â”‚       â”‚       â”‚           if (page < total_pages) {
    â”‚       â”‚       â”‚               bitmap_set(page);
    â”‚       â”‚       â”‚           }
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       serial_puts("[PMM] Initial memory state: ");
    â”‚       â”‚       â”‚       serial_puts(itoa(used_pages, buffer, 10));
    â”‚       â”‚       â”‚       serial_puts(" pages used, ");
    â”‚       â”‚       â”‚       serial_puts(itoa(total_pages - used_pages, buffer, 10));
    â”‚       â”‚       â”‚       serial_puts(" pages free\n");
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       serial_puts("[PMM] Physical Memory Manager initialized successfully\n");
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   uint64_t pmm_alloc_page(void) {
    â”‚       â”‚       â”‚       if (!bitmap) {
    â”‚       â”‚       â”‚           serial_puts("[PMM] ERROR: PMM not initialized!\n");
    â”‚       â”‚       â”‚           return 0;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       uint64_t page = find_free_page();
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       if (page == (uint64_t)-1) {
    â”‚       â”‚       â”‚           serial_puts("[PMM] ERROR: Out of physical memory!\n");
    â”‚       â”‚       â”‚           return 0;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       bitmap_set(page);
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       char buffer[32];
    â”‚       â”‚       â”‚       serial_puts("[PMM] Allocated page: 0x");
    â”‚       â”‚       â”‚       serial_puts(itoa(page * PAGE_SIZE_4K, buffer, 16));
    â”‚       â”‚       â”‚       serial_puts(" (");
    â”‚       â”‚       â”‚       serial_puts(itoa(page, buffer, 10));
    â”‚       â”‚       â”‚       serial_puts(")\n");
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       return page * PAGE_SIZE_4K;
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   void pmm_free_page(uint64_t physical_addr) {
    â”‚       â”‚       â”‚       if (!bitmap) {
    â”‚       â”‚       â”‚           serial_puts("[PMM] ERROR: PMM not initialized!\n");
    â”‚       â”‚       â”‚           return;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       uint64_t page = physical_addr / PAGE_SIZE_4K;
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       if (page >= total_pages) {
    â”‚       â”‚       â”‚           serial_puts("[PMM] ERROR: Attempt to free invalid page!\n");
    â”‚       â”‚       â”‚           return;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       if (!bitmap_test(page)) {
    â”‚       â”‚       â”‚           serial_puts("[PMM] WARNING: Page already free!\n");
    â”‚       â”‚       â”‚           return;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       bitmap_clear(page);
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       char buffer[32];
    â”‚       â”‚       â”‚       serial_puts("[PMM] Freed page: 0x");
    â”‚       â”‚       â”‚       serial_puts(itoa(physical_addr, buffer, 16));
    â”‚       â”‚       â”‚       serial_puts(" (");
    â”‚       â”‚       â”‚       serial_puts(itoa(page, buffer, 10));
    â”‚       â”‚       â”‚       serial_puts(")\n");
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   uint64_t pmm_get_free_memory(void) {
    â”‚       â”‚       â”‚       return (total_pages - used_pages) * PAGE_SIZE_4K;
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   uint64_t pmm_get_used_memory(void) {
    â”‚       â”‚       â”‚       return used_pages * PAGE_SIZE_4K;
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   uint64_t pmm_get_total_memory(void) {
    â”‚       â”‚       â”‚       return total_pages * PAGE_SIZE_4K;
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   void pmm_dump_memory_map(void) {
    â”‚       â”‚       â”‚       if (!current_memmap_response) {
    â”‚       â”‚       â”‚           serial_puts("[PMM] ERROR: No memory map available!\n");
    â”‚       â”‚       â”‚           return;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       serial_puts("[PMM] Memory Map Dump:\n");
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       char buffer[64];
    â”‚       â”‚       â”‚       uint64_t total_usable = 0;
    â”‚       â”‚       â”‚       uint64_t total_reserved = 0;
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       for (uint64_t i = 0; i < current_memmap_response->entry_count; i++) {
    â”‚       â”‚       â”‚           struct limine_memmap_entry* entry = current_memmap_response->entries[i];
    â”‚       â”‚       â”‚           
    â”‚       â”‚       â”‚           char type_str[32];
    â”‚       â”‚       â”‚           switch (entry->type) {
    â”‚       â”‚       â”‚               case LIMINE_MEMMAP_USABLE: 
    â”‚       â”‚       â”‚                   strcpy(type_str, "USABLE"); 
    â”‚       â”‚       â”‚                   total_usable += entry->length;
    â”‚       â”‚       â”‚                   break;
    â”‚       â”‚       â”‚               case LIMINE_MEMMAP_RESERVED: 
    â”‚       â”‚       â”‚                   strcpy(type_str, "RESERVED"); 
    â”‚       â”‚       â”‚                   total_reserved += entry->length;
    â”‚       â”‚       â”‚                   break;
    â”‚       â”‚       â”‚               case LIMINE_MEMMAP_ACPI_RECLAIMABLE: strcpy(type_str, "ACPI_RECLAIM"); break;
    â”‚       â”‚       â”‚               case LIMINE_MEMMAP_ACPI_NVS: strcpy(type_str, "ACPI_NVS"); break;
    â”‚       â”‚       â”‚               case LIMINE_MEMMAP_BAD_MEMORY: strcpy(type_str, "BAD"); break;
    â”‚       â”‚       â”‚               case LIMINE_MEMMAP_BOOTLOADER_RECLAIMABLE: strcpy(type_str, "BOOTLOADER"); break;
    â”‚       â”‚       â”‚               case LIMINE_MEMMAP_EXECUTABLE_AND_MODULES: strcpy(type_str, "KERNEL"); break;
    â”‚       â”‚       â”‚               case LIMINE_MEMMAP_FRAMEBUFFER: strcpy(type_str, "FRAMEBUFFER"); break;
    â”‚       â”‚       â”‚               default: strcpy(type_str, "UNKNOWN"); break;
    â”‚       â”‚       â”‚           }
    â”‚       â”‚       â”‚           
    â”‚       â”‚       â”‚           serial_puts("  ");
    â”‚       â”‚       â”‚           serial_puts(type_str);
    â”‚       â”‚       â”‚           serial_puts(": 0x");
    â”‚       â”‚       â”‚           serial_puts(itoa(entry->base, buffer, 16));
    â”‚       â”‚       â”‚           serial_puts(" - 0x");
    â”‚       â”‚       â”‚           serial_puts(itoa(entry->base + entry->length - 1, buffer, 16));
    â”‚       â”‚       â”‚           serial_puts(" (");
    â”‚       â”‚       â”‚           serial_puts(itoa(entry->length / 1024 / 1024, buffer, 10));
    â”‚       â”‚       â”‚           serial_puts(" MB)\n");
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Ğ’Ñ‹Ğ²Ğ¾Ğ´ ÑÑƒĞ¼Ğ¼Ğ°Ñ€Ğ½Ğ¾Ğ¹ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ğ¸
    â”‚       â”‚       â”‚       serial_puts("[PMM] Summary: ");
    â”‚       â”‚       â”‚       serial_puts(itoa(total_usable / 1024 / 1024, buffer, 10));
    â”‚       â”‚       â”‚       serial_puts(" MB usable, ");
    â”‚       â”‚       â”‚       serial_puts(itoa(total_reserved / 1024 / 1024, buffer, 10));
    â”‚       â”‚       â”‚       serial_puts(" MB reserved\n");
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       // Ğ¢Ğ¾Ñ‡Ğ½Ğ°Ñ ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ° PMM
    â”‚       â”‚       â”‚       serial_puts("[PMM] PMM Stats: ");
    â”‚       â”‚       â”‚       serial_puts(itoa(pmm_get_free_memory() / 1024 / 1024, buffer, 10));
    â”‚       â”‚       â”‚       serial_puts(" MB free, ");
    â”‚       â”‚       â”‚       serial_puts(itoa(pmm_get_used_memory() / 1024, buffer, 10));
    â”‚       â”‚       â”‚       serial_puts(" KB used, ");
    â”‚       â”‚       â”‚       serial_puts(itoa(total_pages, buffer, 10));
    â”‚       â”‚       â”‚       serial_puts(" total pages\n");
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚
    â”‚       â”‚   â””â”€â”€ security.c
    â”‚       â”‚       â”‚
    â”‚       â”‚       â”œâ”€â”€ CONTENT:
    â”‚       â”‚       â”‚   #include "include/memory/security.h"
    â”‚       â”‚       â”‚   #include "include/memory/heap.h"
    â”‚       â”‚       â”‚   #include "include/memory/paging.h"
    â”‚       â”‚       â”‚   #include "include/drivers/serial.h"
    â”‚       â”‚       â”‚   #include "libc/string.h"
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   static uint64_t stack_canary = 0;
    â”‚       â”‚       â”‚   static bool security_initialized = false;
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   // Initialize memory security subsystem
    â”‚       â”‚       â”‚   void memory_security_init(void) {
    â”‚       â”‚       â”‚       serial_puts("[SECURITY] Initializing memory security subsystem...\n");
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       stack_protector_init();
    â”‚       â”‚       â”‚       heap_enable_poisoning(true);
    â”‚       â”‚       â”‚       heap_enable_guard_pages(true);
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       security_initialized = true;
    â”‚       â”‚       â”‚       serial_puts("[SECURITY] Memory security initialized\n");
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   // Generate random stack canary
    â”‚       â”‚       â”‚   uint64_t generate_stack_canary(void) {
    â”‚       â”‚       â”‚       // Simple PRNG for demonstration - replace with hardware RNG if available
    â”‚       â”‚       â”‚       static uint64_t seed = 0x123456789ABCDEF0;
    â”‚       â”‚       â”‚       seed = (seed * 6364136223846793005ULL) + 1;
    â”‚       â”‚       â”‚       return seed ^ 0xDEADBEEFCAFEBABE;
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   void stack_protector_init(void) {
    â”‚       â”‚       â”‚       stack_canary = generate_stack_canary();
    â”‚       â”‚       â”‚       serial_puts("[SECURITY] Stack protector initialized\n");
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   bool stack_protector_check(void) {
    â”‚       â”‚       â”‚       // This would be called from exception handlers
    â”‚       â”‚       â”‚       // For now, just return true - real implementation would check canary
    â”‚       â”‚       â”‚       return true;
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   // Comprehensive memory security check
    â”‚       â”‚       â”‚   void memory_security_check(void) {
    â”‚       â”‚       â”‚       if (!security_initialized) {
    â”‚       â”‚       â”‚           serial_puts("[SECURITY] Security subsystem not initialized!\n");
    â”‚       â”‚       â”‚           return;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       serial_puts("[SECURITY] Performing memory security audit...\n");
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       bool heap_ok = heap_validate_all_blocks();
    â”‚       â”‚       â”‚       bool stack_ok = stack_protector_check();
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       if (!heap_ok) {
    â”‚       â”‚       â”‚           serial_puts("[SECURITY] CRITICAL: Heap integrity check failed!\n");
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       if (!stack_ok) {
    â”‚       â”‚       â”‚           serial_puts("[SECURITY] CRITICAL: Stack corruption detected!\n");
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       if (heap_ok && stack_ok) {
    â”‚       â”‚       â”‚           serial_puts("[SECURITY] Memory security audit passed\n");
    â”‚       â”‚       â”‚       } else {
    â”‚       â”‚       â”‚           serial_puts("[SECURITY] Memory security audit FAILED!\n");
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   // Secure memory zeroing that won't be optimized away
    â”‚       â”‚       â”‚   void secure_memzero(void* ptr, size_t size) {
    â”‚       â”‚       â”‚       if (ptr == NULL || size == 0) return;
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       volatile uint8_t* p = (volatile uint8_t*)ptr;
    â”‚       â”‚       â”‚       while (size--) {
    â”‚       â”‚       â”‚           *p++ = 0;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚   
    â”‚       â”‚       â”‚   // Secure memset that won't be optimized away
    â”‚       â”‚       â”‚   void secure_memset(void* ptr, int value, size_t size) {
    â”‚       â”‚       â”‚       if (ptr == NULL || size == 0) return;
    â”‚       â”‚       â”‚       
    â”‚       â”‚       â”‚       volatile uint8_t* p = (volatile uint8_t*)ptr;
    â”‚       â”‚       â”‚       while (size--) {
    â”‚       â”‚       â”‚           *p++ = (uint8_t)value;
    â”‚       â”‚       â”‚       }
    â”‚       â”‚       â”‚   }
    â”‚       â”‚       â”‚
    â”‚       â”œâ”€â”€ simd
    â”‚       â”‚   â””â”€â”€ simd.c
    â”‚       â”‚       â”‚
    â”‚       â”‚       â”œâ”€â”€ CONTENT:
    â”‚       â”‚       â”‚   <empty>
    â”‚       â”‚       â”‚
    â”‚       â””â”€â”€ sys
    â”‚           â”œâ”€â”€ gdt.c
    â”‚               â”‚
    â”‚               â”œâ”€â”€ CONTENT:
    â”‚               â”‚   #include "include/sys/gdt.h"
    â”‚               â”‚   #include "include/drivers/serial.h"
    â”‚               â”‚   #include <stddef.h>
    â”‚               â”‚   
    â”‚               â”‚   // GDT Ñ‚Ğ°Ğ±Ğ»Ğ¸Ñ†Ğ° (8 Ğ·Ğ°Ğ¿Ğ¸ÑĞµĞ¹)
    â”‚               â”‚   static struct gdt_entry gdt[8] = {0};
    â”‚               â”‚   static struct gdt_ptr gdtp;
    â”‚               â”‚   
    â”‚               â”‚   // Ğ’Ğ½ĞµÑˆĞ½ÑÑ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ñ Ğ´Ğ»Ñ Ğ·Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ¸ GDT
    â”‚               â”‚   extern void gdt_flush(uint64_t gdt_ptr);
    â”‚               â”‚   
    â”‚               â”‚   static void gdt_set_entry(int index, uint32_t base, uint32_t limit, uint8_t access, uint8_t granularity) {
    â”‚               â”‚       gdt[index].limit_low = limit & 0xFFFF;
    â”‚               â”‚       gdt[index].base_low = base & 0xFFFF;
    â”‚               â”‚       gdt[index].base_middle = (base >> 16) & 0xFF;
    â”‚               â”‚       gdt[index].access = access;
    â”‚               â”‚       gdt[index].granularity = (limit >> 16) & 0x0F;
    â”‚               â”‚       gdt[index].granularity |= granularity & 0xF0;
    â”‚               â”‚       gdt[index].base_high = (base >> 24) & 0xFF;
    â”‚               â”‚   }
    â”‚               â”‚   
    â”‚               â”‚   void gdt_init(void) {
    â”‚               â”‚       serial_puts("[GDT] Initializing GDT...\n");
    â”‚               â”‚       
    â”‚               â”‚       // Null descriptor (Ğ¾Ğ±ÑĞ·Ğ°Ñ‚ĞµĞ»ĞµĞ½)
    â”‚               â”‚       gdt_set_entry(0, 0, 0, 0, 0);
    â”‚               â”‚       
    â”‚               â”‚       // Kernel Code Segment (index 1)
    â”‚               â”‚       gdt_set_entry(1, 0, 0xFFFFF, 
    â”‚               â”‚                    GDT_ACCESS_PRESENT | GDT_ACCESS_RING0 | GDT_ACCESS_SEGMENT | 
    â”‚               â”‚                    GDT_ACCESS_EXECUTABLE | GDT_ACCESS_READ_WRITE,
    â”‚               â”‚                    GDT_GRANULARITY_4K | GDT_GRANULARITY_LONG | 0xF);
    â”‚               â”‚       
    â”‚               â”‚       // Kernel Data Segment (index 2)
    â”‚               â”‚       gdt_set_entry(2, 0, 0xFFFFF,
    â”‚               â”‚                    GDT_ACCESS_PRESENT | GDT_ACCESS_RING0 | GDT_ACCESS_SEGMENT | 
    â”‚               â”‚                    GDT_ACCESS_READ_WRITE,
    â”‚               â”‚                    GDT_GRANULARITY_4K | 0xF);
    â”‚               â”‚       
    â”‚               â”‚       // ĞÑÑ‚Ğ°Ğ»ÑŒĞ½Ñ‹Ğµ Ğ´ĞµÑĞºÑ€Ğ¸Ğ¿Ñ‚Ğ¾Ñ€Ñ‹ Ğ¾ÑÑ‚Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ½ÑƒĞ»ĞµĞ²Ñ‹Ğ¼Ğ¸ Ğ´Ğ»Ñ ÑĞ¾Ğ²Ğ¼ĞµÑÑ‚Ğ¸Ğ¼Ğ¾ÑÑ‚Ğ¸ Ñ Limine
    â”‚               â”‚       
    â”‚               â”‚       // ĞĞ°ÑÑ‚Ñ€Ğ°Ğ¸Ğ²Ğ°ĞµĞ¼ ÑƒĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»ÑŒ GDT
    â”‚               â”‚       gdtp.limit = sizeof(gdt) - 1;
    â”‚               â”‚       gdtp.base = (uint64_t)&gdt;
    â”‚               â”‚       
    â”‚               â”‚       serial_puts("[GDT] GDT entries set up\n");
    â”‚               â”‚   }
    â”‚               â”‚   
    â”‚               â”‚   void gdt_load(void) {
    â”‚               â”‚       serial_puts("[GDT] Loading GDT...\n");
    â”‚               â”‚       gdt_flush((uint64_t)&gdtp);
    â”‚               â”‚   }
    â”‚               â”‚   
    â”‚               â”‚   const struct gdt_entry* gdt_get_descriptor(int index) {
    â”‚               â”‚       if (index >= 0 && index < 8) {
    â”‚               â”‚           return &gdt[index];
    â”‚               â”‚       }
    â”‚               â”‚       return NULL;
    â”‚               â”‚   }
    â”‚               â”‚
    â”‚           â””â”€â”€ gdt_asm.S
    â”‚               â”‚
    â”‚               â”œâ”€â”€ CONTENT:
    â”‚               â”‚   .section .text
    â”‚               â”‚   .global gdt_flush
    â”‚               â”‚   
    â”‚               â”‚   gdt_flush:
    â”‚               â”‚       // rdi ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ¸Ñ‚ ÑƒĞºĞ°Ğ·Ğ°Ñ‚ĞµĞ»ÑŒ Ğ½Ğ° struct gdt_ptr
    â”‚               â”‚       lgdt (%rdi)
    â”‚               â”‚       
    â”‚               â”‚       // ĞĞ±Ğ½Ğ¾Ğ²Ğ»ÑĞµĞ¼ ÑĞµĞ³Ğ¼ĞµĞ½Ñ‚Ğ½Ñ‹Ğµ Ñ€ĞµĞ³Ğ¸ÑÑ‚Ñ€Ñ‹
    â”‚               â”‚       mov $0x10, %ax    // Kernel Data Segment selector (8-Ğ¹ Ğ´ĞµÑĞºÑ€Ğ¸Ğ¿Ñ‚Ğ¾Ñ€ * 8 = 0x10)
    â”‚               â”‚       mov %ax, %ds
    â”‚               â”‚       mov %ax, %es
    â”‚               â”‚       mov %ax, %fs
    â”‚               â”‚       mov %ax, %gs
    â”‚               â”‚       mov %ax, %ss
    â”‚               â”‚       
    â”‚               â”‚       // Ğ”ĞµĞ»Ğ°ĞµĞ¼ Ğ´Ğ°Ğ»ÑŒĞ½Ğ¸Ğ¹ Ğ¿ĞµÑ€ĞµÑ…Ğ¾Ğ´ Ğ´Ğ»Ñ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ»ĞµĞ½Ğ¸Ñ CS
    â”‚               â”‚       pushq $0x08       // Kernel Code Segment selector (7-Ğ¹ Ğ´ĞµÑĞºÑ€Ğ¸Ğ¿Ñ‚Ğ¾Ñ€ * 8 = 0x08)
    â”‚               â”‚       lea .flush_here(%rip), %rax
    â”‚               â”‚       pushq %rax
    â”‚               â”‚       lretq
    â”‚               â”‚   
    â”‚               â”‚   .flush_here:
    â”‚               â”‚       ret
    â”‚               â”‚
    â”œâ”€â”€ limine-tools
    â”‚   â”œâ”€â”€ cc-runtime
    â”‚       â””â”€â”€ <ÑĞºÑ€Ñ‹Ñ‚Ğ¾: ÑĞ¸ÑÑ‚ĞµĞ¼Ğ½Ğ°Ñ/Ğ±Ğ¸Ğ½Ğ°Ñ€Ğ½Ğ°Ñ Ğ´Ğ¸Ñ€ĞµĞºÑ‚Ğ¾Ñ€Ğ¸Ñ>
    â”‚   â”œâ”€â”€ freestnd-c-hdrs
    â”‚       â””â”€â”€ <ÑĞºÑ€Ñ‹Ñ‚Ğ¾: ÑĞ¸ÑÑ‚ĞµĞ¼Ğ½Ğ°Ñ/Ğ±Ğ¸Ğ½Ğ°Ñ€Ğ½Ğ°Ñ Ğ´Ğ¸Ñ€ĞµĞºÑ‚Ğ¾Ñ€Ğ¸Ñ>
    â”‚   â”œâ”€â”€ limine
    â”‚       â””â”€â”€ <ÑĞºÑ€Ñ‹Ñ‚Ğ¾: ÑĞ¸ÑÑ‚ĞµĞ¼Ğ½Ğ°Ñ/Ğ±Ğ¸Ğ½Ğ°Ñ€Ğ½Ğ°Ñ Ğ´Ğ¸Ñ€ĞµĞºÑ‚Ğ¾Ñ€Ğ¸Ñ>
    â”‚   â”œâ”€â”€ limine-protocol
    â”‚       â””â”€â”€ <ÑĞºÑ€Ñ‹Ñ‚Ğ¾: ÑĞ¸ÑÑ‚ĞµĞ¼Ğ½Ğ°Ñ/Ğ±Ğ¸Ğ½Ğ°Ñ€Ğ½Ğ°Ñ Ğ´Ğ¸Ñ€ĞµĞºÑ‚Ğ¾Ñ€Ğ¸Ñ>
    â”‚   â””â”€â”€ ovmf
    â”‚       â””â”€â”€ <ÑĞºÑ€Ñ‹Ñ‚Ğ¾: ÑĞ¸ÑÑ‚ĞµĞ¼Ğ½Ğ°Ñ/Ğ±Ğ¸Ğ½Ğ°Ñ€Ğ½Ğ°Ñ Ğ´Ğ¸Ñ€ĞµĞºÑ‚Ğ¾Ñ€Ğ¸Ñ>
    â”œâ”€â”€ limine.conf
        â”‚
        â”œâ”€â”€ CONTENT:
        â”‚   # Timeout in seconds that Limine will use before automatically booting.
        â”‚   timeout: 3
        â”‚   
        â”‚   # The entry name that will be displayed in the boot menu.
        â”‚   /DEER OS v0.0.1
        â”‚       # We use the Limine boot protocol.
        â”‚       protocol: limine
        â”‚   
        â”‚       # Path to the kernel to boot. boot():/ represents the partition on which limine.conf is located.
        â”‚       path: boot():/boot/kernel
        â”‚       resolution: 800x600
        â”‚
    â””â”€â”€ os-config.json
        â”‚
        â”œâ”€â”€ CONTENT:
        â”‚   {
        â”‚       "name": "DEER",
        â”‚       "version": "v0.0.1",
        â”‚       "description": "A 64-bit operating system for extreme conditions.",
        â”‚       "author": "VeoQeo",
        â”‚       "arch": "x86_64",
        â”‚       "bootloader": "limine",
        â”‚       "website": null,
        â”‚       "license": "MIT"
        â”‚   }
        â”‚
