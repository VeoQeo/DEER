#!/usr/bin/env python3
"""
OSDev Build System 

OSCRIPTUM

–£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞ —Å–±–æ—Ä–∫–∏ –¥–ª—è –æ–ø–µ—Ä–∞—Ü–∏–æ–Ω–Ω—ã—Ö —Å–∏—Å—Ç–µ–º —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π:
- –ö—Ä–æ—Å—Å-–∫–æ–º–ø–∏–ª—è—Ü–∏–∏ x86_64
- –ì–µ–Ω–µ—Ä–∞—Ü–∏–∏ ISO –æ–±—Ä–∞–∑–æ–≤
- –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –≤ QEMU
- –£–ø—Ä–∞–≤–ª–µ–Ω–∏—è –≤–µ—Ä—Å–∏—è–º–∏
- –ö–∞—Å—Ç–æ–º–∏–∑–∞—Ü–∏–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –û–°
"""

import os
import sys
import subprocess
from pathlib import Path
import argparse
import shutil
import time
import json
from datetime import datetime
from typing import List, Dict, Optional, Tuple
from enum import Enum, auto
import readline
import glob
import multiprocessing
import hashlib
import zipfile
import tarfile
import concurrent.futures
from dataclasses import dataclass

KERNEL_SRC = 'kernel.c'
BOOT_ASM = 'boot.S'
LINKER_SCRIPT = 'link.ld'
GRUB_CONFIG = 'grub.cfg'


class LogLevel(Enum):
    DEBUG = auto()
    INFO = auto()
    WARNING = auto()
    ERROR = auto()
    CRITICAL = auto()
    SUCCESS = auto()


class Color:
    PURPLE = '\033[95m'
    CYAN = '\033[96m'
    DARKCYAN = '\033[36m'
    BLUE = '\033[94m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    ORANGE = '\033[33m'
    PINK = '\033[95m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'
    END = '\033[0m'


@dataclass
class BuildStats:
    total_files: int = 0
    compiled_files: int = 0
    start_time: float = 0
    end_time: float = 0
    memory_usage: float = 0


class OSConfig:
    def __init__(self):
        self.NAME = "BELL"
        self.VERSION = "0.7.0"
        self.AUTHOR = "Anonymous OSDev"
        self.DESCRIPTION = "A simple 64-bit OS that prints 'ABC 64 BIT'"
        self.BUILD_DATE = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        self.ELF_KERNEL = f'{self.NAME.lower()}.kernel'
        self.BIN_KERNEL = f'{self.NAME.lower()}.bin'
        self.ISO_OUTPUT = f'{self.NAME.lower()}.iso'

        self.ARCH = 'x86_64'
        self.TARGET = 'x86_64-elf'
        self.CC = f'{self.TARGET}-gcc'
        self.LD = f'{self.TARGET}-ld'
        self.OBJCOPY = f'{self.TARGET}-objcopy'
        self.GRUB_FILE = 'grub-file'
        self.GRUB_MKRESCUE = 'grub-mkrescue'
        
        self.CFLAGS = '-ffreestanding -O2 -Wall -Wextra -std=gnu11 -mno-red-zone -fno-stack-protector -fno-pic'
        self.LDFLAGS = '-nostdlib'
        self.INCLUDES = ['include']
        
        self.SOURCE_DIRS = ['src']
        
        self.BUILD_DIR = 'build'
        self.BIN_DIR = 'bin'
        self.DEMO_ISO_DIR = 'demo_iso'
        self.ISO_DIR = 'isodir'
        self.GRUB_CFG = f'src/{GRUB_CONFIG}'
        self.TREE_FILE = 'OS-TREE.txt'
        self.BUILD_CACHE = '.build_cache'

        self.QEMU_CMD = 'qemu-system-x86_64'
        self.QEMU_MEMORY = '512M'
        self.QEMU_AUDIO = False
        self.QEMU_SERIAL = True
        self.QEMU_CLEAN_AFTER_RUN = False
        self.QEMU_GDB_PORT = 1234
        self.QEMU_NETWORK = False

        self.GRUB_TIMEOUT = 10
        self.GRUB_DEFAULT = 0
        self.GRUB_MENU_COLORS = {
            'normal': 'white/black',
            'highlight': 'black/light-gray'
        }

        self.PARALLEL_BUILD = True
        self.MAX_WORKERS = multiprocessing.cpu_count()
        self.OPTIMIZATION_LEVEL = 'O2'
        self.COMPRESS_ISO = False
        self.BACKUP_BUILDS = True
        self.AUTO_UPDATE = False

    def get_kernel_output(self) -> str:
        return f'{self.BIN_DIR}/{self.ELF_KERNEL}'

    def get_kernel_binary(self) -> str:
        return f'{self.BIN_DIR}/{self.BIN_KERNEL}'

    def get_iso_image(self, versioned: bool = False) -> str:
        if versioned:
            timestamp = datetime.now().strftime("%Y%m%d-%H%M%S")
            return f'{self.DEMO_ISO_DIR}/{self.NAME.lower()}-v{self.VERSION}-{timestamp}.iso'
        return f'{self.BIN_DIR}/{self.ISO_OUTPUT}'

    def load_config(self, config_file: str = 'os_config.json') -> None:
        if not os.path.exists(config_file):
            self.create_default_config(config_file)
        try:
            with open(config_file, 'r') as f:
                config_data = json.load(f)
                for key, value in config_data.items():
                    if hasattr(self, key):
                        if key in ['QEMU_AUDIO', 'QEMU_SERIAL', 'QEMU_CLEAN_AFTER_RUN', 'PARALLEL_BUILD', 'COMPRESS_ISO', 'BACKUP_BUILDS', 'AUTO_UPDATE', 'QEMU_NETWORK']:
                            value = str(value).lower() in ('true', '1', 't', 'y', 'yes')
                        setattr(self, key, value)
                self._update_dynamic_names()
            self.log(f"–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –∑–∞–≥—Ä—É–∂–µ–Ω–∞ –∏–∑ {config_file}", LogLevel.SUCCESS)
        except Exception as e:
            self.log(f"–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏: {e}", LogLevel.ERROR)

    def save_config(self, config_file: str = 'os_config.json') -> None:
        config_data = {
            'NAME': self.NAME,
            'VERSION': self.VERSION,
            'AUTHOR': self.AUTHOR,
            'DESCRIPTION': self.DESCRIPTION,
            'ARCH': self.ARCH,
            'TARGET': self.TARGET,
            'CFLAGS': self.CFLAGS,
            'LDFLAGS': self.LDFLAGS,
            'QEMU_MEMORY': self.QEMU_MEMORY,
            'QEMU_AUDIO': self.QEMU_AUDIO,
            'QEMU_SERIAL': self.QEMU_SERIAL,
            'QEMU_NETWORK': self.QEMU_NETWORK,
            'QEMU_CLEAN_AFTER_RUN': self.QEMU_CLEAN_AFTER_RUN,
            'GRUB_TIMEOUT': self.GRUB_TIMEOUT,
            'GRUB_DEFAULT': self.GRUB_DEFAULT,
            'PARALLEL_BUILD': self.PARALLEL_BUILD,
            'MAX_WORKERS': self.MAX_WORKERS,
            'OPTIMIZATION_LEVEL': self.OPTIMIZATION_LEVEL,
            'COMPRESS_ISO': self.COMPRESS_ISO,
            'BACKUP_BUILDS': self.BACKUP_BUILDS,
            'AUTO_UPDATE': self.AUTO_UPDATE
        }
        try:
            with open(config_file, 'w') as f:
                json.dump(config_data, f, indent=4)
            self.log(f"–ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –≤ {config_file}", LogLevel.SUCCESS)
        except Exception as e:
            self.log(f"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏: {e}", LogLevel.ERROR)

    def create_default_config(self, config_file: str = 'os_config.json') -> None:
        default_config = {
            'NAME': 'OS',
            'VERSION': '0.7.0',
            'AUTHOR': 'Anonymous OSDev',
            'DESCRIPTION': 'A simple 64-bit OS that prints \'ABC 64 BIT\'',
            'ARCH': 'x86_64',
            'TARGET': 'x86_64-elf',
            'CFLAGS': '-ffreestanding -O2 -Wall -Wextra -std=gnu11 -mno-red-zone -fno-stack-protector -fno-pic',
            'LDFLAGS': '-nostdlib',
            'QEMU_MEMORY': '512M',
            'QEMU_AUDIO': False,
            'QEMU_SERIAL': True,
            'QEMU_NETWORK': False,
            'QEMU_CLEAN_AFTER_RUN': False,
            'GRUB_TIMEOUT': 0,
            'GRUB_DEFAULT': 0,
            'PARALLEL_BUILD': True,
            'MAX_WORKERS': multiprocessing.cpu_count(),
            'OPTIMIZATION_LEVEL': 'O2',
            'COMPRESS_ISO': False,
            'BACKUP_BUILDS': True,
            'AUTO_UPDATE': False
        }
        try:
            with open(config_file, 'w') as f:
                json.dump(default_config, f, indent=4)
            self.log(f"–°–æ–∑–¥–∞–Ω —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –∫–æ–Ω—Ñ–∏–≥: {config_file}", LogLevel.SUCCESS)
        except Exception as e:
            self.log(f"–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è os_config.json: {e}", LogLevel.ERROR)

    def _update_dynamic_names(self):
        self.ELF_KERNEL = f'{self.NAME.lower()}.kernel'
        self.BIN_KERNEL = f'{self.NAME.lower()}.bin'
        self.ISO_OUTPUT = f'{self.NAME.lower()}.iso'

    def edit_config_interactive(self) -> None:
        print(f"{Color.BOLD}{Color.CYAN}üåÄ –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏ –û–°{Color.END}")
        print(f"{Color.YELLOW}‚ú® –û—Å—Ç–∞–≤—å—Ç–µ –ø–æ–ª–µ –ø—É—Å—Ç—ã–º, —á—Ç–æ–±—ã —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ç–µ–∫—É—â–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ{Color.END}")

        config_items = [
            ('NAME', 'üåà –ò–º—è –û–°', str),
            ('VERSION', 'üì¶ –í–µ—Ä—Å–∏—è –û–°', str),
            ('AUTHOR', 'üë§ –ê–≤—Ç–æ—Ä', str),
            ('DESCRIPTION', 'üìù –û–ø–∏—Å–∞–Ω–∏–µ', str),
            ('ARCH', 'üèóÔ∏è –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞', str),
            ('TARGET', 'üéØ –¶–µ–ª–µ–≤–∞—è –ø–ª–∞—Ç—Ñ–æ—Ä–º–∞', str),
            ('QEMU_MEMORY', 'üíæ –ü–∞–º—è—Ç—å QEMU (–Ω–∞–ø—Ä–∏–º–µ—Ä, 512M)', str),
            ('QEMU_AUDIO', 'üîä –ó–≤—É–∫ –≤ QEMU (y/n)', lambda x: x.lower() in ('y', 'yes')),
            ('QEMU_SERIAL', 'üîå –ü–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω—ã–π –ø–æ—Ä—Ç –≤ QEMU (y/n)', lambda x: x.lower() in ('y', 'yes')),
            ('QEMU_NETWORK', 'üåê –°–µ—Ç—å –≤ QEMU (y/n)', lambda x: x.lower() in ('y', 'yes')),
            ('QEMU_CLEAN_AFTER_RUN', 'üßπ –û—á–∏—Å—Ç–∫–∞ –ø–æ—Å–ª–µ –∑–∞–ø—É—Å–∫–∞ QEMU (y/n)', lambda x: x.lower() in ('y', 'yes')),
            ('GRUB_TIMEOUT', '‚è∞ –¢–∞–π–º–∞—É—Ç –º–µ–Ω—é GRUB (—Å–µ–∫, -1 = –Ω–µ—Ç –º–µ–Ω—é)', int),
            ('GRUB_DEFAULT', 'üîò –ü—É–Ω–∫—Ç –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –≤ –º–µ–Ω—é GRUB', int),
            ('PARALLEL_BUILD', '‚ö° –ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω–∞—è —Å–±–æ—Ä–∫–∞ (y/n)', lambda x: x.lower() in ('y', 'yes')),
            ('MAX_WORKERS', 'üë• –ú–∞–∫—Å–∏–º—É–º –ø–æ—Ç–æ–∫–æ–≤ —Å–±–æ—Ä–∫–∏', int),
            ('OPTIMIZATION_LEVEL', 'üöÄ –£—Ä–æ–≤–µ–Ω—å –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ (O0, O1, O2, O3, Os)', str),
            ('COMPRESS_ISO', 'üóúÔ∏è –°–∂–∞—Ç–∏–µ ISO (y/n)', lambda x: x.lower() in ('y', 'yes')),
            ('BACKUP_BUILDS', 'üíæ –†–µ–∑–µ—Ä–≤–Ω—ã–µ –∫–æ–ø–∏–∏ —Å–±–æ—Ä–æ–∫ (y/n)', lambda x: x.lower() in ('y', 'yes')),
        ]

        for attr, prompt, validator in config_items:
            current_value = getattr(self, attr)
            while True:
                try:
                    user_input = input(f"{prompt} [{current_value}]: ").strip()
                    if not user_input:
                        break
                    new_value = validator(user_input) if validator != bool else (user_input.lower() in ('y', 'yes'))
                    setattr(self, attr, new_value)
                    break
                except ValueError:
                    print(f"{Color.RED}‚ùå –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ!{Color.END}")

        self._update_dynamic_names()
        self.save_config()
        print(f"{Color.GREEN}‚úÖ –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∞!{Color.END}")

    def log(self, message: str, level: LogLevel = LogLevel.INFO) -> None:
        colors = {
            LogLevel.DEBUG: Color.DARKCYAN,
            LogLevel.INFO: Color.BLUE,
            LogLevel.WARNING: Color.YELLOW,
            LogLevel.ERROR: Color.RED,
            LogLevel.CRITICAL: Color.RED + Color.BOLD,
            LogLevel.SUCCESS: Color.GREEN
        }
        icons = {
            LogLevel.DEBUG: "üîç",
            LogLevel.INFO: "‚ÑπÔ∏è",
            LogLevel.WARNING: "‚ö†Ô∏è",
            LogLevel.ERROR: "‚ùå",
            LogLevel.CRITICAL: "üí•",
            LogLevel.SUCCESS: "‚úÖ"
        }
        print(f"{colors.get(level, '')}{icons.get(level, '')} {message}{Color.END}")


class BuildSystem:
    def __init__(self, config: OSConfig):
        self.config = config
        self.start_time = time.time()
        self.stats = BuildStats()
        self.build_cache = {}

    def print_banner(self) -> None:
        banner = fr"""
{Color.PURPLE}{Color.BOLD}
   ___  ____   ____ ____  ___ ____ _____ _   _ __  __ 
  / _ \/ ___| / ___|  _ \|_ _|  _ \_   _| | | |  \/  |
 | | | \___ \| |   | |_) || || |_) || | | | | | |\/| |
 | |_| |___) | |___|  _ < | ||  __/ | | | |_| | |  | |
  \___/|____/ \____|_| \_\___|_|    |_|  \___/|_|  |_|
                                                      
{Color.END}
{Color.CYAN}üè∑Ô∏è  OS Name:    {Color.BOLD}{self.config.NAME}{Color.END}
{Color.CYAN}üì¶ Version:    {Color.BOLD}{self.config.VERSION}{Color.END}
{Color.CYAN}üë§ Author:     {Color.BOLD}{self.config.AUTHOR}{Color.END}
{Color.CYAN}üìù Description:{Color.BOLD}{self.config.DESCRIPTION}{Color.END}
{Color.CYAN}üìÖ Build Date: {Color.BOLD}{self.config.BUILD_DATE}{Color.END}
{Color.CYAN}üéØ Target:     {Color.BOLD}{self.config.TARGET}{Color.END}
{Color.CYAN}üèóÔ∏è Arch:       {Color.BOLD}{self.config.ARCH}{Color.END}
{Color.CYAN}‚ö° Workers:    {Color.BOLD}{self.config.MAX_WORKERS}{Color.END}
{Color.CYAN}üöÄ Optimize:   {Color.BOLD}{self.config.OPTIMIZATION_LEVEL}{Color.END}
"""
        print(banner)

    def ensure_dir(self, path: str) -> None:
        Path(path).mkdir(parents=True, exist_ok=True)
        self.config.log(f"üìÅ –î–∏—Ä–µ–∫—Ç–æ—Ä–∏—è {path} —Å–æ–∑–¥–∞–Ω–∞/–ø—Ä–æ–≤–µ—Ä–µ–Ω–∞", LogLevel.DEBUG)

    def get_file_hash(self, filepath: str) -> str:
        hasher = hashlib.md5()
        try:
            with open(filepath, 'rb') as f:
                for chunk in iter(lambda: f.read(4096), b""):
                    hasher.update(chunk)
            return hasher.hexdigest()
        except Exception:
            return ""

    def load_build_cache(self) -> None:
        cache_file = self.config.BUILD_CACHE
        if os.path.exists(cache_file):
            try:
                with open(cache_file, 'r') as f:
                    self.build_cache = json.load(f)
            except Exception:
                self.build_cache = {}

    def save_build_cache(self) -> None:
        cache_file = self.config.BUILD_CACHE
        try:
            with open(cache_file, 'w') as f:
                json.dump(self.build_cache, f, indent=2)
        except Exception:
            pass

    def should_compile(self, src: str, obj: str) -> bool:
        if not os.path.exists(obj):
            return True
        
        src_mtime = os.path.getmtime(src)
        obj_mtime = os.path.getmtime(obj)
        
        if src_mtime > obj_mtime:
            return True
        
        src_hash = self.get_file_hash(src)
        cached_hash = self.build_cache.get(src)
        
        if src_hash != cached_hash:
            return True
            
        return False

    def update_cache(self, src: str) -> None:
        self.build_cache[src] = self.get_file_hash(src)

    def compile_single_source(self, args) -> Tuple[bool, str]:
        src, obj, cmd = args
        try:
            subprocess.run(cmd, shell=True, check=True, capture_output=True)
            self.update_cache(src)
            return True, src
        except subprocess.CalledProcessError as e:
            return False, f"{src}: {e}"

    def find_sources(self, extensions: Tuple[str, ...] = ('.c', '.S', '.asm')) -> List[str]:
        sources = []
        exclude_files = {BOOT_ASM}

        for directory in self.config.SOURCE_DIRS:
            for root, _, files in os.walk(directory):
                for file in files:
                    if file.endswith(extensions) and file not in exclude_files:
                        full_path = os.path.join(root, file)
                        sources.append(full_path)
                        self.config.log(f"üìÑ –î–æ–±–∞–≤–ª–µ–Ω –∏—Å—Ç–æ—á–Ω–∏–∫: {full_path}", LogLevel.DEBUG)

        self.config.log(f"üîç –ù–∞–π–¥–µ–Ω–æ {len(sources)} –∏—Å—Ö–æ–¥–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤", LogLevel.INFO)
        return sources

    def compile_sources(self, sources: List[str], obj_dir: str) -> List[str]:
        objects = []
        include_flags = ' '.join(f'-I{inc}' for inc in self.config.INCLUDES)
        compile_tasks = []

        for src in sources:
            obj = os.path.join(obj_dir, f"{Path(src).stem}.o")
            objects.append(obj)

            if not self.should_compile(src, obj):
                self.config.log(f"‚ôªÔ∏è  –ü—Ä–æ–ø—É—Å–∫ (–∞–∫—Ç—É–∞–ª–µ–Ω): {src}", LogLevel.DEBUG)
                continue

            cmd = f"{self.config.CC} {self.config.CFLAGS} {include_flags} -c {src} -o {obj}"
            compile_tasks.append((src, obj, cmd))

        if not compile_tasks:
            return objects

        self.stats.total_files = len(compile_tasks)
        self.config.log(f"üî® –ö–æ–º–ø–∏–ª—è—Ü–∏—è {len(compile_tasks)} —Ñ–∞–π–ª–æ–≤...", LogLevel.INFO)

        if self.config.PARALLEL_BUILD and len(compile_tasks) > 1:
            with concurrent.futures.ThreadPoolExecutor(max_workers=self.config.MAX_WORKERS) as executor:
                future_to_src = {executor.submit(self.compile_single_source, task): task[0] for task in compile_tasks}
                
                for future in concurrent.futures.as_completed(future_to_src):
                    src_file = future_to_src[future]
                    try:
                        success, result = future.result()
                        if success:
                            self.config.log(f"‚úÖ –°–∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞–Ω: {src_file}", LogLevel.SUCCESS)
                            self.stats.compiled_files += 1
                        else:
                            self.config.log(f"‚ùå –û—à–∏–±–∫–∞ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏: {result}", LogLevel.ERROR)
                            sys.exit(1)
                    except Exception as e:
                        self.config.log(f"üí• –ò—Å–∫–ª—é—á–µ–Ω–∏–µ –ø—Ä–∏ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ {src_file}: {e}", LogLevel.ERROR)
                        sys.exit(1)
        else:
            for src, obj, cmd in compile_tasks:
                self.config.log(f"üî® –ö–æ–º–ø–∏–ª—è—Ü–∏—è: {src}", LogLevel.INFO)
                try:
                    subprocess.run(cmd, shell=True, check=True)
                    self.update_cache(src)
                    self.config.log(f"‚úÖ –°–∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞–Ω: {src}", LogLevel.SUCCESS)
                    self.stats.compiled_files += 1
                except subprocess.CalledProcessError as e:
                    self.config.log(f"‚ùå –û—à–∏–±–∫–∞ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ {src}: {e}", LogLevel.ERROR)
                    sys.exit(1)

        return objects

    def link_kernel(self, objects: List[str], output: str, linker_script: str) -> None:
        cmd = (
            f"{self.config.CC} {self.config.LDFLAGS} -T {linker_script} "
            f"-o {output} {' '.join(objects)}"
        )
        self.config.log(f"üîó –õ–∏–Ω–∫–æ–≤–∫–∞ —è–¥—Ä–∞ -> {output}", LogLevel.INFO)
        try:
            subprocess.run(cmd, shell=True, check=True)
            self.config.log(f"‚úÖ –Ø–¥—Ä–æ —É—Å–ø–µ—à–Ω–æ —Å–ª–∏–Ω–∫–æ–≤–∞–Ω–æ", LogLevel.SUCCESS)
        except subprocess.CalledProcessError as e:
            self.config.log(f"‚ùå –û—à–∏–±–∫–∞ –ª–∏–Ω–∫–æ–≤–∫–∏: {e}", LogLevel.ERROR)
            sys.exit(1)

        self.config.log("üîç –ü—Ä–æ–≤–µ—Ä–∫–∞ Multiboot2 —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏", LogLevel.INFO)
        try:
            result = subprocess.run(
                [self.config.GRUB_FILE, '--is-x86-multiboot2', output],
                capture_output=True
            )
            if result.returncode != 0:
                self.config.log("‚ö†Ô∏è –§–∞–π–ª –Ω–µ —è–≤–ª—è–µ—Ç—Å—è Multiboot2 —Å–æ–≤–º–µ—Å—Ç–∏–º—ã–º!", LogLevel.WARNING)
        except Exception:
            pass

    def create_kernel_binary(self, elf_kernel: str, bin_kernel: str) -> None:
        if not os.path.exists(elf_kernel):
            self.config.log(f"‚ùå ELF —Ñ–∞–π–ª —è–¥—Ä–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω: {elf_kernel}", LogLevel.ERROR)
            return

        if os.path.exists(bin_kernel) and os.path.getmtime(bin_kernel) >= os.path.getmtime(elf_kernel):
            self.config.log(f"‚ôªÔ∏è –ë–∏–Ω–∞—Ä–Ω—ã–π —Ñ–∞–π–ª –∞–∫—Ç—É–∞–ª–µ–Ω: {bin_kernel}", LogLevel.DEBUG)
            return

        self.config.log(f"üî® –°–æ–∑–¥–∞–Ω–∏–µ –±–∏–Ω–∞—Ä–Ω–æ–≥–æ —Ñ–∞–π–ª–∞: {bin_kernel}", LogLevel.INFO)
        cmd = f"{self.config.OBJCOPY} -O binary {elf_kernel} {bin_kernel}"
        try:
            subprocess.run(cmd, shell=True, check=True)
            self.config.log(f"‚úÖ –ë–∏–Ω–∞—Ä–Ω—ã–π —Ñ–∞–π–ª —Å–æ–∑–¥–∞–Ω: {bin_kernel}", LogLevel.SUCCESS)
        except subprocess.CalledProcessError as e:
            self.config.log(f"‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è .bin: {e}", LogLevel.ERROR)
            sys.exit(1)

    def create_grub_cfg(self, grub_cfg_path: str) -> None:
        should_create = True
        if os.path.exists(grub_cfg_path):
            try:
                with open(grub_cfg_path, 'r') as f:
                    content = f.read()
                    timeout_match = f'timeout={self.config.GRUB_TIMEOUT}' in content
                    default_match = f'default={self.config.GRUB_DEFAULT}' in content
                    menuentry_match = f'menuentry "{self.config.NAME} OS v{self.config.VERSION}"' in content
                    if timeout_match and default_match and menuentry_match:
                        should_create = False
            except Exception:
                pass

        if not should_create:
            return

        grub_content = f"""
timeout={self.config.GRUB_TIMEOUT}
default={self.config.GRUB_DEFAULT}
menuentry "{self.config.NAME} OS v{self.config.VERSION}" {{
    multiboot2 /boot/{self.config.ELF_KERNEL}
    boot
}}
"""
        try:
            self.ensure_dir(os.path.dirname(grub_cfg_path))
            with open(grub_cfg_path, 'w') as f:
                f.write(grub_content.strip())
            self.config.log(f"‚úÖ –°–æ–∑–¥–∞–Ω/–æ–±–Ω–æ–≤–ª—ë–Ω GRUB –∫–æ–Ω—Ñ–∏–≥: {grub_cfg_path}", LogLevel.SUCCESS)
        except Exception as e:
            self.config.log(f"‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è grub.cfg: {e}", LogLevel.ERROR)
            sys.exit(1)

    def create_iso(self, kernel_bin: str, iso_dir: str, grub_cfg_src: str, iso_image: str) -> None:
        boot_dir = f"{iso_dir}/boot"
        grub_dir = f"{boot_dir}/grub"

        self.ensure_dir(boot_dir)
        self.ensure_dir(grub_dir)

        shutil.copy(kernel_bin, f"{boot_dir}/{self.config.BIN_KERNEL}")
        kernel_elf = self.config.get_kernel_output()
        if os.path.exists(kernel_elf):
            shutil.copy(kernel_elf, f"{boot_dir}/{self.config.ELF_KERNEL}")

        shutil.copy(grub_cfg_src, f"{grub_dir}/{GRUB_CONFIG}")

        self.config.log(f"üìÄ –°–æ–∑–¥–∞–Ω–∏–µ ISO: {iso_image}", LogLevel.INFO)
        try:
            subprocess.run(
                f"{self.config.GRUB_MKRESCUE} -o {iso_image} {iso_dir}",
                shell=True, check=True
            )
            self.config.log(f"‚úÖ ISO —Å–æ–∑–¥–∞–Ω: {iso_image}", LogLevel.SUCCESS)
        except subprocess.CalledProcessError as e:
            self.config.log(f"‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è ISO: {e}", LogLevel.ERROR)
            sys.exit(1)

    def compress_iso(self, iso_path: str) -> None:
        if not self.config.COMPRESS_ISO:
            return
            
        compressed_path = f"{iso_path}.xz"
        self.config.log(f"üóúÔ∏è –°–∂–∞—Ç–∏–µ ISO...", LogLevel.INFO)
        try:
            subprocess.run(f"xz -k -9 {iso_path}", shell=True, check=True)
            self.config.log(f"‚úÖ ISO —Å–∂–∞—Ç: {compressed_path}", LogLevel.SUCCESS)
        except subprocess.CalledProcessError:
            self.config.log("‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å —Å–∂–∞—Ç—å ISO", LogLevel.WARNING)

    def backup_build(self) -> None:
        if not self.config.BACKUP_BUILDS:
            return
            
        backup_dir = f"backups/{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        self.ensure_dir(backup_dir)
        
        files_to_backup = [
            self.config.get_kernel_output(),
            self.config.get_kernel_binary(),
            self.config.get_iso_image()
        ]
        
        for file_path in files_to_backup:
            if os.path.exists(file_path):
                shutil.copy2(file_path, backup_dir)
                
        self.config.log(f"üíæ –†–µ–∑–µ—Ä–≤–Ω–∞—è –∫–æ–ø–∏—è —Å–æ–∑–¥–∞–Ω–∞: {backup_dir}", LogLevel.INFO)

    def run_qemu(self, iso_image: str, clean_after: bool = False, gdb: bool = False) -> None:
        if not os.path.exists(iso_image):
            demo_iso_pattern = f"{self.config.DEMO_ISO_DIR}/{self.config.NAME.lower()}-v*"
            demo_isos = sorted(glob.glob(demo_iso_pattern), reverse=True)
            if demo_isos:
                iso_image = demo_isos[0]
                self.config.log(f"üîç –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –ø–æ—Å–ª–µ–¥–Ω–∏–π ISO: {iso_image}", LogLevel.INFO)
            else:
                self.config.log("‚ùå ISO –Ω–µ –Ω–∞–π–¥–µ–Ω", LogLevel.ERROR)
                return

        qemu_cmd = [
            self.config.QEMU_CMD,
            '-m', self.config.QEMU_MEMORY,
            '-cdrom', iso_image,
            '-d', 'guest_errors',
            '-no-reboot',
            '-name', f"{self.config.NAME} v{self.config.VERSION}"
        ]

        if gdb:
            qemu_cmd += ['-s', '-S']
            self.config.log(f"üêõ QEMU –≤ —Ä–µ–∂–∏–º–µ –æ—Ç–ª–∞–¥–∫–∏: target remote localhost:{self.config.QEMU_GDB_PORT}", LogLevel.INFO)

        if self.config.QEMU_SERIAL:
            qemu_cmd += ['-serial', 'stdio']

        if self.config.QEMU_AUDIO:
            qemu_cmd += ['-audiodev', 'pa,id=audio0', '-machine', 'pcspk-audiodev=audio0']

        if self.config.QEMU_NETWORK:
            qemu_cmd += ['-netdev', 'user,id=net0', '-device', 'e1000,netdev=net0']

        self.config.log("üöÄ –ó–∞–ø—É—Å–∫ QEMU...", LogLevel.INFO)
        try:
            subprocess.run(qemu_cmd, check=True)
        except subprocess.CalledProcessError as e:
            self.config.log(f"‚ùå QEMU –∑–∞–≤–µ—Ä—à–∏–ª—Å—è —Å –æ—à–∏–±–∫–æ–π: {e}", LogLevel.ERROR)
        except KeyboardInterrupt:
            self.config.log("‚èπÔ∏è QEMU –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º", LogLevel.INFO)
        finally:
            if clean_after:
                self.clean()

    def generate_file_tree(self, path: str = '.', indent: str = '', last: bool = True, output_file=None) -> None:
        prefix = indent + ('‚îî‚îÄ‚îÄ ' if last else '‚îú‚îÄ‚îÄ ')
        name = os.path.basename(path)

        if os.path.isdir(path):
            output_file.write(f"{prefix}üìÅ {name}\n")
        else:
            output_file.write(f"{prefix}üìÑ {name}\n")

        if os.path.isdir(path):
            items = sorted(os.listdir(path))
            for i, item in enumerate(items):
                is_last = i == len(items) - 1
                new_indent = indent + ('    ' if last else '‚îÇ   ')
                self.generate_file_tree(os.path.join(path, item), new_indent, is_last, output_file)

    def save_file_tree(self) -> None:
        tree_file = self.config.TREE_FILE
        self.config.log(f"üå≥ –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –¥–µ—Ä–µ–≤–∞ —Ñ–∞–π–ª–æ–≤ –≤ {tree_file}", LogLevel.INFO)
        with open(tree_file, 'w', encoding='utf-8') as f:
            f.write(f"üå≥ –î–µ—Ä–µ–≤–æ —Ñ–∞–π–ª–æ–≤ –û–° {self.config.NAME} v{self.config.VERSION}\n")
            f.write(f"üìÖ –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–æ: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
            f.write("=" * 50 + "\n\n")
            self.generate_file_tree(output_file=f)
        self.config.log(f"‚úÖ –î–µ—Ä–µ–≤–æ —Ñ–∞–π–ª–æ–≤ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ –≤ {tree_file}", LogLevel.SUCCESS)

    def print_file_tree(self) -> None:
        self.save_file_tree()
        with open(self.config.TREE_FILE, 'r', encoding='utf-8') as f:
            print(f.read())

    def clean(self) -> None:
        dirs_to_clean = [self.config.BUILD_DIR, self.config.ISO_DIR]
        files_to_clean = [
            self.config.get_iso_image(),
            self.config.get_kernel_output(),
            self.config.get_kernel_binary(),
            self.config.BUILD_CACHE
        ]
        
        self.config.log("üßπ –û—á–∏—Å—Ç–∫–∞ –∞—Ä—Ç–µ—Ñ–∞–∫—Ç–æ–≤ —Å–±–æ—Ä–∫–∏", LogLevel.INFO)
        for directory in dirs_to_clean:
            if os.path.exists(directory):
                shutil.rmtree(directory)
                self.config.log(f"üóëÔ∏è –£–¥–∞–ª–µ–Ω–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è: {directory}", LogLevel.DEBUG)
        
        for file_pattern in files_to_clean:
            if os.path.exists(file_pattern):
                os.remove(file_pattern)
                self.config.log(f"üóëÔ∏è –£–¥–∞–ª–µ–Ω —Ñ–∞–π–ª: {file_pattern}", LogLevel.DEBUG)

    def check_tools(self) -> None:
        required_tools = [
            self.config.CC,
            self.config.LD,
            self.config.OBJCOPY,
            self.config.GRUB_FILE,
            self.config.GRUB_MKRESCUE,
            self.config.QEMU_CMD
        ]
        
        self.config.log("üîß –ü—Ä–æ–≤–µ—Ä–∫–∞ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ —Å–±–æ—Ä–∫–∏", LogLevel.INFO)
        missing_tools = []
        for tool in required_tools:
            try:
                subprocess.run(f"which {tool}", shell=True, check=True, 
                             stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                self.config.log(f"‚úÖ {tool} –Ω–∞–π–¥–µ–Ω", LogLevel.SUCCESS)
            except subprocess.CalledProcessError:
                missing_tools.append(tool)
                self.config.log(f"‚ùå –ù–µ –Ω–∞–π–¥–µ–Ω: {tool}", LogLevel.ERROR)
        
        if missing_tools:
            self.config.log(f"üí• –û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã: {', '.join(missing_tools)}", LogLevel.CRITICAL)
            sys.exit(1)

    def print_build_stats(self) -> None:
        build_time = time.time() - self.start_time
        self.config.log(f"üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Å–±–æ—Ä–∫–∏:", LogLevel.INFO)
        self.config.log(f"   ‚è±Ô∏è –í—Ä–µ–º—è: {build_time:.2f} —Å–µ–∫", LogLevel.INFO)
        self.config.log(f"   üì¶ –§–∞–π–ª–æ–≤ —Å–∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞–Ω–æ: {self.stats.compiled_files}/{self.stats.total_files}", LogLevel.INFO)
        self.config.log(f"   ‚ö° –°–∫–æ—Ä–æ—Å—Ç—å: {self.stats.compiled_files/build_time if build_time > 0 else 0:.1f} —Ñ–∞–π–ª–æ–≤/—Å–µ–∫", LogLevel.INFO)

    def build(self, debug: bool = False, versioned_iso: bool = False) -> None:
        self.print_banner()
        self.load_build_cache()
        
        if debug:
            self.config.CFLAGS += ' -g -DDEBUG'
            self.config.log("üêõ –†–µ–∂–∏–º –æ—Ç–ª–∞–¥–∫–∏ –≤–∫–ª—é—á–µ–Ω", LogLevel.INFO)
        
        self.check_tools()
        
        self.ensure_dir(self.config.BUILD_DIR)
        self.ensure_dir(self.config.BIN_DIR)
        self.ensure_dir(self.config.ISO_DIR)
        self.ensure_dir(self.config.DEMO_ISO_DIR)
        
        try:
            if not os.path.exists('os_config.json'):
                self.config.create_default_config('os_config.json')
            
            self.create_grub_cfg(self.config.GRUB_CFG)

            sources = self.find_sources()
            objects = self.compile_sources(sources, self.config.BUILD_DIR)
            
            boot_src = f"src/kernel/{BOOT_ASM}"
            obj = os.path.join(self.config.BUILD_DIR, "boot.o")

            if not os.path.exists(boot_src):
                self.config.log(f"üí• –§–∞—Ç–∞–ª—å–Ω–æ: –Ω–µ –Ω–∞–π–¥–µ–Ω —Ñ–∞–π–ª {boot_src}", LogLevel.CRITICAL)
                sys.exit(1)

            cmd = (
                f"{self.config.CC} {self.config.CFLAGS} "
                f"-x assembler-with-cpp -c {boot_src} -o {obj}"
            )
            self.config.log(f"üî® –ö–æ–º–ø–∏–ª—è—Ü–∏—è: {boot_src}", LogLevel.INFO)
            try:
                subprocess.run(cmd, shell=True, check=True)
                objects.insert(0, obj)
                self.config.log(f"‚úÖ Bootloader —Å–∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞–Ω", LogLevel.SUCCESS)
            except subprocess.CalledProcessError as e:
                self.config.log(f"‚ùå –û—à–∏–±–∫–∞ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ boot.s: {e}", LogLevel.ERROR)
                sys.exit(1)

            elf_kernel_path = self.config.get_kernel_output()
            self.link_kernel(
                objects=objects,
                output=elf_kernel_path,
                linker_script=f"src/kernel/{LINKER_SCRIPT}"
            )

            bin_kernel_path = self.config.get_kernel_binary()
            self.create_kernel_binary(elf_kernel_path, bin_kernel_path)

            iso_path = self.config.get_iso_image(versioned=versioned_iso)
            
            self.create_iso(
                kernel_bin=bin_kernel_path,
                iso_dir=self.config.ISO_DIR,
                grub_cfg_src=self.config.GRUB_CFG,
                iso_image=iso_path
            )
            
            self.compress_iso(iso_path)
            
            if versioned_iso:
                self.config.log(f"üìÄ ISO —Å–æ–∑–¥–∞–Ω: {iso_path}", LogLevel.INFO)
            else:
                demo_iso = self.config.get_iso_image(versioned=True)
                shutil.copy(iso_path, demo_iso)
                self.config.log(f"üìÄ ISO —Å–æ—Ö—Ä–∞–Ω–µ–Ω –∫–∞–∫: {demo_iso}", LogLevel.INFO)
            
            if self.config.BACKUP_BUILDS:
                self.backup_build()
            
            self.save_file_tree()
            self.save_build_cache()
            self.print_build_stats()
            
        except KeyboardInterrupt:
            self.config.log("‚èπÔ∏è –°–±–æ—Ä–∫–∞ –ø—Ä–µ—Ä–≤–∞–Ω–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º", LogLevel.ERROR)
            sys.exit(1)


def main() -> None:
    config = OSConfig()
    config.load_config()
    config._update_dynamic_names()

    parser = argparse.ArgumentParser(
        description=f'{config.NAME} OS Build System',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter
    )
    parser.add_argument('--clean', action='store_true', help='üßπ –û—á–∏—Å—Ç–∏—Ç—å –∞—Ä—Ç–µ—Ñ–∞–∫—Ç—ã —Å–±–æ—Ä–∫–∏')
    parser.add_argument('--run', action='store_true', help='üöÄ –°–æ–±—Ä–∞—Ç—å –∏ –∑–∞–ø—É—Å—Ç–∏—Ç—å –≤ QEMU')
    parser.add_argument('--debug', action='store_true', help='üêõ –°–±–æ—Ä–∫–∞ —Å –æ—Ç–ª–∞–¥–æ—á–Ω—ã–º–∏ —Å–∏–º–≤–æ–ª–∞–º–∏')
    parser.add_argument('--demo', action='store_true', 
                       help='üìÄ –°–æ–∑–¥–∞—Ç—å –≤–µ—Ä—Å–∏–æ–Ω–Ω—ã–π ISO –≤ –ø–∞–ø–∫–µ demo_iso')
    parser.add_argument('--name', type=str, help='üåà –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∏–º—è –û–°')
    parser.add_argument('--version', type=str, help='üì¶ –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –≤–µ—Ä—Å–∏—é –û–°')
    parser.add_argument('--author', type=str, help='üë§ –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∞–≤—Ç–æ—Ä–∞ –û–°')
    parser.add_argument('--description', type=str, help='üìù –£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –æ–ø–∏—Å–∞–Ω–∏–µ –û–°')
    parser.add_argument('--save-config', action='store_true', 
                       help='üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ç–µ–∫—É—â—É—é –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é')
    parser.add_argument('--edit-config', action='store_true', 
                       help='üåÄ –ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–æ–µ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏')
    parser.add_argument('--clean-after-run', action='store_true', 
                       help='üßπ –û—á–∏—Å—Ç–∏—Ç—å –∞—Ä—Ç–µ—Ñ–∞–∫—Ç—ã –ø–æ—Å–ª–µ –∑–∞–ø—É—Å–∫–∞ QEMU')
    parser.add_argument('--gdb', action='store_true', 
                       help='üêõ –ó–∞–ø—É—Å—Ç–∏—Ç—å QEMU –≤ —Ä–µ–∂–∏–º–µ –æ—Ç–ª–∞–¥–∫–∏ GDB')
    parser.add_argument('--tree', action='store_true', 
                       help='üå≥ –ü–æ–∫–∞–∑–∞—Ç—å –¥–µ—Ä–µ–≤–æ —Ñ–∞–π–ª–æ–≤ –∏ –ø–∞–ø–æ–∫ –û–° –∏ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –≤ —Ñ–∞–π–ª')
    parser.add_argument('--grub-timeout', type=int, help='‚è∞ –¢–∞–π–º–∞—É—Ç –º–µ–Ω—é GRUB –≤ —Å–µ–∫—É–Ω–¥–∞—Ö')
    parser.add_argument('--grub-default', type=int, help='üîò –ù–æ–º–µ—Ä –ø—É–Ω–∫—Ç–∞ –º–µ–Ω—é –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é')
    parser.add_argument('--no-grub-menu', action='store_true', help='üö´ –û—Ç–∫–ª—é—á–∏—Ç—å –º–µ–Ω—é GRUB (–º–≥–Ω–æ–≤–µ–Ω–Ω—ã–π –∑–∞–ø—É—Å–∫)')
    parser.add_argument('--parallel', action='store_true', help='‚ö° –í–∫–ª—é—á–∏—Ç—å –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω—É—é —Å–±–æ—Ä–∫—É')
    parser.add_argument('--no-parallel', action='store_true', help='üêå –û—Ç–∫–ª—é—á–∏—Ç—å –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω—É—é —Å–±–æ—Ä–∫—É')
    parser.add_argument('--workers', type=int, help='üë• –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ—Ç–æ–∫–æ–≤ –¥–ª—è —Å–±–æ—Ä–∫–∏')
    parser.add_argument('--optimize', type=str, help='üöÄ –£—Ä–æ–≤–µ–Ω—å –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ (O0, O1, O2, O3, Os)')
    parser.add_argument('--compress', action='store_true', help='üóúÔ∏è –°–∂–∞—Ç—å ISO –æ–±—Ä–∞–∑')
    parser.add_argument('--backup', action='store_true', help='üíæ –°–æ–∑–¥–∞—Ç—å —Ä–µ–∑–µ—Ä–≤–Ω—É—é –∫–æ–ø–∏—é —Å–±–æ—Ä–∫–∏')
    parser.add_argument('--stats', action='store_true', help='üìä –ü–æ–∫–∞–∑–∞—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø—Ä–µ–¥—ã–¥—É—â–µ–π —Å–±–æ—Ä–∫–∏')
    
    args = parser.parse_args()
    
    if args.edit_config:
        config.edit_config_interactive()
        return
    
    updated = False

    if args.name:
        config.NAME = args.name
        config._update_dynamic_names()
        config.save_config()
        config.log(f"‚úÖ –ò–º—è –û–° —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ –∫–∞–∫ '{config.NAME}'", LogLevel.SUCCESS)
        updated = True

    if args.version:
        config.VERSION = args.version
        config.save_config()
        config.log(f"‚úÖ –í–µ—Ä—Å–∏—è —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞: {config.VERSION}", LogLevel.SUCCESS)
        updated = True

    if args.author:
        config.AUTHOR = args.author
        config.save_config()
        updated = True

    if args.description:
        config.DESCRIPTION = args.description
        config.save_config()
        updated = True

    if args.grub_timeout is not None:
        config.GRUB_TIMEOUT = args.grub_timeout
        config.save_config()
        config.log(f"‚úÖ –¢–∞–π–º–∞—É—Ç GRUB —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω: {config.GRUB_TIMEOUT} —Å–µ–∫", LogLevel.SUCCESS)
        updated = True

    if args.no_grub_menu:
        config.GRUB_TIMEOUT = -1
        config.save_config()
        config.log("‚úÖ –ú–µ–Ω—é GRUB –æ—Ç–∫–ª—é—á–µ–Ω–æ (–º–≥–Ω–æ–≤–µ–Ω–Ω—ã–π –∑–∞–ø—É—Å–∫)", LogLevel.SUCCESS)
        updated = True

    if args.grub_default is not None:
        config.GRUB_DEFAULT = args.grub_default
        config.save_config()
        config.log(f"‚úÖ –ü—É–Ω–∫—Ç –º–µ–Ω—é GRUB –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é: {config.GRUB_DEFAULT}", LogLevel.SUCCESS)
        updated = True

    if args.parallel:
        config.PARALLEL_BUILD = True
        config.save_config()
        config.log("‚úÖ –ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω–∞—è —Å–±–æ—Ä–∫–∞ –≤–∫–ª—é—á–µ–Ω–∞", LogLevel.SUCCESS)
        updated = True

    if args.no_parallel:
        config.PARALLEL_BUILD = False
        config.save_config()
        config.log("‚úÖ –ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω–∞—è —Å–±–æ—Ä–∫–∞ –æ—Ç–∫–ª—é—á–µ–Ω–∞", LogLevel.SUCCESS)
        updated = True

    if args.workers:
        config.MAX_WORKERS = args.workers
        config.save_config()
        config.log(f"‚úÖ –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ—Ç–æ–∫–æ–≤ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ: {config.MAX_WORKERS}", LogLevel.SUCCESS)
        updated = True

    if args.optimize:
        config.OPTIMIZATION_LEVEL = args.optimize
        config.save_config()
        config.log(f"‚úÖ –£—Ä–æ–≤–µ–Ω—å –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω: {config.OPTIMIZATION_LEVEL}", LogLevel.SUCCESS)
        updated = True

    if args.compress:
        config.COMPRESS_ISO = True
        config.save_config()
        config.log("‚úÖ –°–∂–∞—Ç–∏–µ ISO –≤–∫–ª—é—á–µ–Ω–æ", LogLevel.SUCCESS)
        updated = True

    if args.backup:
        config.BACKUP_BUILDS = True
        config.save_config()
        config.log("‚úÖ –†–µ–∑–µ—Ä–≤–Ω–æ–µ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ –≤–∫–ª—é—á–µ–Ω–æ", LogLevel.SUCCESS)
        updated = True

    if args.clean_after_run:
        config.QEMU_CLEAN_AFTER_RUN = True
        config.save_config()

    if args.save_config or updated:
        config.save_config()
        return
    
    builder = BuildSystem(config)
    
    if args.tree:
        builder.print_file_tree()
        return
    
    if args.stats:
        builder.load_build_cache()
        builder.print_build_stats()
        return
    
    if args.clean:
        builder.clean()
        return
    
    builder.build(
        debug=args.debug,
        versioned_iso=args.demo or args.run
    )
    
    if args.run:
        iso_path = config.get_iso_image(versioned=True)
        if not os.path.exists(iso_path):
            iso_path = config.get_iso_image()
        
        builder.run_qemu(
            iso_path,
            clean_after=args.clean_after_run or config.QEMU_CLEAN_AFTER_RUN,
            gdb=args.gdb
        )


if __name__ == '__main__':
    main()