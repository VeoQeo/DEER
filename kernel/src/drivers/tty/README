экран у нас поделен на "служебная часть экрана" и "пользовательская часть экрана". 
По умолчанию служебная занимает 25 ячеек (регулируется константой VGA_PROMPT_LENGTH. Вся длина экрана VGA_OUTPUT_LENGTH).
Высота служебной части VGA_PROMPT_HEIGHT, высота беклога VGA_BACKLOG_HEIGHT

ОБЩАЯ ИДЕЯ: 
backlog у нас 75 строк в высоту и 80 в длину. Что такое backlog? backlog хранит весь инпут пользователя 
(пользовательская часть экрана). Из-за особенностей, длина backlog равна всей длине экрана VGA_OUTPUT_LENGTH, 
но отрисовываем мы с VGA_PROMPT_LENGTH ячейки (если смотреть по координате x вдоль строки). ТО ЕСТЬ, история 
введенных пользователей символов будет записын в backlog.symbols ТОЛЬКО НАЧИНАЯ С VGA_PROMPT_LENGTH по координате x.
То есть -> symbols[<тут начинаем с 0>][!<ТУТ ВСЕГДА НАЧИНАЕМ С VGA_PROMPT_LENGTH>]. Во время отрисовки самого монитора,
мы отрисовываем весь беклог, ПОВЕРХ БЕКЛОГА мы отрисовываем prompt_field.symbols (то есть поверх отрисованных пустых ячеек 
на экране пишем служебную информацию). Все массивы у нас двумерные, так как по ним удобнее отрисовывать ячейки, так как монитор 
можно представить в виде оси координат (вроде уже должны начать проходить в школе). Кроме буффера getchar_buffer, он линейный 
(о нем позже). Когда мы начинаем что-то писать (самое начало работы после инициализации) мы отрисовываем от 0 строки 
беклога (то есть по y) до 24 строки включительно (такуже по координате y), а записываем символы в 0 строку 
(то есть начало границы) и в 25 координату по x (от 0 до 24 мы не трогам, они пустые по умолчанию, 
это служебные данные как и упоминалось ранее, их место зарезервировано константой VGA_PROMPT_LENGTH, 
их данные по отрисовке хранит prompt_field (от 0 до 74 включительно по умолчанию строк регулирует константа VGA_PROMPT_HEIGTH 
и до 24 колонки (регулирует константа VGA_PROMPT_LENGTH)). Итого как строится отрисовка. У нас 75 строк backlog и в prompt_field.
Во время MODE_INIT (описание смотри ниже) мы инициализируем ВСЕ ячейки пустым значением, цвета выставлены по умолчанию черный фон - 
зеленый символ. Сперва берем структуру backlog, достаем символ ячейки по y и по x из двумерного массива symbols, берем цвет символа из
blended_color по y и по x, смешиваем их с помощью ф-ии vga_cell и выводим на экран. После того как отрисовали беклог (напоминаю, 
что backlog у нас хранит ячейки от 0 до 80 по x (то есть вся длина монитора, НО НИКОГДА НЕ ОТРИСОВЫВАЕТ ПЕРВЫЕ VGA_PROMPT_LENGTH). 
ПОВЕРХ ЭТИХ ПУСТЫХ ЯЧЕЕК ЦВЕТА ФОНА мы отрисовываем данные из prompt_field), отрисовываем prompt_field. Там схема та же: достаем 
символ ячейки по y и по x из двумерного массива symbols, берем цвет символа из blended_color по y и по x, смешиваем их с помощью 
ф-ии vga_cell и выводим на экран. Цвета в backlog.blended_color и prompt_field.blended_color смешаны с помощью ф-ии vga_blend_color.
Мы берем цвет фона, цвет символа (цвета темы хранятся в переменных tty_symbol_color_theme и tty_background_color_theme. По умолчанию, 
как и упоминалось ранее черный фон и зеленый символ), и совмещаем их, сдвинув 4 бита фона. Почему мы храним blended_color и symbols отдельно? 
Есть функция изменения цветовой палитры. Она принимает два аргумента и меняет значения цветов в backlog.blended_color и
prompt_field.blended_color, а затем отрисовывает эти структуры по текущим границам upper_limit и lower_limit на монитор. 
По этой причине смешанный цвет (цвет фона + цвет символа) мы храним отдельно от символов! Так проще менять тему консоли. 

С историей понятно, что с текущим вводом с клавиатуры? За это отвечает getchar_buffer[GETCHAR_MAX_LENGTH], как упоминалось раннее
он линейный, так как в таком случае проще хранить введенные символы без трудностей в размещении спец символов, обработки backspace, tab и тд.
Инициализируется ' ', цвет символа и фона равен tty_background_color_theme. ВАЖНО! Мы храним параметр кол-ва введенных символов 
getchar_buffer_length, она НЕ УЧИТЫВАЕТ инициализированные ' '. Счетчик увеличивается с учетом вызова команды getchar -> если обычный символ,
space, то getchar_buffer_length++, для tab getchar_buffer_length += TAB (константа табуляции, по умолчанию 4), при backspace getchar_buffer_length--. 
prompt_start_line хранит значение y, где ФАКТИЧЕСКИ был введен первый символ (важный параметр, особенно во время скроллинга).
Если говорить проще, getchar_buffer временный буфер для обработки команды getchar. Для putchar putchar_buffer, но он уже двумерный,
так как в таком случае гораздо проще скопировать весь буфер РАЗОМ на экран. По сути он представляет из себя сетку координат, по которым
мы обрабатываем символ. putchar_act_coordinate[2] хранит значения y и x ТЕКУЩЕЙ СВОБОДНОЙ ЯЧЕЙКИ, куда поместим следующий символ.
То есть -> вызываем putchar('x') -> внутри putchar определяет, что это обычный символ, вызывавет put_default_symbol('x') -> внутри 
put_default_symbol достает y = putchar_act_coordinate[0]; x = putchar_act_coordinate[1] и ПОМЕЩАЕТ СИМВОЛ В ЭТИ КООРДИНАТЫ, после чего 
увеличивает счетчики с учетом края правой границы (x == 79 увеличиваем y++, а x == VGA_PROMPT_LENGTH). ВАЖНО! putchar_buffer полностью
копирует логику backlog! то есть первые VGA_PROMPT_LENGTH символов от левого края ВСЕГДА ЗАРЕЗЕРВИРОВАНЫ И НЕ ОТРИСОВЫВАЮТСЯ.

upper_limit и lower_limit хранят координату y backlog. upper_limit = y, lower_limit = y + 24. Аналогия: backlog это типо как манускрипт,
длинный сверток, чтобы его прочитать - необходимо разместить на столе. Каждая строка на манускрипте у нас 1см, в ширину манускрипт у нас
VGA_OUTPUT_LENGTH, стол, на котором будем рассматривать манускрипт длиной VGA_OUTPUT_LENGTH, и высотой VGA_OUTPUT_HEIGHT (ТО ЕСТЬ 25см),
то бишь на столе у нас разместится только 25 строк манускрипта, остальная часть свертка будет свисать со стола. По мере дохождения нами 
до нижней границы (25 строка == край стола), мы двигаем весь манускрипт ВВЕРХ, получается что первая строка (нулевой индекс по y) 
начнет свисать со стола сверху, а нижняя его часть подтянется на стол. 

дальше идут структура с параметрами курсора (его форма, и координаты), тут все просто, за них отвечают четыре функции 
(в тек. реализации 3): get_cursor_position(), set_cursor_shape() и update_cursor_position(); первая получает текущие координаты 
на МОНИТОРЕ, вторая устанавливает настройки курсора (по умолчанию подчеркнутый, мигающий) и update_cursor_position изменяет координаты
в структуре.

КАК ПРОИСХОДЯТ ИЗМЕНЕНИЯ: до backlog и prompt_field имеет доступ только terminal_update, до cursor_position имеет доступ 
только ф-ии курсора (их 4),до getchar_buffer имеет доступ только getchar, до putchar_buffer только putchar. Пока у нас нет 
мютекс, временное решение от гонки данных это разделить доступы в общей структуре (потому как не все эти ф-ии будут вызываться 
в terminal_update).

ПРИНЦИП РАБОТЫ: У нас есть terminal_update, которая имеет доступ к parameter_info (главная tty структура со всем вышеописанными 
параметрами). Она получает доступ к ней по указателю через ф-ю interact_tty_parameters (в прочем и везде, где нужен прямой доступ 
к parameter_info мы вызываем interact_tty_parameters, это те функции, которые имеют доступ к своим облостям. Эти ф-ии описаны в пункте
"КАК ПРОИСХОДЯТ ИЗМЕНЕНИЯ"). Далее terminal_update вызывается в других функциях, которым необходимо вывести инфу на экран. Они в стеке 
создают экземпляр структуры &request, заполняют необходимые данные и указывают мод для обработки, после передают ее в 
terminal_update(&request) как аргумент. Все структуры объеденены в union для экономии места. Как это выглядит: 

Список модов из tty-render.h:  
typedef enum {
    /*terminal-control*/
    MODE_INIT,            //>>обновляет всю сетку (2000 символов при размере 80х25)
    MODE_SCROLL_UP,       //>>скроллер вверх
    MODE_SCROLL_DOWN,     //>>скроллер вниз
    MODE_SET_COLOR_THEME, //>>сменить цвет темы
    MODE_CLEAR,

    /*getchar*/
    MODE_RETURN_CARRIEGE_INPUT, //>>\r возврат каретки
    MODE_BACKSPACE_INPUT,       //>>бекспейс
    MODE_TAB_INPUT,             //>>табуляция
    MODE_SPACE_INPUT,           //>>пробел
    MODE_CHAR_INPUT,            //>>вывод одного символа
    MODE_ENTER_INPUT,           //>>вызов print_username

    /*printf/putchar*/
    MODE_RETURN_CARRIAGE_OUTPUT,
    MODE_BACKSPACE_OUTPUT, //>>\b возврат на 1 символ назад
    MODE_TAB_OUTPUT,       //>>\t 4 пробела
    MODE_CHAR_OUTPUT,

} set_mode_t;

НАПРИМЕР, возьмем MODE_SET_COLOR_THEME. 

Под него в tty-render.h выделена структура:
/*MODE_SET_COLOR_THEME*/
typedef struct {
    uint8_t symbol_color_theme;
    uint8_t background_color_theme;

} set_color_theme_data;

ВОТ ТАК ВЫГЛЯДИТ СХЕМА ДЛЯ request:

// ДАННЫЕ ЗАПРОСА НА ИЗМЕНЕНИЕ
typedef struct {
    set_mode_t mode;                //<<ВОТ ТУТ УКАЗЫВАЕМ МОД MODE_SET_COLOR_THEME!

    // ~используем юнион для экономии места
    union {
        //..все структуры под каждый мод

        set_color_theme_data set_color;   //<<НАША СТРУКТУРА!

    } params;

} update_request_t;

Пример реализации terminal_set_color:
// УСТАНОВИТЬ ЦВЕТ
void terminal_set_color(uint8_t symbol_color_theme, uint8_t background_color_theme) {
    update_request_t request; //<<СОЗДАЕМ ОБРАЩЕНИЕ НА ИЗМЕНЕНИЕ ТЕМЫ

    request.mode = MODE_SET_COLOR_THEME;  //<<УКАЗЫВАЕМ МОД ОТРИСОВКИ

    request.params.set_color.symbol_color_theme = symbol_color_theme;           //<<ЗАПОЛНЯЕМ ПАРАМЕТРЫ СТРУКТУРЫ set_color
    request.params.set_color.background_color_theme = background_color_theme;  //<<ЗАПОЛНЯЕМ ПАРАМЕТРЫ СТРУКТУРЫ set_color

    terminal_update(&request); //<<ПЕРЕДАЕМ АДРЕС СТРУКТУРЫ С ДАННЫМИ ДЛЯ ОТРИСОВКИ 
}

ПОДРОБНЕЕ ПРО КАЖДЫЙ МОД: 

MODE_INIT:
Этот мод вызывает ф-я terminal_init() при запуске ОС, она инициализирует весь backlog, prompt_field пробелами с цветом фона (пустой экран)
и инициализирует начальные данные главной структуры tty (parameter_info). Мы формируем данные для отрисовки в terminal_init, так как
в будущем скорее всего с помощью этой функции будем обрабатывать логику отображения логитипа, поэтому целесообразнее все данные
прописать там, а в terminal_update передавать то, что необходимо отрисовать. Аналогично с цветами, они инициализируются в этой же
функции, пока там стояит константные значения, позже можно передавать с параметрами запуска.

MODE_CLEAR: 
По аналогии с MODE_INIT, но он очищает экран, а не инициализирует его. Вызвает ф-я terminal_clear().

MODE_CHAR_INPUT:
Этот мод вызывает ф-я get_default_symbol() (в случае если это обычный символ!) в request к terminal_update. 
Сама get_default_symbol вызывается внутри getchar(). Что делает? Она добавляет символ в getchar_buffer по текущей координате курсора,
увеличивает счетчик. Есть несколько сценариев: символ в конце предложения (но не строки), символ в середине строки и символ 
в конце строки (правая граница монитора). В первых двух случаях мы двигаем ВЕСЬ getchar_buffer вправо (то есть все
инициализированные пробелы и символы), а по индексу курсора присваивает символ. В этих сценариях мы изменяем ТОЛЬКО СТРОКИ, затронутые 
getchar_buffer. В случае, если символ оказался в конце строки (край правой границы монитора), проверяем, есть ли еще место внизу для строки,
если да, просто распечатываем символ на новой строке, в таком случае повторяется превый сценарий, перерисовываются только кол-во ячеек равное
длине getchar_buffer (из самого getchar_buffer). В случае если внизу нижняя граница экрана, то нужно сделать скролл, в таком случае увеличиваем 
upper_limit и lower_limit, распечатываем беклог по границам обновленных upper_limit и lower_limit, затем поверх распечатываем 
prompt_field, а уже после getchar_buffer. 

MODE_SPACE_INPUT:
Этот мод вызывает ф-я space() в request к terminal_update. Сама get_default_symbol вызывается внутри getchar(). Далее обработка 
схожа, как в MODE_CHAR_INPUT 

MODE_TAB_INPUT:
Этот мод вызывает ф-я tab() в request к terminal_update. Сама get_default_symbol вызывается внутри getchar(). Далее обработка 
схожа, как в MODE_SPACE_INPUT, но с 4 пробелами. 

MODE_BACKSPACE_INPUT:
*в разработке, будет вызываться backspace() в request к terminal_update. Сама get_default_symbol вызывается внутри getchar(). 
Обработка схожа с MODE_SPACE_INPUT, но в обратную сторону (если в space мы увеличиваем getchar_buffer_length++, то в backspace мы его 
уменьшаем getchar_buffer_length--)



